import{mat4,vec3,quat,glMatrix}from"gl-matrix";import AmmoLib from"ammo";let gl=null;function initWebGLContext(canvasName){const canvas=document.getElementById(canvasName);if(canvas===null){console.log(`Failed to get a canvas element with the name "${canvasName}"`);return false}gl=canvas.getContext("webgl",{alpha:false,premultipliedAlpha:false});return true}let Ammo=null;let world=null;function initAmmo(){return new Promise(resolve=>{AmmoLib().then(result=>{Ammo=result;const collisionConfiguration=new Ammo.btDefaultCollisionConfiguration;const dispatcher=new Ammo.btCollisionDispatcher(collisionConfiguration);const overlappingPairCache=new Ammo.btDbvtBroadphase;const solver=new Ammo.btSequentialImpulseConstraintSolver;world=new Ammo.btDiscreteDynamicsWorld(dispatcher,overlappingPairCache,solver,collisionConfiguration);world.setGravity(new Ammo.btVector3(0,-9.8,0));resolve()})})}async function createShaderProgram(path,vertShaderFileName,fragShaderFileName){let response=await fetch(path+vertShaderFileName);const vertShaderSource=await response.text();response=await fetch(path+fragShaderFileName);const fragShaderSource=await response.text();const vShader=gl.createShader(gl.VERTEX_SHADER);gl.shaderSource(vShader,vertShaderSource);gl.compileShader(vShader);let ok=gl.getShaderParameter(vShader,gl.COMPILE_STATUS);if(!ok){console.log(`${fragShaderFileName}: ${gl.getShaderInfoLog(vShader)}`);return null}const fShader=gl.createShader(gl.FRAGMENT_SHADER);gl.shaderSource(fShader,fragShaderSource);gl.compileShader(fShader);ok=gl.getShaderParameter(vShader,gl.COMPILE_STATUS);if(!ok){console.log(`${vertShaderFileName}: ${gl.getShaderInfoLog(fShader)}`);return null}const program=gl.createProgram();gl.attachShader(program,vShader);gl.attachShader(program,fShader);gl.linkProgram(program);ok=gl.getProgramParameter(program,gl.LINK_STATUS);if(!ok){console.log(`Link error with shaders ${vertShaderFileName}`+` and ${fragShaderFileName}`);console.log(gl.getProgramInfoLog(program));return null}gl.useProgram(program);return program}async function initVertexBuffers(path,modelNames){const vertexBuffers={};for(let i=0;i<modelNames.length;i++){const contentResponse=await fetch(path+modelNames[i]+".dae");const content=await contentResponse.text();const parser=new DOMParser;const xmlDoc=parser.parseFromString(content,"text/xml");const expForIndexes="//*[local-name() = 'p']/text()";let nodes=xmlDoc.evaluate(expForIndexes,xmlDoc,null,XPathResult.ANY_TYPE,null);let result=nodes.iterateNext();const order=result.textContent.trim().split(" ").map(value=>{return parseInt(value)});const partOfPositionsId="mesh-positions-array";const expForPositions=`//*[local-name() = 'float_array'][substring(@id, string-length(@id) -`+`string-length('${partOfPositionsId}') + 1) = '${partOfPositionsId}']`;nodes=xmlDoc.evaluate(expForPositions,xmlDoc,null,XPathResult.ANY_TYPE,null);result=nodes.iterateNext();const positions=result.textContent.trim().split(" ").map(value=>{return parseFloat(value)});const partOfNormalsId="mesh-normals-array";const expForNormals=`//*[local-name() = 'float_array'][substring(@id, string-length(@id) -`+`string-length('${partOfNormalsId}') + 1) = '${partOfNormalsId}']`;nodes=xmlDoc.evaluate(expForNormals,xmlDoc,null,XPathResult.ANY_TYPE,null);result=nodes.iterateNext();const normals=result.textContent.trim().split(" ").map(value=>{return parseFloat(value)});const partOfTexCoordsId="mesh-map-0-array";const expForTexCoords=`//*[local-name() = 'float_array'][substring(@id, string-length(@id) -`+`string-length('${partOfTexCoordsId}') + 1) = '${partOfTexCoordsId}']`;nodes=xmlDoc.evaluate(expForTexCoords,xmlDoc,null,XPathResult.ANY_TYPE,null);result=nodes.iterateNext();const texCoords=result.textContent.trim().split(" ").map(value=>{return parseFloat(value)});const correctionMatrix=mat4.create();mat4.fromXRotation(correctionMatrix,-Math.PI/2);const vertPosResult=[];const normalsResult=[];const texCoordsResult=[];const amountOfTriangles=order.length/9;for(let i=0;i<amountOfTriangles;i++){for(let j=0;j<9;j++){if((i*9+j)%3===0){const vx=positions[order[i*9+j]*3+0];const vy=positions[order[i*9+j]*3+1];const vz=positions[order[i*9+j]*3+2];const oldPos=vec3.fromValues(vx,vy,vz);const newPos=vec3.create();vec3.transformMat4(newPos,oldPos,correctionMatrix);vertPosResult.push(newPos[0]);vertPosResult.push(newPos[1]);vertPosResult.push(newPos[2])}else if((i*9+j)%3===1){const nx=normals[order[i*9+j]*3+0];const ny=normals[order[i*9+j]*3+1];const nz=normals[order[i*9+j]*3+2];const oldNormal=vec3.fromValues(nx,ny,nz);const newNormal=vec3.create();vec3.transformMat4(newNormal,oldNormal,correctionMatrix);normalsResult.push(newNormal[0]);normalsResult.push(newNormal[1]);normalsResult.push(newNormal[2])}else if((i*9+j)%3===2){texCoordsResult.push(texCoords[order[i*9+j]*2+0]);texCoordsResult.push(texCoords[order[i*9+j]*2+1])}}}const vertPosBuffer=gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER,vertPosBuffer);gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(vertPosResult),gl.STATIC_DRAW);const normalBuffer=gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER,normalBuffer);gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(normalsResult),gl.STATIC_DRAW);const texCoordBuffer=gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER,texCoordBuffer);gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(texCoordsResult),gl.STATIC_DRAW);const buffers={vertPosBuffer:vertPosBuffer,normalBuffer:normalBuffer,texCoordBuffer:texCoordBuffer,amountOfVertices:vertPosResult.length/3};vertexBuffers[modelNames[i]]=buffers}return vertexBuffers}class DebugDrawer{constructor(edge){this.edge=edge;this.projViewMatrix=null;this.heap=null;this.debugDrawer=new Ammo.DebugDrawer;this.debugDrawer.drawLine=((from,to,color)=>{this.drawLine(from,to,color)}).bind(this);this.debugDrawer.setDebugMode=()=>{};this.debugMode=1;this.debugDrawer.getDebugMode=()=>{return this.debugMode};this.debugDrawer.setDebugMode(1);this.debugDrawer.drawContactPoint=(pointOnB,normalOnB,distance,lifeTime,color)=>{};this.debugDrawer.reportErrorWarning=warningString=>{};this.debugDrawer.draw3dText=(location,textString)=>{};world.setDebugDrawer(this.debugDrawer);this.fromX=0;this.fromY=0;this.fromZ=0;this.toX=0;this.toY=0;this.toZ=0;this.r=0;this.g=0;this.b=0;this.centerX=0;this.centerY=0;this.centerZ=0;this.length=0;this.vec=vec3.create();this.x=0;this.y=0;this.z=0;this.unitX=vec3.fromValues(1,0,0)}drawLine(from,to,color){this.heap=Ammo.HEAPF32;this.fromX=this.heap[(parseInt(from)+0)/4];this.fromY=this.heap[(parseInt(from)+4)/4];this.fromZ=this.heap[(parseInt(from)+8)/4];this.toX=this.heap[(parseInt(to)+0)/4];this.toY=this.heap[(parseInt(to)+4)/4];this.toZ=this.heap[(parseInt(to)+8)/4];this.r=this.heap[(parseInt(color)+0)/4];this.g=this.heap[(parseInt(color)+4)/4];this.b=this.heap[(parseInt(color)+8)/4];if(this.fromX>this.toX){this.centerX=this.toX+Math.abs(this.fromX-this.toX)/2}else{this.centerX=this.fromX+Math.abs(this.toX-this.fromX)/2}if(this.fromY>this.toY){this.centerY=this.toY+Math.abs(this.fromY-this.toY)/2}else{this.centerY=this.fromY+Math.abs(this.toY-this.fromY)/2}if(this.fromZ>this.toZ){this.centerZ=this.toZ+Math.abs(this.fromZ-this.toZ)/2}else{this.centerZ=this.fromZ+Math.abs(this.toZ-this.fromZ)/2}this.vec[0]=this.toX-this.fromX;this.vec[1]=this.toY-this.fromY;this.vec[2]=this.toZ-this.fromZ;this.length=vec3.length(this.vec);vec3.normalize(this.vec,this.vec);quat.rotationTo(this.edge.rotation,this.unitX,this.vec);this.edge.scale=[this.length,.02,.02];this.edge.position=[this.centerX,this.centerY,this.centerZ];this.edge.draw(this.projViewMatrix,[this.r,this.g,this.b])}}class Lightless{constructor(program,vertexBuffers){this.program=program;this.vertexBuffers=vertexBuffers;this.position=vec3.fromValues(0,0,0);this.rotation=quat.create();this.scale=vec3.fromValues(1,1,1);this.mvpMatrix=mat4.create();this.modelMatrix=mat4.create();gl.useProgram(program);this.aPositionLocation=gl.getAttribLocation(program,"aPosition");this.uMvpMatrixLocation=gl.getUniformLocation(program,"uMvpMatrix");this.uColorLocation=gl.getUniformLocation(program,"uColor")}bind(){gl.bindBuffer(gl.ARRAY_BUFFER,this.vertexBuffers.vertPosBuffer);gl.vertexAttribPointer(this.aPositionLocation,3,gl.FLOAT,false,0,0);gl.enableVertexAttribArray(this.aPositionLocation)}draw(projViewMatrix,color){gl.useProgram(this.program);mat4.fromRotationTranslationScale(this.modelMatrix,this.rotation,this.position,this.scale);mat4.mul(this.mvpMatrix,projViewMatrix,this.modelMatrix);gl.uniformMatrix4fv(this.uMvpMatrixLocation,false,this.mvpMatrix);gl.uniform3fv(this.uColorLocation,color);this.bind();gl.drawArrays(gl.TRIANGLES,0,this.vertexBuffers.amountOfVertices)}}class Collider{constructor(position,rotation,shape,mass){this.position=position;this.rotation=rotation;this.tempMotionState=null;this.tempTransform=new Ammo.btTransform;this.tempRotation=null;const initialPosition=new Ammo.btVector3(position[0],position[1],position[2]);const initialRotation=new Ammo.btQuaternion(rotation[0],rotation[1],rotation[2],rotation[3]);const transform=new Ammo.btTransform;transform.setIdentity();transform.setOrigin(initialPosition);transform.setRotation(initialRotation);const motionState=new Ammo.btDefaultMotionState(transform);const localInertia=new Ammo.btVector3(0,0,0);if(mass>=.001){shape.calculateLocalInertia(mass,localInertia)}const rbInfo=new Ammo.btRigidBodyConstructionInfo(mass,motionState,shape,localInertia);this.body=new Ammo.btRigidBody(rbInfo);this.body.setActivationState(4);this.body.setFriction(1);this.body.setRollingFriction(.1);world.addRigidBody(this.body)}update(){this.tempMotionState=this.body.getMotionState();if(this.tempMotionState){this.tempMotionState.getWorldTransform(this.tempTransform);this.position[0]=this.tempTransform.getOrigin().x();this.position[1]=this.tempTransform.getOrigin().y();this.position[2]=this.tempTransform.getOrigin().z();this.tempRotation=this.tempTransform.getRotation();this.rotation[0]=this.tempRotation.x();this.rotation[1]=this.tempRotation.y();this.rotation[2]=this.tempRotation.z();this.rotation[3]=this.tempRotation.w()}}}class Keyboard{constructor(){this.keys={};document.addEventListener("keydown",event=>{this.onKeyChange(event,true)},true);document.addEventListener("keyup",event=>{this.onKeyChange(event,false)},false)}pressed(key){return this.keys[key]}onKeyChange(event,pressed){this.keys[event.code]=pressed}}const projMatrix=mat4.create();const viewMatrix=mat4.create();const projViewMatrix=mat4.create();let debugDrawer;const TIME_STEP=1/60;const MAX_FRAME_TIME=.05;let lastTicks=0;let accumulator=0;let playerCollider,sphereCollider,boxCollider;const forward=vec3.fromValues(0,0,1);const direction=vec3.fromValues(forward[0],forward[1],forward[2]);const linearSpeed=5;const angularSpeed=5;const keyboard=new Keyboard;async function init(){if(!initWebGLContext("renderCanvas")){return}await initAmmo();gl.clearColor(.2,.2,.2,1);gl.enable(gl.DEPTH_TEST);const vertexBuffers=await initVertexBuffers("assets/models/",["cube"]);const lightlessProgram=await createShaderProgram("assets/shaders/","lightless.vert","lightless.frag");const lightless=new Lightless(lightlessProgram,vertexBuffers["cube"]);debugDrawer=new DebugDrawer(lightless);const groundSize=[10,.5,5];const groundShape=new Ammo.btBoxShape(new Ammo.btVector3(groundSize[0]/2,groundSize[1]/2,groundSize[2]/2));new Collider([0,-.5,0],[0,0,0,1],groundShape,0);const playserRadius=.5;const playerShape=new Ammo.btSphereShape(playserRadius);playerCollider=new Collider([0,2,0],[0,0,0,1],playerShape,80);playerCollider.body.setAngularFactor(0,1,0);playerCollider.body.setDamping(.9,.99);const sphereRadius=.3;const sphereShape=new Ammo.btSphereShape(sphereRadius);sphereCollider=new Collider([3,2,0],[0,0,0,1],sphereShape,10);const boxSize=[.5,.5,.5];const boxShape=new Ammo.btBoxShape(new Ammo.btVector3(boxSize[0]/2,boxSize[1]/2,boxSize[2]/2));boxCollider=new Collider([-3,2,0],[0,0,0,1],boxShape,30);mat4.lookAt(viewMatrix,vec3.fromValues(0,5,10),vec3.fromValues(0,1,0),vec3.fromValues(0,1,0));onResize();window.addEventListener("resize",onResize);lastTicks=performance.now();requestAnimationFrame(iterate)}function onResize(){const w=gl.canvas.clientWidth;const h=gl.canvas.clientHeight;gl.canvas.width=w;gl.canvas.height=h;const canvasAspect=w/h;gl.viewport(0,0,w,h);mat4.identity(projMatrix);mat4.perspective(projMatrix,glMatrix.toRadian(45),canvasAspect,.1,200);mat4.mul(projViewMatrix,projMatrix,viewMatrix);debugDrawer.projViewMatrix=projViewMatrix}function keyboardHandler(){if(keyboard.pressed("KeyW")||keyboard.pressed("ArrowUp")){const vy=playerCollider.body.getLinearVelocity().y();const impulse=new Ammo.btVector3(direction[0]*linearSpeed,vy,direction[2]*linearSpeed);playerCollider.body.setLinearVelocity(impulse)}if(keyboard.pressed("KeyS")||keyboard.pressed("ArrowDown")){const vy=playerCollider.body.getLinearVelocity().y();const impulse=new Ammo.btVector3(-direction[0]*linearSpeed,vy,-direction[2]*linearSpeed);playerCollider.body.setLinearVelocity(impulse)}if(keyboard.pressed("KeyA")||keyboard.pressed("ArrowLeft")){const impulse=new Ammo.btVector3(0,angularSpeed,0);playerCollider.body.setAngularVelocity(impulse)}if(keyboard.pressed("KeyD")||keyboard.pressed("ArrowRight")){const impulse=new Ammo.btVector3(0,-angularSpeed,0);playerCollider.body.setAngularVelocity(impulse)}if(!keyboard.pressed("KeyW")&&!keyboard.pressed("ArrowUp")&&!keyboard.pressed("KeyS")&&!keyboard.pressed("ArrowDown")&&!keyboard.pressed("KeyA")&&!keyboard.pressed("ArrowLeft")&&!keyboard.pressed("KeyD")&&!keyboard.pressed("ArrowRight")){const vy=playerCollider.body.getLinearVelocity().y();playerCollider.body.setLinearVelocity(new Ammo.btVector3(0,vy,0));playerCollider.body.setAngularVelocity(new Ammo.btVector3(0,0,0))}vec3.transformQuat(direction,forward,playerCollider.rotation)}function iterate(){keyboardHandler();const now=performance.now();let dt=(now-lastTicks)/1e3;lastTicks=now;if(dt>MAX_FRAME_TIME){dt=MAX_FRAME_TIME}accumulator+=dt;while(accumulator>=TIME_STEP){world.stepSimulation(TIME_STEP,8);accumulator-=TIME_STEP}playerCollider.update();sphereCollider.update();boxCollider.update();gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);{world.debugDrawWorld()}requestAnimationFrame(iterate)}init();