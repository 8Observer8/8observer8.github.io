import"oimo-physics";import{mat4,vec3,quat}from"gl-matrix";let gl=null;function initWebGLContext(canvasName){const canvas=document.getElementById(canvasName);if(canvas===null){console.log(`Failed to get a canvas element with the name "${canvasName}"`);return false}gl=canvas.getContext("webgl",{alpha:false,premultipliedAlpha:false});return true}async function createProgram(path,vertShaderFileName,fragShaderFileName){let response=await fetch(path+vertShaderFileName);const vertShaderSource=await response.text();response=await fetch(path+fragShaderFileName);const fragShaderSource=await response.text();const vShader=gl.createShader(gl.VERTEX_SHADER);gl.shaderSource(vShader,vertShaderSource);gl.compileShader(vShader);let ok=gl.getShaderParameter(vShader,gl.COMPILE_STATUS);if(!ok){console.log("vert: "+gl.getShaderInfoLog(vShader));return null}const fShader=gl.createShader(gl.FRAGMENT_SHADER);gl.shaderSource(fShader,fragShaderSource);gl.compileShader(fShader);ok=gl.getShaderParameter(vShader,gl.COMPILE_STATUS);if(!ok){console.log("frag: "+gl.getShaderInfoLog(fShader));return null}const program=gl.createProgram();gl.attachShader(program,vShader);gl.attachShader(program,fShader);gl.linkProgram(program);ok=gl.getProgramParameter(program,gl.LINK_STATUS);if(!ok){console.log("link: "+gl.getProgramInfoLog(program));return null}gl.useProgram(program);return program}async function initVertexBuffers(path,modelNames){const vertexBuffers={};for(let i=0;i<modelNames.length;i++){const contentResponse=await fetch(path+modelNames[i]+".dae");const content=await contentResponse.text();const parser=new DOMParser;const xmlDoc=parser.parseFromString(content,"text/xml");const expForIndexes="//*[local-name() = 'p']/text()";let nodes=xmlDoc.evaluate(expForIndexes,xmlDoc,null,XPathResult.ANY_TYPE,null);let result=nodes.iterateNext();const order=result.textContent.trim().split(" ").map(value=>{return parseInt(value)});const partOfPositionsId="mesh-positions-array";const expForPositions=`//*[local-name() = 'float_array'][substring(@id, string-length(@id) -`+`string-length('${partOfPositionsId}') + 1) = '${partOfPositionsId}']`;nodes=xmlDoc.evaluate(expForPositions,xmlDoc,null,XPathResult.ANY_TYPE,null);result=nodes.iterateNext();const positions=result.textContent.trim().split(" ").map(value=>{return parseFloat(value)});const partOfNormalsId="mesh-normals-array";const expForNormals=`//*[local-name() = 'float_array'][substring(@id, string-length(@id) -`+`string-length('${partOfNormalsId}') + 1) = '${partOfNormalsId}']`;nodes=xmlDoc.evaluate(expForNormals,xmlDoc,null,XPathResult.ANY_TYPE,null);result=nodes.iterateNext();const normals=result.textContent.trim().split(" ").map(value=>{return parseFloat(value)});const partOfTexCoordsId="mesh-map-0-array";const expForTexCoords=`//*[local-name() = 'float_array'][substring(@id, string-length(@id) -`+`string-length('${partOfTexCoordsId}') + 1) = '${partOfTexCoordsId}']`;nodes=xmlDoc.evaluate(expForTexCoords,xmlDoc,null,XPathResult.ANY_TYPE,null);result=nodes.iterateNext();const texCoords=result.textContent.trim().split(" ").map(value=>{return parseFloat(value)});const correctionMatrix=mat4.create();mat4.fromXRotation(correctionMatrix,-Math.PI/2);const vertPosResult=[];const normalsResult=[];const texCoordsResult=[];const amountOfTriangles=order.length/9;for(let i=0;i<amountOfTriangles;i++){for(let j=0;j<9;j++){if((i*9+j)%3===0){const vx=positions[order[i*9+j]*3+0];const vy=positions[order[i*9+j]*3+1];const vz=positions[order[i*9+j]*3+2];const oldPos=vec3.fromValues(vx,vy,vz);const newPos=vec3.create();vec3.transformMat4(newPos,oldPos,correctionMatrix);vertPosResult.push(newPos[0]);vertPosResult.push(newPos[1]);vertPosResult.push(newPos[2])}else if((i*9+j)%3===1){const nx=normals[order[i*9+j]*3+0];const ny=normals[order[i*9+j]*3+1];const nz=normals[order[i*9+j]*3+2];const oldNormal=vec3.fromValues(nx,ny,nz);const newNormal=vec3.create();vec3.transformMat4(newNormal,oldNormal,correctionMatrix);normalsResult.push(newNormal[0]);normalsResult.push(newNormal[1]);normalsResult.push(newNormal[2])}else if((i*9+j)%3===2){texCoordsResult.push(texCoords[order[i*9+j]*2+0]);texCoordsResult.push(texCoords[order[i*9+j]*2+1])}}}const vertPosBuffer=gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER,vertPosBuffer);gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(vertPosResult),gl.STATIC_DRAW);const normalBuffer=gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER,normalBuffer);gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(normalsResult),gl.STATIC_DRAW);const texCoordBuffer=gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER,texCoordBuffer);gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(texCoordsResult),gl.STATIC_DRAW);const buffers={vertPosBuffer:vertPosBuffer,normalBuffer:normalBuffer,texCoordBuffer:texCoordBuffer,amountOfVertices:vertPosResult.length/3};vertexBuffers[modelNames[i]]=buffers}return vertexBuffers}class DebugDrawer extends OIMO.DebugDraw{constructor(edge){super();this.edge=edge;this.projViewMatrix=null;this.centerX=0;this.centerY=0;this.centerZ=0;this.length=0;this.vec=vec3.create();this.x=0;this.y=0;this.z=0;this.unitX=vec3.fromValues(1,0,0)}point(v,color){console.log("point")}triangle(v1,v2,v3,n1,n2,n3,color){console.log("triangle")}line(from,to,color){this.edge.color[0]=color.x;this.edge.color[1]=color.y;this.edge.color[2]=color.z;if(from.x>to.x){this.centerX=to.x+Math.abs(from.x-to.x)/2}else{this.centerX=from.x+Math.abs(to.x-from.x)/2}if(from.y>to.y){this.centerY=to.y+Math.abs(from.y-to.y)/2}else{this.centerY=from.y+Math.abs(to.y-from.y)/2}if(from.z>to.z){this.centerZ=to.z+Math.abs(from.z-to.z)/2}else{this.centerZ=from.z+Math.abs(to.z-from.z)/2}this.vec[0]=to.x-from.x;this.vec[1]=to.y-from.y;this.vec[2]=to.z-from.z;this.length=vec3.length(this.vec);vec3.normalize(this.vec,this.vec);quat.rotationTo(this.edge.rotation,this.unitX,this.vec);this.edge.scale=[this.length,.2,.2];this.edge.position=[this.centerX,this.centerY,this.centerZ];this.edge.draw(this.projViewMatrix)}}class Object3D{constructor(program,vertexBuffers,color){this.program=program;this.vertexBuffers=vertexBuffers;this.color=color;this.position=vec3.create();this.rotation=quat.create();this.scale=vec3.fromValues(1,1,1);this.mvpMatrix=mat4.create();this.modelMatrix=mat4.create();this.normalMatrix=mat4.create();this.aPositionLocation=gl.getAttribLocation(program,"aPosition");this.aNormalLocation=gl.getAttribLocation(program,"aNormal");this.uMvpMatrixLocation=gl.getUniformLocation(program,"uMvpMatrix");this.uColorLocation=gl.getUniformLocation(program,"uColor");this.uModelMatrixLocation=gl.getUniformLocation(program,"uModelMatrix");this.uNormalMatrixLocation=gl.getUniformLocation(program,"uNormalMatrix")}bind(){gl.bindBuffer(gl.ARRAY_BUFFER,this.vertexBuffers.vertPosBuffer);gl.vertexAttribPointer(this.aPositionLocation,3,gl.FLOAT,false,0,0);gl.enableVertexAttribArray(this.aPositionLocation);gl.bindBuffer(gl.ARRAY_BUFFER,this.vertexBuffers.normalBuffer);gl.vertexAttribPointer(this.aNormalLocation,3,gl.FLOAT,false,0,0);gl.enableVertexAttribArray(this.aNormalLocation)}draw(projViewMatrix){gl.useProgram(this.program);mat4.fromRotationTranslationScale(this.modelMatrix,this.rotation,this.position,this.scale);mat4.mul(this.mvpMatrix,projViewMatrix,this.modelMatrix);gl.uniformMatrix4fv(this.uMvpMatrixLocation,false,this.mvpMatrix);gl.uniformMatrix4fv(this.uModelMatrixLocation,false,this.modelMatrix);gl.uniform3fv(this.uColorLocation,this.color);mat4.invert(this.normalMatrix,this.modelMatrix);mat4.transpose(this.normalMatrix,this.normalMatrix);gl.uniformMatrix4fv(this.uNormalMatrixLocation,false,this.normalMatrix);this.bind();gl.drawArrays(gl.TRIANGLES,0,this.vertexBuffers.amountOfVertices)}}class Lightless{constructor(program,vertexBuffers){this.program=program;this.vertexBuffers=vertexBuffers;this.color=[1,0,0];this.position=vec3.fromValues(0,0,0);this.rotation=quat.create();this.scale=vec3.fromValues(1,1,1);this.mvpMatrix=mat4.create();this.modelMatrix=mat4.create();gl.useProgram(program);this.aPositionLocation=gl.getAttribLocation(program,"aPosition");this.uMvpMatrixLocation=gl.getUniformLocation(program,"uMvpMatrix");this.uColorLocation=gl.getUniformLocation(program,"uColor")}bind(){gl.bindBuffer(gl.ARRAY_BUFFER,this.vertexBuffers.vertPosBuffer);gl.vertexAttribPointer(this.aPositionLocation,3,gl.FLOAT,false,0,0);gl.enableVertexAttribArray(this.aPositionLocation)}draw(projViewMatrix){gl.useProgram(this.program);mat4.fromRotationTranslationScale(this.modelMatrix,this.rotation,this.position,this.scale);mat4.mul(this.mvpMatrix,projViewMatrix,this.modelMatrix);gl.uniformMatrix4fv(this.uMvpMatrixLocation,false,this.mvpMatrix);gl.uniform3fv(this.uColorLocation,this.color);this.bind();gl.drawArrays(gl.TRIANGLES,0,this.vertexBuffers.amountOfVertices)}}class Keyboard{constructor(){this.keys={};document.addEventListener("keydown",event=>{this.onKeyChange(event,true)},true);document.addEventListener("keyup",event=>{this.onKeyChange(event,false)},false)}pressed(key){return this.keys[key]}onKeyChange(event,pressed){this.keys[event.code]=pressed}}class RayCaster{constructor(cube){this.cube=cube;this.projViewMatrix=null;this.fromX=0;this.fromY=0;this.fromZ=0;this.toX=0;this.toY=0;this.toZ=0;this.centerX=0;this.centerY=0;this.centerZ=0;this.length=0;this.vec=vec3.create();this.x=0;this.y=0;this.z=0;this.unitX=vec3.fromValues(1,0,0)}drawLine(from,to,thickness=.05){this.fromX=from[0];this.fromY=from[1];this.fromZ=from[2];this.toX=to[0];this.toY=to[1];this.toZ=to[2];if(this.fromX>this.toX){this.centerX=this.toX+Math.abs(this.fromX-this.toX)/2}else{this.centerX=this.fromX+Math.abs(this.toX-this.fromX)/2}if(this.fromY>this.toY){this.centerY=this.toY+Math.abs(this.fromY-this.toY)/2}else{this.centerY=this.fromY+Math.abs(this.toY-this.fromY)/2}if(this.fromZ>this.toZ){this.centerZ=this.toZ+Math.abs(this.fromZ-this.toZ)/2}else{this.centerZ=this.fromZ+Math.abs(this.toZ-this.fromZ)/2}this.vec[0]=this.toX-this.fromX;this.vec[1]=this.toY-this.fromY;this.vec[2]=this.toZ-this.fromZ;this.length=vec3.length(this.vec);vec3.normalize(this.vec,this.vec);quat.rotationTo(this.cube.rotation,this.unitX,this.vec);this.cube.scale=[this.length,thickness,thickness];this.cube.position=[this.centerX,this.centerY,this.centerZ];this.cube.draw(this.projViewMatrix)}}let ground,platform1,platform2,box,boxRigidBody,raycaster;let vertexBuffers,debugDrawer;const keyboard=new Keyboard;const linearSpeed=500;const projMatrix=mat4.create();mat4.perspective(projMatrix,55*Math.PI/180,1,.1,500);const viewMatrix=mat4.create();mat4.lookAt(viewMatrix,[0,0,20],[0,0,0],[0,1,0]);const projViewMatrix=mat4.create();mat4.mul(projViewMatrix,projMatrix,viewMatrix);const world=new OIMO.World;world.setGravity(new OIMO.Vec3(0,-50,0));let groundedLeft=false;let groundedRight=false;const rayCastCallback=new OIMO.RayCastCallback;const rayCastClosest=new OIMO.RayCastClosest;let showColliders=false;const showCollidersCheckbox=document.getElementById("colliderCheckBox");showColliders=showCollidersCheckbox.checked;showCollidersCheckbox.onchange=()=>{showColliders=showCollidersCheckbox.checked};const maxTimeStepMs=1/60*1e3;function step(deltaMs){const dt=Math.min(deltaMs,maxTimeStepMs);if((keyboard.pressed("KeyW")||keyboard.pressed("ArrowUp"))&&(groundedLeft||groundedRight)){const vel=boxRigidBody.getLinearVelocity();vel.y=30;boxRigidBody.setLinearVelocity(vel)}if(keyboard.pressed("KeyA")||keyboard.pressed("ArrowLeft")){const vy=boxRigidBody.getLinearVelocity().y;const impulse=new OIMO.Vec3(-1*linearSpeed*dt/1e3,vy,0);boxRigidBody.setLinearVelocity(impulse)}if(keyboard.pressed("KeyD")||keyboard.pressed("ArrowRight")){const vy=boxRigidBody.getLinearVelocity().y;const impulse=new OIMO.Vec3(1*linearSpeed*dt/1e3,vy,0);boxRigidBody.setLinearVelocity(impulse)}world.step(dt/1e3)}function draw(){gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);if(showColliders){world.debugDraw()}box.position[0]=boxRigidBody.getPosition().x;box.position[1]=boxRigidBody.getPosition().y;box.position[2]=boxRigidBody.getPosition().z;box.rotation[0]=boxRigidBody.getOrientation().x;box.rotation[1]=boxRigidBody.getOrientation().y;box.rotation[2]=boxRigidBody.getOrientation().z;box.rotation[3]=boxRigidBody.getOrientation().w;ground.draw(projViewMatrix);platform1.draw(projViewMatrix);platform2.draw(projViewMatrix);box.draw(projViewMatrix);raycaster.drawLine(vec3.fromValues(box.position[0],box.position[1]+1,0),vec3.fromValues(box.position[0],box.position[1]+2,0));let begin=new OIMO.Vec3(box.position[0],box.position[1]+1,0);let end=new OIMO.Vec3(box.position[0],box.position[1]+2,0);world.rayCast(begin,end,rayCastCallback);raycaster.drawLine(vec3.fromValues(box.position[0]-1.3,box.position[1]-1,0),vec3.fromValues(box.position[0]-1.3,box.position[1]-2,0));begin=new OIMO.Vec3(box.position[0]-1.3,box.position[1]-1,0);end=new OIMO.Vec3(box.position[0]-1.3,box.position[1]-2,0);world.rayCast(begin,end,rayCastClosest);if(rayCastClosest.hit){groundedLeft=true}else{groundedLeft=false}rayCastClosest.clear();raycaster.drawLine(vec3.fromValues(box.position[0]+1.3,box.position[1]-1,0),vec3.fromValues(box.position[0]+1.3,box.position[1]-2,0));begin=new OIMO.Vec3(box.position[0]+1.3,box.position[1]-1,0);end=new OIMO.Vec3(box.position[0]+1.3,box.position[1]-2,0);world.rayCast(begin,end,rayCastClosest);if(rayCastClosest.hit){groundedRight=true}else{groundedRight=false}rayCastClosest.clear()}async function init(){if(!initWebGLContext("renderCanvas"))return;gl.enable(gl.DEPTH_TEST);gl.clearColor(.2,.2,.2,1);gl.viewport(0,0,gl.drawingBufferWidth,gl.drawingBufferHeight);vertexBuffers=await initVertexBuffers("assets/models/",["cube_1x1"]);const defaultProgram=await createProgram("assets/shaders/","default.vert","default.frag");const lightlessProgram=await createProgram("assets/shaders/","lightless.vert","lightless.frag");ground=new Object3D(defaultProgram,vertexBuffers["cube_1x1"],vec3.fromValues(0,1,0));ground.position=vec3.fromValues(0,-7,0);ground.scale=vec3.fromValues(15,1,5);box=new Object3D(defaultProgram,vertexBuffers["cube_1x1"],vec3.fromValues(0,.5,.5));box.position=vec3.fromValues(-4,-2,0);box.scale=vec3.fromValues(3,3,3);platform1=new Object3D(defaultProgram,vertexBuffers["cube_1x1"],vec3.fromValues(.5,.2,0));platform1.position=vec3.fromValues(-3,1,0);platform1.scale=vec3.fromValues(3,1,5);platform2=new Object3D(defaultProgram,vertexBuffers["cube_1x1"],vec3.fromValues(.2,.5,.3));platform2.position=vec3.fromValues(4,3,0);platform2.scale=vec3.fromValues(3,1,5);const colliderEdge=new Lightless(lightlessProgram,vertexBuffers["cube_1x1"],vec3.fromValues(0,1,0));debugDrawer=new DebugDrawer(colliderEdge);debugDrawer.wireframe=true;world.setDebugDraw(debugDrawer);debugDrawer.projViewMatrix=projViewMatrix;const ray=new Lightless(lightlessProgram,vertexBuffers["cube_1x1"]);raycaster=new RayCaster(ray);raycaster.projViewMatrix=projViewMatrix;const boxRBConfig=new OIMO.RigidBodyConfig;boxRBConfig.type=OIMO.RigidBodyType.DYNAMIC;boxRBConfig.position=new OIMO.Vec3(box.position[0],box.position[1],box.position[2]);boxRigidBody=new OIMO.RigidBody(boxRBConfig);boxRigidBody.setOrientation(new OIMO.Quat(0,0,0,1));const boxShapeConfig=new OIMO.ShapeConfig;boxShapeConfig.geometry=new OIMO.BoxGeometry(new OIMO.Vec3(box.scale[0]/2,box.scale[1]/2,box.scale[2]/2));boxShapeConfig.friction=1;boxRigidBody.addShape(new OIMO.Shape(boxShapeConfig));boxRigidBody.setRotationFactor(new OIMO.Vec3(0,0,0));boxRigidBody.setAngularDamping(10);world.addRigidBody(boxRigidBody);const groundRBConfig=new OIMO.RigidBodyConfig;groundRBConfig.type=OIMO.RigidBodyType.STATIC;groundRBConfig.position=new OIMO.Vec3(ground.position[0],ground.position[1],ground.position[2]);const groundRigidBody=new OIMO.RigidBody(groundRBConfig);const groundShapeConfig=new OIMO.ShapeConfig;groundShapeConfig.geometry=new OIMO.BoxGeometry(new OIMO.Vec3(ground.scale[0]/2,ground.scale[1]/2,ground.scale[2]/2));groundShapeConfig.friction=1;const groundShape=new OIMO.Shape(groundShapeConfig);groundShape.userData={name:"ground"};groundRigidBody.addShape(groundShape);world.addRigidBody(groundRigidBody);const platform1RBConfig=new OIMO.RigidBodyConfig;platform1RBConfig.type=OIMO.RigidBodyType.STATIC;platform1RBConfig.position=new OIMO.Vec3(platform1.position[0],platform1.position[1],platform1.position[2]);const platform1RigidBody=new OIMO.RigidBody(platform1RBConfig);const platform1ShapeConfig=new OIMO.ShapeConfig;platform1ShapeConfig.geometry=new OIMO.BoxGeometry(new OIMO.Vec3(platform1.scale[0]/2,platform1.scale[1]/2,platform1.scale[2]/2));platform1ShapeConfig.friction=1;const platform1Shape=new OIMO.Shape(platform1ShapeConfig);platform1Shape.userData={name:"platform1"};platform1RigidBody.addShape(platform1Shape);world.addRigidBody(platform1RigidBody);const platform2RBConfig=new OIMO.RigidBodyConfig;platform2RBConfig.type=OIMO.RigidBodyType.STATIC;platform2RBConfig.position=new OIMO.Vec3(platform2.position[0],platform2.position[1],platform2.position[2]);const platform2RigidBody=new OIMO.RigidBody(platform2RBConfig);const platform2ShapeConfig=new OIMO.ShapeConfig;platform2ShapeConfig.geometry=new OIMO.BoxGeometry(new OIMO.Vec3(platform2.scale[0]/2,platform2.scale[1]/2,platform2.scale[2]/2));platform2ShapeConfig.friction=1;const platform2Shape=new OIMO.Shape(platform2ShapeConfig);platform2Shape.userData={name:"platform2"};platform2RigidBody.addShape(platform2Shape);world.addRigidBody(platform2RigidBody);rayCastCallback.process=(shape,hit)=>{if(shape.userData.name==="platform1"){console.log("platform1")}else if(shape.userData.name==="platform2"){console.log("platform2")}};(function animationLoop(prevMs){const nowMs=window.performance.now();window.requestAnimationFrame(animationLoop.bind(null,nowMs));const deltaMs=nowMs-prevMs;step(deltaMs);draw()})(window.performance.now())}init();