/**
 * Bundled by jsDelivr using Rollup v2.79.1 and Terser v5.19.2.
 * Original file: /npm/@box2d/lights@0.10.0/dist/index.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import t from"/npm/typed-glsl@0.11.0/+esm";var e="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{},i={},s={},r={},h={},o={},a={},n={};Object.defineProperty(n,"__esModule",{value:!0}),n.BlendFunc=void 0;n.BlendFunc=class{constructor(t,e,i){this.gl=t,this.default_sfactor=e,this.default_dfactor=i,this.sfactor=e,this.dfactor=i}set(t,e){this.sfactor=t,this.dfactor=e}reset(){this.sfactor=this.default_sfactor,this.dfactor=this.default_dfactor}apply(){this.gl.blendFunc(this.sfactor,this.dfactor)}};var l={};Object.defineProperty(l,"__esModule",{value:!0}),l.LightColor=void 0;l.LightColor=class{constructor(t=0,e=0,i=0,s=1){this.r=t,this.g=e,this.b=i,this.a=s}set(t,e,i,s=1){this.r=t,this.g=e,this.b=i,this.a=s}copy(t){this.r=t.r,this.g=t.g,this.b=t.b,this.a=t.a}toFloatBits(){return Math.round(255*this.a)<<24|Math.round(255*this.b)<<16|Math.round(255*this.g)<<8|Math.round(255*this.r)}};var d={};Object.defineProperty(d,"__esModule",{value:!0}),d.FrameBuffer=void 0;d.FrameBuffer=class{constructor(t,e,i){this.gl=t,this.width=e,this.height=i,this.texture=this.createTexture(),this.framebufferHandle=this.gl.createFramebuffer(),this.gl.bindFramebuffer(this.gl.FRAMEBUFFER,this.framebufferHandle),this.bindTexture(),this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER,this.gl.COLOR_ATTACHMENT0,this.gl.TEXTURE_2D,this.texture,0),this.gl.bindRenderbuffer(this.gl.RENDERBUFFER,null),this.bindTexture();const s=this.gl.checkFramebufferStatus(this.gl.FRAMEBUFFER);if(this.gl.bindFramebuffer(this.gl.FRAMEBUFFER,null),s!==this.gl.FRAMEBUFFER_COMPLETE){if(this.dispose(),s===this.gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT)throw new Error("Frame buffer couldn't be constructed: incomplete attachment");if(s===this.gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS)throw new Error("Frame buffer couldn't be constructed: incomplete dimensions");if(s===this.gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT)throw new Error("Frame buffer couldn't be constructed: missing attachment");if(s===this.gl.FRAMEBUFFER_UNSUPPORTED)throw new Error("Frame buffer couldn't be constructed: unsupported combination of formats");throw new Error(`Frame buffer couldn't be constructed: unknown error ${s}`)}}bindTexture(){this.gl.bindTexture(this.gl.TEXTURE_2D,this.texture)}createTexture(){const t=this.gl.RGBA,e=this.gl.UNSIGNED_BYTE,i=this.gl.createTexture();return this.gl.bindTexture(this.gl.TEXTURE_2D,i),this.gl.texImage2D(this.gl.TEXTURE_2D,0,t,this.width,this.height,0,t,e,null),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MIN_FILTER,this.gl.LINEAR),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MAG_FILTER,this.gl.LINEAR),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_S,this.gl.CLAMP_TO_EDGE),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_T,this.gl.CLAMP_TO_EDGE),i}dispose(){this.gl.deleteTexture(this.texture),this.gl.deleteFramebuffer(this.framebufferHandle)}bind(){this.gl.bindFramebuffer(this.gl.FRAMEBUFFER,this.framebufferHandle)}unbind(){this.gl.bindFramebuffer(this.gl.FRAMEBUFFER,null)}begin(){this.bind(),this.lastViewport=this.gl.getParameter(this.gl.VIEWPORT),this.gl.viewport(0,0,this.width,this.height)}endSimple(){this.end(this.lastViewport[0],this.lastViewport[1],this.lastViewport[2],this.lastViewport[3])}end(t,e,i,s){this.unbind(),this.gl.viewport(t,e,i,s)}};var u,c,g,f={};Object.defineProperty(f,"__esModule",{value:!0}),f.VertexBufferObject=void 0;f.VertexBufferObject=class{constructor(t,e,i){this.gl=t,this.buffer=t.createBuffer(),this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.buffer),this.gl.bufferData(this.gl.ARRAY_BUFFER,i,e),this.gl.bindBuffer(this.gl.ARRAY_BUFFER,null)}setData(t,e=!0){e&&this.bind(),this.gl.bufferSubData(this.gl.ARRAY_BUFFER,0,t),e&&this.unbind()}bind(){this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.buffer)}unbind(){this.gl.bindBuffer(this.gl.ARRAY_BUFFER,null)}dispose(){this.gl.bindBuffer(this.gl.ARRAY_BUFFER,null),this.gl.deleteBuffer(this.buffer)}},u=a,c=e&&e.__createBinding||(Object.create?function(t,e,i,s){void 0===s&&(s=i);var r=Object.getOwnPropertyDescriptor(e,i);r&&!("get"in r?!e.__esModule:r.writable||r.configurable)||(r={enumerable:!0,get:function(){return e[i]}}),Object.defineProperty(t,s,r)}:function(t,e,i,s){void 0===s&&(s=i),t[s]=e[i]}),g=e&&e.__exportStar||function(t,e){for(var i in t)"default"===i||Object.prototype.hasOwnProperty.call(e,i)||c(e,t,i)},Object.defineProperty(u,"__esModule",{value:!0}),g(n,u),g(l,u),g(d,u),g(f,u),Object.defineProperty(o,"__esModule",{value:!0}),o.LightMesh=void 0;const y=a;class m{constructor(t,e){this.vertexNum=0,this.lightMapDrawingDisabled=!1,this.gl=t,this.setVertexNum(e)}setVertexNum(t){t<m.MIN_VERTS&&(t=m.MIN_VERTS),this.vertexNum<t&&(this.vertexNum=t,this.vertices=new Float32Array(4*this.vertexNum),this.colors=new Int32Array(2*this.vertexNum),this.colorScales=new Float32Array(2*this.vertexNum),this.vertBuffer&&this.vertBuffer.dispose(),this.vertBuffer=new y.VertexBufferObject(this.gl,this.gl.DYNAMIC_DRAW,this.vertices),this.colorBuffer&&this.colorBuffer.dispose(),this.colorBuffer=new y.VertexBufferObject(this.gl,this.gl.DYNAMIC_DRAW,this.colors),this.sBuffer&&this.sBuffer.dispose(),this.sBuffer=new y.VertexBufferObject(this.gl,this.gl.DYNAMIC_DRAW,this.colorScales))}getVertices(){return this.vertices}getColors(){return this.colors}getColorScales(){return this.colorScales}render(t,e,i){this.vertBuffer.bind(),t.a_position.enable(),t.a_position.set(2,this.gl.FLOAT,!1,0,0),this.vertBuffer.unbind(),this.colorBuffer.bind(),t.quad_colors.enable(),t.quad_colors.set(4,this.gl.UNSIGNED_BYTE,!0,0,0),this.colorBuffer.unbind(),this.sBuffer.bind(),t.s.enable(),t.s.set(1,this.gl.FLOAT,!1,0,0),this.sBuffer.unbind(),this.gl.drawArrays(e,0,i),t.a_position.disable(),t.quad_colors.disable(),t.s.disable()}update(){this.vertBuffer.setData(this.vertices),this.colorBuffer.setData(this.colors),this.sBuffer.setData(this.colorScales)}dispose(){this.vertBuffer.dispose(),this.colorBuffer.dispose(),this.sBuffer.dispose()}}o.LightMesh=m,m.MIN_VERTS=4;var p={},b={};Object.defineProperty(b,"__esModule",{value:!0}),b.Matrix3=void 0;class x{constructor(){this.data=[1,0,0,0,1,0,0,0,1]}mulVec2(t){const e=t.x*this.data[0]+t.y*this.data[3]+this.data[6],i=t.x*this.data[1]+t.y*this.data[4]+this.data[7];return t.x=e,t.y=i,t}setToTranslation(t){const e=this.data;return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=t.x,e[7]=t.y,e[8]=1,this}setToRotationRad(t){const e=Math.cos(t),i=Math.sin(t),s=this.data;return s[0]=e,s[1]=i,s[2]=0,s[3]=-i,s[4]=e,s[5]=0,s[6]=0,s[7]=0,s[8]=1,this}det(){const t=this.data;return t[0]*t[4]*t[8]+t[3]*t[7]*t[2]+t[6]*t[1]*t[5]-t[0]*t[7]*t[5]-t[3]*t[1]*t[8]-t[6]*t[4]*t[2]}set(t,e,i,s,r,h,o,a,n){return this.data[0]=t,this.data[1]=e,this.data[2]=i,this.data[3]=s,this.data[4]=r,this.data[5]=h,this.data[6]=o,this.data[7]=a,this.data[8]=n,this}inv(){const t=this.det();if(0===t)throw new Error("Can't invert a singular matrix");const e=1/t,i=this.data;return this.set(e*(i[4]*i[8]-i[5]*i[7]),e*(i[2]*i[7]-i[1]*i[8]),e*(i[1]*i[5]-i[2]*i[4]),e*(i[5]*i[6]-i[3]*i[8]),e*(i[0]*i[8]-i[2]*i[6]),e*(i[2]*i[3]-i[0]*i[5]),e*(i[3]*i[7]-i[4]*i[6]),e*(i[1]*i[6]-i[0]*i[7]),e*(i[0]*i[4]-i[1]*i[3]))}rotateRad(t){if(0===t)return this;const e=Math.cos(t),i=Math.sin(t);return this.mul(v.set(e,i,0,-i,e,0,0,0,1))}mul(t){const e=this.data,i=t.data;return this.set(e[0]*i[0]+e[3]*i[1]+e[6]*i[2],e[1]*i[0]+e[4]*i[1]+e[7]*i[2],e[2]*i[0]+e[5]*i[1]+e[8]*i[2],e[0]*i[3]+e[3]*i[4]+e[6]*i[5],e[1]*i[3]+e[4]*i[4]+e[7]*i[5],e[2]*i[3]+e[5]*i[4]+e[8]*i[5],e[0]*i[6]+e[3]*i[7]+e[6]*i[8],e[1]*i[6]+e[4]*i[7]+e[7]*i[8],e[2]*i[6]+e[5]*i[7]+e[8]*i[8])}}b.Matrix3=x;const v=new x;var _={};!function(t){Object.defineProperty(t,"__esModule",{value:!0}),t.makeNumberArray=t.cosDeg=t.sinDeg=t.RAD_TO_DEG=t.DEG_TO_RAD=void 0,t.DEG_TO_RAD=Math.PI/180,t.RAD_TO_DEG=180/Math.PI,t.sinDeg=function(e){return Math.sin(t.DEG_TO_RAD*e)},t.cosDeg=function(e){return Math.cos(t.DEG_TO_RAD*e)},t.makeNumberArray=function(t,e=0){const i=new Array(t);for(let s=0;s<t;s++)i[s]=e;return i}}(_);var M={};Object.defineProperty(M,"__esModule",{value:!0}),M.Rectangle=void 0;M.Rectangle=class{constructor(){this.x=0,this.y=0,this.width=0,this.height=0}set(t,e,i,s){return this.x=t,this.y=e,this.width=i,this.height=s,this}contains(t,e){return this.x<=t&&this.x+this.width>=t&&this.y<=e&&this.y+this.height>=e}overlaps(t){return this.x<t.x+t.width&&this.x+this.width>t.x&&this.y<t.y+t.height&&this.y+this.height>t.y}};var S={};Object.defineProperty(S,"__esModule",{value:!0}),S.Spinor=void 0;const A=_;class w{constructor(t=0,e=0){this.real=t,this.complex=e}setAngle(t){return t/=2,this.set(Math.cos(t),Math.sin(t))}copy(t){return this.set(t.real,t.complex),this}set(t,e){return this.real=t,this.complex=e,this}scale(t){return this.real*=t,this.complex*=t,this}invert(){return this.complex=-this.complex,this.scale(this.len2()),this}add(t){return this.real+=t.real,this.complex+=t.complex,this}addAngle(t){return t/=2,this.real+=Math.cos(t),this.complex+=Math.sin(t),this}sub(t){return this.real-=t.real,this.complex-=t.complex,this}subAngle(t){return t/=2,this.real-=Math.cos(t),this.complex-=Math.sin(t),this}len(){return Math.sqrt(this.real*this.real+this.complex*this.complex)}len2(){return this.real*this.real+this.complex*this.complex}mul(t){return this.set(this.real*t.real-this.complex*t.complex,this.real*t.complex+this.complex*t.real),this}nor(){const t=this.len();return this.real/=t,this.complex/=t,this}angle(){return 2*Math.atan2(this.complex,this.real)}lerp(t,e,i){return this.scale(1-e),i.copy(t).scale(e),this.add(i),this.nor(),this}slerp(t,e){let i,s,r,h,o,a,n;return h=this.real*t.real+this.complex*t.complex,h<0?(h=-h,s=-t.complex,i=-t.real):(s=t.complex,i=t.real),1-h>w.COSINE_THRESHOLD?(r=Math.acos(h),o=Math.sin(r),a=Math.sin((1-e)*r)/o,n=Math.sin(e*r)/o):(a=1-e,n=e),this.complex=a*this.complex+n*s,this.real=a*this.real+n*i,this}toString(){const t=this.angle();return`radians: ${t}, degrees: ${t*A.RAD_TO_DEG*t}`}}S.Spinor=w,w.COSINE_THRESHOLD=.001;var L={};Object.defineProperty(L,"__esModule",{value:!0}),L.Vector2=void 0;class C{constructor(){this.x=0,this.y=0}set(t,e){return this.x=t,this.y=e,this}copy(t){return this.x=t.x,this.y=t.y,this}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}normalize(){const t=this.length();if(t>0){const e=1/t;this.x*=e,this.y*=e}return this}add(t){return this.x+=t.x,this.y+=t.y,this}addXY(t,e){return this.x+=t,this.y+=e,this}subXY(t,e){return this.x-=t,this.y-=e,this}sub(t){return this.x-=t.x,this.y-=t.y,this}scale(t){return this.x*=t,this.y*=t,this}rotate(t){const e=Math.cos(t),i=Math.sin(t),{x:s}=this;return this.x=e*s-i*this.y,this.y=i*s+e*this.y,this}rotate90(t){const{x:e}=this;return t>=0?(this.x=-this.y,this.y=e):(this.x=this.y,this.y=-e),this}getAngle(){return Math.atan2(this.y,this.x)}static MakeArray(t){const e=new Array(t);for(let i=0;i<t;i++)e[i]=new C;return e}}L.Vector2=C,function(t){var i=e&&e.__createBinding||(Object.create?function(t,e,i,s){void 0===s&&(s=i);var r=Object.getOwnPropertyDescriptor(e,i);r&&!("get"in r?!e.__esModule:r.writable||r.configurable)||(r={enumerable:!0,get:function(){return e[i]}}),Object.defineProperty(t,s,r)}:function(t,e,i,s){void 0===s&&(s=i),t[s]=e[i]}),s=e&&e.__exportStar||function(t,e){for(var s in t)"default"===s||Object.prototype.hasOwnProperty.call(e,s)||i(e,t,s)};Object.defineProperty(t,"__esModule",{value:!0}),s(b,t),s(_,t),s(M,t),s(S,t),s(L,t)}(p);var B={};!function(t){Object.defineProperty(t,"__esModule",{value:!0}),t.lightSettings=t.NO_GAMMA_CORRECTION=t.RECOMMENDED_GAMMA_CORRECTION=void 0,t.RECOMMENDED_GAMMA_CORRECTION=.625,t.NO_GAMMA_CORRECTION=1,t.lightSettings={isDiffuse:!1,gammaCorrection:t.NO_GAMMA_CORRECTION}}(B);var E={};Object.defineProperty(E,"__esModule",{value:!0}),E.removeFromArray=void 0,E.removeFromArray=function(t,e){const i=t.indexOf(e);i>=0&&t.splice(i,1)},Object.defineProperty(h,"__esModule",{value:!0}),h.Light=void 0;const R=o,O=a,D=p,F=B,N=E;class P{constructor(t,e,i,s,r){this.color=new O.LightColor,this.tmpPosition=new D.Vector2,this.active=!0,this.soft=!0,this.xray=!1,this.staticLight=!1,this.culled=!1,this.dirty=!0,this.ignoreBody=!1,this.rayNum=0,this.vertexNum=0,this.distance=0,this.direction=0,this.colorF=0,this.softShadowLength=2.5,this.softShadowMesh=null,this.mx=[],this.my=[],this.f=[],this.m_index=0,this.contactFilter=null,this.rayCast=t.createRayCastCallback(this),t.lightList.push(this),this.rayHandler=t,this.gl=t.gl,this.setRayNum(e,!1),this.setColorC(i),this.setDistance(s),this.setSoftnessLength(Number.isFinite(s)?.1*s:this.softShadowLength),this.setDirection(r),this.lightMesh=new R.LightMesh(this.gl,this.vertexNum),this.setupSoftShadowMesh()}setupSoftShadowMesh(){const t=this.soft&&!this.xray;this.softShadowMesh&&!t?(this.softShadowMesh.dispose(),this.softShadowMesh=null):this.softShadowMesh=new R.LightMesh(this.gl,this.getSoftShadowVertexCount())}getSoftShadowVertexCount(){return this.vertexNum}getPosition(){return this.tmpPosition}setColorC(t){this.color.copy(t),this.colorF=this.color.toFloatBits(),this.staticLight&&(this.dirty=!0)}setColor(t,e,i,s){this.color.set(t,e,i,s),this.colorF=this.color.toFloatBits(),this.staticLight&&(this.dirty=!0)}add(t){this.rayHandler=t,this.active?t.lightList.push(this):t.disabledLights.push(this)}remove(t=!0){this.rayHandler.removeLight(this),t&&this.dispose()}dispose(){var t;this.lightMesh.dispose(),null===(t=this.softShadowMesh)||void 0===t||t.dispose()}isActive(){return this.active}setActive(t){t!==this.active&&(this.active=t,t?(this.rayHandler.lightList.push(this),(0,N.removeFromArray)(this.rayHandler.disabledLights,this)):(this.rayHandler.disabledLights.push(this),(0,N.removeFromArray)(this.rayHandler.lightList,this)))}isXray(){return this.xray}setXray(t){this.xray=t,this.staticLight&&(this.dirty=!0),this.setupSoftShadowMesh()}isStaticLight(){return this.staticLight}setStaticLight(t){this.staticLight=t,t&&(this.dirty=!0)}isSoft(){return this.soft}setSoft(t){this.soft=t,this.staticLight&&(this.dirty=!0),this.setupSoftShadowMesh()}getSoftShadowLength(){return this.softShadowLength}setSoftnessLength(t){this.softShadowLength=t,this.staticLight&&(this.dirty=!0)}getColor(){return this.color}getDistance(){return this.distance/F.lightSettings.gammaCorrection}getDirection(){return this.direction}contains(t,e){return!1}setIgnoreAttachedBody(t){this.ignoreBody=t}getIgnoreAttachedBody(){return this.ignoreBody}setRayNum(t,e=!0){var i;t<P.MIN_RAYS&&(t=P.MIN_RAYS),this.rayNum=t,this.vertexNum=t+1,e&&(this.lightMesh.setVertexNum(this.vertexNum),null===(i=this.softShadowMesh)||void 0===i||i.setVertexNum(this.getSoftShadowVertexCount())),this.mx=(0,D.makeNumberArray)(this.vertexNum),this.my=(0,D.makeNumberArray)(this.vertexNum),this.f=(0,D.makeNumberArray)(this.vertexNum)}getRayNum(){return this.rayNum}setContactFilter(t){this.contactFilter=t}getContactFilter(){return this.contactFilter}setContactFilterBits(t,e,i){this.contactFilter={categoryBits:t,groupIndex:e,maskBits:i}}static setGlobalContactFilter(t){this.globalContactFilter=t}static setGlobalContactFilterBits(t,e,i){this.globalContactFilter={categoryBits:t,groupIndex:e,maskBits:i}}static getGlobalContactFilter(){return this.globalContactFilter}reportFixture(t,e,i,s){const r=P.getGlobalContactFilter();if(r&&!this.runContactFilter(r,t))return-1;const h=this.getContactFilter();return h&&!this.runContactFilter(h,t)||this.ignoreBody&&this.getBody()===e?-1:(this.mx[this.m_index]=i.x,this.my[this.m_index]=i.y,this.f[this.m_index]=s,s)}runContactFilter(t,e){return 0!==t.groupIndex&&t.groupIndex===e.groupIndex?t.groupIndex>0:0!=(t.maskBits&e.categoryBits)&&0!=(t.categoryBits&e.maskBits)}}h.Light=P,P.DefaultColor=new O.LightColor(.75,.75,.5,.75),P.DebugColor=new O.LightColor(1,1,0),P.MIN_RAYS=3,P.globalContactFilter=null,Object.defineProperty(r,"__esModule",{value:!0}),r.ChainLight=void 0;const T=h,V=p,H=B,I={v1:new V.Vector2,v2:new V.Vector2,vSegmentStart:new V.Vector2,vDirection:new V.Vector2,vRayOffset:new V.Vector2,previousAngle:new V.Spinor,currentAngle:new V.Spinor,nextAngle:new V.Spinor,startAngle:new V.Spinor,endAngle:new V.Spinor,rayAngle:new V.Spinor};class Y extends T.Light{constructor(t,e,i,s,r,h){super(t,e,i,s,0),this.chain=[],this.bodyAngle=0,this.bodyAngleOffset=0,this.body=null,this.segmentAngles=[],this.segmentLengths=[],this.startX=[],this.startY=[],this.endX=[],this.endY=[],this.bodyPosition=new V.Vector2,this.tmpEnd=new V.Vector2,this.tmpStart=new V.Vector2,this.tmpPerp=new V.Vector2,this.tmpVec=new V.Vector2,this.zeroPosition=new V.Matrix3,this.rotateAroundZero=new V.Matrix3,this.restorePosition=new V.Matrix3,this.chainLightBounds=new V.Rectangle,this.rayHandlerBounds=new V.Rectangle,this.rayStartOffset=Y.defaultRayStartOffset,this.rayDirection=r,this.vertexNum=2*(this.vertexNum-1),this.endX=(0,V.makeNumberArray)(e),this.endY=(0,V.makeNumberArray)(e),this.startX=(0,V.makeNumberArray)(e),this.startY=(0,V.makeNumberArray)(e),this.chain=h?h.slice():[],this.setMesh()}update(){this.dirty?(this.updateChain(),this.applyAttachment()):this.updateBody(),this.cull()||this.staticLight&&!this.dirty||(this.dirty=!1,this.updateMesh())}render(){var t;this.rayHandler.culling&&this.culled||(this.rayHandler.lightRenderedLastFrame++,this.lightMesh.render(this.rayHandler.lightShader,this.gl.TRIANGLE_STRIP,this.vertexNum),null===(t=this.softShadowMesh)||void 0===t||t.render(this.rayHandler.lightShader,this.gl.TRIANGLE_STRIP,this.vertexNum))}debugRender(t){const e=[];for(let t=0;t<this.rayNum;t++)e.push({x:this.mx[t],y:this.my[t]});for(let t=this.rayNum-1;t>-1;t--)e.push({x:this.startX[t],y:this.startY[t]});t(e,e.length,T.Light.DebugColor)}attachToBody(t,e=0){this.body=t,this.bodyPosition.copy(this.rayHandler.getBodyPosition(this.body)),this.bodyAngleOffset=V.DEG_TO_RAD*e,this.bodyAngle=this.rayHandler.getBodyAngle(t),this.applyAttachment(),this.staticLight&&(this.dirty=!0)}getBody(){return this.body}getX(){return this.tmpPosition.x}getY(){return this.tmpPosition.y}setPosition(t,e){this.tmpPosition.set(t,e),this.staticLight&&(this.dirty=!0)}setPositionV(t){this.tmpPosition.copy(t),this.staticLight&&(this.dirty=!0)}contains(t,e){if(!this.chainLightBounds.contains(t,e))return!1;const i=[];for(let t=0;t<this.rayNum;t++)i.push(this.mx[t],this.my[t]);for(let t=this.rayNum-1;t>-1;t--)i.push(this.startX[t],this.startY[t]);let s=0;for(let r=0;r<i.length;r+=2){const h=i[r],o=i[r+1],a=i[(r+2)%i.length],n=i[(r+3)%i.length];(o<=e&&e<n||n<=e&&e<o)&&t<(a-h)/(n-o)*(e-o)+h&&s++}return 1==(1&s)}setDistance(t){t*=H.lightSettings.gammaCorrection,this.distance=t<.01?.01:t,this.dirty=!0}setDirection(t){}updateChain(){const{v1:t,v2:e,vSegmentStart:i,vDirection:s,vRayOffset:r,previousAngle:h,currentAngle:o,nextAngle:a,startAngle:n,endAngle:l,rayAngle:d}=I,u=Math.round(this.chain.length/2)-1;this.segmentAngles.length=0,this.segmentLengths.length=0;let c=0;for(let e=0,i=0;e<this.chain.length-2;e+=2,i++)t.set(this.chain[e+2],this.chain[e+3]).subXY(this.chain[e],this.chain[e+1]),this.segmentLengths.push(t.length()),this.segmentAngles.push(t.rotate90(this.rayDirection).getAngle()),c+=this.segmentLengths[i];let g=0,f=this.rayNum;for(let y=0;y<u;y++){h.setAngle(0===y?this.segmentAngles[y]:this.segmentAngles[y-1]),o.setAngle(this.segmentAngles[y]),a.setAngle(y===this.segmentAngles.length-1?this.segmentAngles[y]:this.segmentAngles[y+1]),n.copy(h).slerp(o,.5),l.copy(o).slerp(a,.5);const m=2*y;i.set(this.chain[m],this.chain[m+1]),s.set(this.chain[m+2],this.chain[m+3]).sub(i).normalize();const p=c/f,b=y===u-1?f:Math.round(this.segmentLengths[y]/c*f);for(let h=0;h<b;h++){const o=h*p;d.copy(n).slerp(l,o/this.segmentLengths[y]);const a=d.angle();r.set(this.rayStartOffset,0).rotate(a),t.copy(s).scale(o).add(i).add(r),this.startX[g]=t.x,this.startY[g]=t.y,e.set(this.distance,0).rotate(a).add(t),this.endX[g]=e.x,this.endY[g]=e.y,g++}f-=b,c-=this.segmentLengths[y]}}applyAttachment(){if(this.body&&!this.staticLight){this.restorePosition.setToTranslation(this.bodyPosition),this.rotateAroundZero.setToRotationRad(this.bodyAngle+this.bodyAngleOffset);for(let t=0;t<this.rayNum;t++)this.restorePosition.mulVec2(this.rotateAroundZero.mulVec2(this.tmpVec.set(this.startX[t],this.startY[t]))),this.startX[t]=this.tmpVec.x,this.startY[t]=this.tmpVec.y,this.restorePosition.mulVec2(this.rotateAroundZero.mulVec2(this.tmpVec.set(this.endX[t],this.endY[t]))),this.endX[t]=this.tmpVec.x,this.endY[t]=this.tmpVec.y}}cull(){return this.rayHandler.culling?(this.updateBoundingRects(),this.culled=this.chainLightBounds.width>0&&this.chainLightBounds.height>0&&!this.chainLightBounds.overlaps(this.rayHandlerBounds)):this.culled=!1,this.culled}updateBody(){if(!this.body||this.staticLight)return;const t=this.rayHandler.getBodyPosition(this.body),e=this.rayHandler.getBodyAngle(this.body);this.tmpVec.set(0,0).sub(this.bodyPosition),this.bodyPosition.copy(t),this.zeroPosition.setToTranslation(this.tmpVec),this.restorePosition.setToTranslation(this.bodyPosition),this.rotateAroundZero.setToRotationRad(this.bodyAngle).inv().rotateRad(e),this.bodyAngle=e;for(let t=0;t<this.rayNum;t++)this.restorePosition.mulVec2(this.rotateAroundZero.mulVec2(this.zeroPosition.mulVec2(this.tmpVec.set(this.startX[t],this.startY[t])))),this.startX[t]=this.tmpVec.x,this.startY[t]=this.tmpVec.y,this.restorePosition.mulVec2(this.rotateAroundZero.mulVec2(this.zeroPosition.mulVec2(this.tmpVec.set(this.endX[t],this.endY[t])))),this.endX[t]=this.tmpVec.x,this.endY[t]=this.tmpVec.y}updateMesh(){for(let t=0;t<this.rayNum;t++)this.m_index=t,this.f[t]=1,this.tmpEnd.x=this.endX[t],this.mx[t]=this.tmpEnd.x,this.tmpEnd.y=this.endY[t],this.my[t]=this.tmpEnd.y,this.tmpStart.x=this.startX[t],this.tmpStart.y=this.startY[t],this.xray||this.rayCast(this.tmpStart,this.tmpEnd);this.setMesh()}setMesh(){const t=this.lightMesh.getVertices();let e=0;const i=this.lightMesh.getColors();let s=0;const r=this.lightMesh.getColorScales();let h=0;for(let o=0;o<this.rayNum;o++)t[e++]=this.startX[o],t[e++]=this.startY[o],i[s++]=this.colorF,r[h++]=1,t[e++]=this.mx[o],t[e++]=this.my[o],i[s++]=this.colorF,r[h++]=1-this.f[o];if(this.lightMesh.update(),this.softShadowMesh){const t=this.softShadowMesh.getVertices();let e=0;const i=this.softShadowMesh.getColors();let s=0;const r=this.softShadowMesh.getColorScales();let h=0;for(let o=0;o<this.rayNum;o++){t[e++]=this.mx[o],t[e++]=this.my[o],i[s++]=this.colorF;const a=1-this.f[o];r[h++]=a,this.tmpPerp.set(this.mx[o],this.my[o]).subXY(this.startX[o],this.startY[o]).normalize().scale(this.softShadowLength*a).addXY(this.mx[o],this.my[o]),t[e++]=this.tmpPerp.x,t[e++]=this.tmpPerp.y,i[s++]=0,r[h++]=0}this.softShadowMesh.update()}}updateBoundingRects(){let t=this.startX[0],e=this.startX[0],i=this.startY[0],s=this.startY[0];for(let r=0;r<this.rayNum;r++)t=t>this.startX[r]?t:this.startX[r],t=t>this.mx[r]?t:this.mx[r],e=e<this.startX[r]?e:this.startX[r],e=e<this.mx[r]?e:this.mx[r],i=i>this.startY[r]?i:this.startY[r],i=i>this.my[r]?i:this.my[r],s=s<this.startY[r]?s:this.startY[r],s=s<this.my[r]?s:this.my[r];this.chainLightBounds.set(e,s,t-e,i-s),this.rayHandlerBounds.set(this.rayHandler.x1,this.rayHandler.y1,this.rayHandler.x2-this.rayHandler.x1,this.rayHandler.y2-this.rayHandler.y1)}}r.ChainLight=Y,Y.defaultRayStartOffset=.001;var X={},j={};Object.defineProperty(j,"__esModule",{value:!0}),j.PositionalLight=void 0;const G=h,U=p;class k extends G.Light{constructor(t,e,i,s,r,h,o){super(t,e,i,s,o),this.tmpEnd=new U.Vector2,this.start=new U.Vector2,this.body=null,this.bodyOffsetX=0,this.bodyOffsetY=0,this.bodyAngleOffset=0,this.start.x=r,this.start.y=h,this.setMesh()}getSoftShadowVertexCount(){return 2*this.vertexNum}update(){this.updateBody(),this.cull()||this.staticLight&&!this.dirty||(this.dirty=!1,this.updateMesh())}render(){var t;this.rayHandler.culling&&this.culled||(this.rayHandler.lightRenderedLastFrame++,this.lightMesh.render(this.rayHandler.lightShader,this.gl.TRIANGLE_FAN,this.vertexNum),null===(t=this.softShadowMesh)||void 0===t||t.render(this.rayHandler.lightShader,this.gl.TRIANGLE_STRIP,this.getSoftShadowVertexCount()-2))}debugRender(t){const e=[this.start];for(let t=0;t<this.rayNum;t++)e.push({x:this.mx[t],y:this.my[t]});t(e,e.length,G.Light.DebugColor)}attachToBody(t,e=0,i=0,s=0){this.body=t,this.bodyOffsetX=e,this.bodyOffsetY=i,this.bodyAngleOffset=s,this.staticLight&&(this.dirty=!0)}getPosition(){return this.tmpPosition.copy(this.start)}getBody(){return this.body}getX(){return this.start.x}getY(){return this.start.y}setPosition(t,e){this.start.set(t,e),this.staticLight&&(this.dirty=!0)}setPositionV(t){this.start.copy(t),this.staticLight&&(this.dirty=!0)}contains(t,e){const i=this.start.x-t,s=this.start.y-e,r=i*i+s*s;if(this.distance*this.distance<=r)return!1;let h=!1,o=this.mx[this.rayNum]=this.start.x,a=this.my[this.rayNum]=this.start.y,n=0,l=0;for(let i=0;i<=this.rayNum;o=n,a=l,++i)n=this.mx[i],l=this.my[i],(l<e&&a>=e||l>=e&&a<e)&&(e-l)/(a-l)*(o-n)<t-n&&(h=!h);return h}setRayNum(t,e=!0){super.setRayNum(t,e),this.sin=(0,U.makeNumberArray)(t),this.cos=(0,U.makeNumberArray)(t),this.endX=(0,U.makeNumberArray)(t),this.endY=(0,U.makeNumberArray)(t)}cull(){return this.culled=this.rayHandler.culling&&!this.rayHandler.intersect(this.start.x,this.start.y,this.distance+this.softShadowLength),this.culled}updateBody(){if(!this.body||this.staticLight)return;const t=this.rayHandler.getBodyPosition(this.body),e=this.rayHandler.getBodyAngle(this.body),i=Math.cos(e),s=Math.sin(e),r=this.bodyOffsetX*i-this.bodyOffsetY*s,h=this.bodyOffsetX*s+this.bodyOffsetY*i;this.start.x=t.x+r,this.start.y=t.y+h,this.setDirection(this.bodyAngleOffset+U.RAD_TO_DEG*e)}updateMesh(){for(let t=0;t<this.rayNum;t++)this.m_index=t,this.f[t]=1,this.tmpEnd.x=this.endX[t]+this.start.x,this.mx[t]=this.tmpEnd.x,this.tmpEnd.y=this.endY[t]+this.start.y,this.my[t]=this.tmpEnd.y,this.xray||this.rayCast(this.start,this.tmpEnd);this.setMesh()}setMesh(){const t=this.lightMesh.getVertices();let e=0;const i=this.lightMesh.getColors();let s=0;const r=this.lightMesh.getColorScales();let h=0;t[e++]=this.start.x,t[e++]=this.start.y,i[s++]=this.colorF,r[h++]=1;for(let o=0;o<this.rayNum;o++)t[e++]=this.mx[o],t[e++]=this.my[o],i[s++]=this.colorF,r[h++]=1-this.f[o];if(this.lightMesh.update(),this.softShadowMesh){const t=this.softShadowMesh.getVertices();let e=0;const i=this.softShadowMesh.getColors();let s=0;const r=this.softShadowMesh.getColorScales();let h=0;for(let o=0;o<this.rayNum;o++){t[e++]=this.mx[o],t[e++]=this.my[o],i[s++]=this.colorF;const a=1-this.f[o];r[h++]=a,t[e++]=this.mx[o]+a*this.softShadowLength*this.cos[o],t[e++]=this.my[o]+a*this.softShadowLength*this.sin[o],i[s++]=0,r[h++]=0}this.softShadowMesh.update()}}getBodyOffsetX(){return this.bodyOffsetX}getBodyOffsetY(){return this.bodyOffsetY}getBodyAngleOffset(){return this.bodyAngleOffset}setBodyOffsetX(t){this.bodyOffsetX=t}setBodyOffsetY(t){this.bodyOffsetY=t}setBodyAngleOffset(t){this.bodyAngleOffset=t}}j.PositionalLight=k,Object.defineProperty(X,"__esModule",{value:!0}),X.ConeLight=void 0;const W=j,$=p,q=B;class z extends W.PositionalLight{constructor(t,e,i,s,r,h,o,a){super(t,e,i,s,r,h,o),this.setConeDegree(a)}update(){this.updateBody(),this.dirty&&this.setEndPoints(),this.cull()||this.staticLight&&!this.dirty||(this.dirty=!1,this.updateMesh())}setDirection(t){this.direction=t,this.dirty=!0}getConeDegree(){return this.coneDegree}setConeDegree(t){this.coneDegree=Math.max(0,Math.min(180,t)),this.dirty=!0}setDistance(t){t*=q.lightSettings.gammaCorrection,this.distance=t<.01?.01:t,this.dirty=!0}setEndPoints(){for(let t=0;t<this.rayNum;t++){const e=this.direction+this.coneDegree-2*this.coneDegree*t/(this.rayNum-1),i=this.sin[t]=(0,$.sinDeg)(e),s=this.cos[t]=(0,$.cosDeg)(e);this.endX[t]=this.distance*s,this.endY[t]=this.distance*i}}}X.ConeLight=z;var Z={};Object.defineProperty(Z,"__esModule",{value:!0}),Z.DirectionalLight=void 0;const J=h,K=p;class Q extends J.Light{constructor(t,e,i,s){super(t,e,i,1/0,s),this.sin=0,this.cos=0,this.body=null,this.vertexNum=2*(this.vertexNum-1),this.start=K.Vector2.MakeArray(this.rayNum),this.end=K.Vector2.MakeArray(this.rayNum),this.setMesh()}setDirection(t){this.direction=t,this.sin=(0,K.sinDeg)(t),this.cos=(0,K.cosDeg)(t),this.staticLight&&(this.dirty=!0)}update(){this.staticLight&&!this.dirty||(this.dirty=!1,this.updateMesh())}updateMesh(){const t=this.rayHandler.x2-this.rayHandler.x1,e=this.rayHandler.y2-this.rayHandler.y1,i=t>e?t:e;let s=i*this.cos,r=i*this.sin;s*s<.1&&r*r<.1&&(s=1,r=1);const h=i*-this.sin,o=i*this.cos;let a=.5*(this.rayHandler.x1+this.rayHandler.x2)-h,n=.5*(this.rayHandler.y1+this.rayHandler.y2)-o;const l=2*h/(this.rayNum-1);a=Math.floor(a/(2*l))*l*2;const d=2*o/(this.rayNum-1);n=Math.ceil(n/(2*d))*d*2;for(let t=0;t<this.rayNum;t++){const e=t*l+a,i=t*d+n;this.m_index=t,this.start[t].x=e-s,this.start[t].y=i-r,this.mx[t]=this.end[t].x=e+s,this.my[t]=this.end[t].y=i+r,this.xray||this.rayCast(this.start[t],this.end[t])}this.setMesh()}setMesh(){const t=this.lightMesh.getVertices();let e=0;const i=this.lightMesh.getColors();let s=0;const r=this.lightMesh.getColorScales();let h=0;for(let o=0;o<this.rayNum;o++)t[e++]=this.start[o].x,t[e++]=this.start[o].y,i[s++]=this.colorF,r[h++]=1,t[e++]=this.mx[o],t[e++]=this.my[o],i[s++]=this.colorF,r[h++]=1;if(this.lightMesh.update(),this.softShadowMesh){const t=this.softShadowMesh.getVertices();let e=0;const i=this.softShadowMesh.getColors();let s=0;const r=this.softShadowMesh.getColorScales();let h=0;for(let o=0;o<this.rayNum;o++)t[e++]=this.mx[o],t[e++]=this.my[o],i[s++]=this.colorF,r[h++]=1,t[e++]=this.mx[o]+this.softShadowLength*this.cos,t[e++]=this.my[o]+this.softShadowLength*this.sin,i[s++]=0,r[h++]=1;this.softShadowMesh.update()}}render(){var t;this.rayHandler.lightRenderedLastFrame++,this.lightMesh.render(this.rayHandler.lightShader,this.gl.TRIANGLE_STRIP,this.vertexNum),null===(t=this.softShadowMesh)||void 0===t||t.render(this.rayHandler.lightShader,this.gl.TRIANGLE_STRIP,this.vertexNum)}debugRender(t){const e=[];for(let t=0;t<this.rayNum;t++)e.push(this.start[t],{x:this.mx[t],y:this.my[t]});t(e,e.length,J.Light.DebugColor)}contains(t,e){let i,s,r=!1,h=this.mx[this.rayNum]=this.start[0].x,o=this.my[this.rayNum]=this.start[0].y;for(let a=0;a<=this.rayNum;h=i,o=s,++a)i=this.mx[a],s=this.my[a],(s<e&&o>=e||s>=e&&o<e)&&(e-s)/(o-s)*(h-i)<t-i&&(r=!r);for(let a=0;a<this.rayNum;h=i,o=s,++a)i=this.start[a].x,s=this.start[a].y,(s<e&&o>=e||s>=e&&o<e)&&(e-s)/(o-s)*(h-i)<t-i&&(r=!r);return r}attachToBody(t){}setPosition(t,e){}getBody(){return this.body}getX(){return 0}getY(){return 0}setPositionV(t){}setDistance(t){}setIgnoreAttachedBody(t){}getIgnoreAttachedBody(){return!1}setIgnoreBody(t){this.body=t,this.ignoreBody=!!t}}Z.DirectionalLight=Q;var tt={};Object.defineProperty(tt,"__esModule",{value:!0}),tt.PointLight=void 0;const et=j,it=h,st=p,rt=B;class ht extends et.PositionalLight{constructor(t,e,i=it.Light.DefaultColor,s=15,r=0,h=0){super(t,e,i,s,r,h,0)}update(){this.updateBody(),this.dirty&&this.setEndPoints(),this.cull()||this.staticLight&&!this.dirty||(this.dirty=!1,this.updateMesh())}setDistance(t){t*=rt.lightSettings.gammaCorrection,this.distance=t<.01?.01:t,this.dirty=!0}setEndPoints(){const t=360/(this.rayNum-1);for(let e=0;e<this.rayNum;e++){const i=t*e;this.sin[e]=(0,st.sinDeg)(i),this.cos[e]=(0,st.cosDeg)(i),this.endX[e]=this.distance*this.cos[e],this.endY[e]=this.distance*this.sin[e]}}setDirection(t){}}tt.PointLight=ht,function(t){var i=e&&e.__createBinding||(Object.create?function(t,e,i,s){void 0===s&&(s=i);var r=Object.getOwnPropertyDescriptor(e,i);r&&!("get"in r?!e.__esModule:r.writable||r.configurable)||(r={enumerable:!0,get:function(){return e[i]}}),Object.defineProperty(t,s,r)}:function(t,e,i,s){void 0===s&&(s=i),t[s]=e[i]}),s=e&&e.__exportStar||function(t,e){for(var s in t)"default"===s||Object.prototype.hasOwnProperty.call(e,s)||i(e,t,s)};Object.defineProperty(t,"__esModule",{value:!0}),s(r,t),s(X,t),s(Z,t),s(h,t),s(tt,t),s(j,t)}(s);var ot={},at={};Object.defineProperty(at,"__esModule",{value:!0}),at.createDiffuseShader=void 0;const nt=t,lt=nt.glsl`
attribute vec4 a_position;
attribute vec2 a_texCoord;
varying vec2 v_texCoords;

void main() {
    v_texCoords = a_texCoord;
    gl_Position = a_position;
}
`,dt=nt.glsl`
#ifdef GL_ES
precision lowp float;
#define MED mediump
#else
#define MED 
#endif

varying MED vec2 v_texCoords;
uniform sampler2D u_texture;
uniform  vec4 ambient;

void main() {
    gl_FragColor.rgb = (ambient.rgb + texture2D(u_texture, v_texCoords).rgb);
    gl_FragColor.a = 1.0;
}
`;at.createDiffuseShader=function(t){return(0,nt.createShaderProgram)(t,lt,dt,{a_position:"vertexAttribPointer",a_texCoord:"vertexAttribPointer",u_texture:"uniform1i",ambient:"uniform4f"})};var ut={};Object.defineProperty(ut,"__esModule",{value:!0}),ut.createGaussianShader=void 0;const ct=t;ut.createGaussianShader=function(t,e,i,s){const r=(h=e.toFixed(1),o=i.toFixed(1),ct.glsl`
attribute vec4 a_position;
uniform vec2  dir;
attribute vec2 a_texCoord;
varying vec2 v_texCoords0;
varying vec2 v_texCoords1;
varying vec2 v_texCoords2;
varying vec2 v_texCoords3;
varying vec2 v_texCoords4;

const vec2 futher = vec2(3.2307692308 / ${h}, 3.2307692308 / ${o} );
const vec2 closer = vec2(1.3846153846 / ${h}, 1.3846153846 / ${o} );

void main() {
    vec2 f = futher * dir;
    vec2 c = closer * dir;
    v_texCoords0 = a_texCoord - f;
    v_texCoords1 = a_texCoord - c;
    v_texCoords2 = a_texCoord;
    v_texCoords3 = a_texCoord + c;
    v_texCoords4 = a_texCoord + f;
    gl_Position = a_position;
}
`);var h,o;const a=(n=s?".rgb":"",ct.glsl`
#ifdef GL_ES
precision lowp float;
#define MED mediump
#else
#define MED 
#endif

uniform sampler2D u_texture;
varying MED vec2 v_texCoords0;
varying MED vec2 v_texCoords1;
varying MED vec2 v_texCoords2;
varying MED vec2 v_texCoords3;
varying MED vec2 v_texCoords4;
const float center = 0.2270270270;
const float close  = 0.3162162162;
const float far    = 0.0702702703;

void main() {	 
    gl_FragColor${n} = far    * texture2D(u_texture, v_texCoords0)${n}
	      		+ close  * texture2D(u_texture, v_texCoords1)${n}
				+ center * texture2D(u_texture, v_texCoords2)${n}
				+ close  * texture2D(u_texture, v_texCoords3)${n}
				+ far    * texture2D(u_texture, v_texCoords4)${n};
}
`);var n;return(0,ct.createShaderProgram)(t,r,a,{a_position:"vertexAttribPointer",a_texCoord:"vertexAttribPointer",dir:"uniform2f"})};var gt={};Object.defineProperty(gt,"__esModule",{value:!0}),gt.createLightShader=void 0;const ft=t,yt=ft.glsl`
attribute vec4 a_position;
attribute vec4 quad_colors;
attribute float s;
uniform mat4 u_projTrans;
varying vec4 v_color;

void main() {
    v_color = s * quad_colors;
    gl_Position =  u_projTrans * a_position;
}
`;gt.createLightShader=function(t,e){const i=(s=e?"sqrt":"",ft.glsl`
#ifdef GL_ES
precision lowp float;
#define MED mediump
#else
#define MED 
#endif

varying vec4 v_color;

void main() {
    gl_FragColor = ${s}(v_color);
}
`);var s;return(0,ft.createShaderProgram)(t,yt,i,{a_position:"vertexAttribPointer",quad_colors:"vertexAttribPointer",s:"vertexAttribPointer",u_projTrans:"uniformMatrix4f"})};var mt={};Object.defineProperty(mt,"__esModule",{value:!0}),mt.createShadowShader=void 0;const pt=t,bt=pt.glsl`
attribute vec4 a_position;
attribute vec2 a_texCoord;
varying vec2 v_texCoords;

void main() {
    v_texCoords = a_texCoord;
    gl_Position = a_position;
}
`,xt=pt.glsl`
#ifdef GL_ES
precision lowp float;
#define MED mediump
#else
#define MED 
#endif

varying MED vec2 v_texCoords;
uniform sampler2D u_texture;
uniform vec4 ambient;

void main() {
    vec4 c = texture2D(u_texture, v_texCoords);
    gl_FragColor.rgb = c.rgb * c.a + ambient.rgb;
    gl_FragColor.a = ambient.a - c.a;
}
`;mt.createShadowShader=function(t){return(0,pt.createShaderProgram)(t,bt,xt,{a_position:"vertexAttribPointer",a_texCoord:"vertexAttribPointer",u_texture:"uniform1i",ambient:"uniform4f"})};var vt={};Object.defineProperty(vt,"__esModule",{value:!0}),vt.createWithoutShadowShader=void 0;const _t=t,Mt=_t.glsl`
attribute vec4 a_position;
attribute vec2 a_texCoord;
varying vec2 v_texCoords;

void main() {
    v_texCoords = a_texCoord;
    gl_Position = a_position;
}
`,St=_t.glsl`
#ifdef GL_ES
precision lowp float;
#define MED mediump
#else
#define MED 
#endif

varying MED vec2 v_texCoords;
uniform sampler2D u_texture;

void main() {
    gl_FragColor = texture2D(u_texture, v_texCoords);
}
`;vt.createWithoutShadowShader=function(t){return(0,_t.createShaderProgram)(t,Mt,St,{a_position:"vertexAttribPointer",a_texCoord:"vertexAttribPointer",u_texture:"uniform1i",ambient:"uniform4f"})},function(t){var i=e&&e.__createBinding||(Object.create?function(t,e,i,s){void 0===s&&(s=i);var r=Object.getOwnPropertyDescriptor(e,i);r&&!("get"in r?!e.__esModule:r.writable||r.configurable)||(r={enumerable:!0,get:function(){return e[i]}}),Object.defineProperty(t,s,r)}:function(t,e,i,s){void 0===s&&(s=i),t[s]=e[i]}),s=e&&e.__exportStar||function(t,e){for(var s in t)"default"===s||Object.prototype.hasOwnProperty.call(e,s)||i(e,t,s)};Object.defineProperty(t,"__esModule",{value:!0}),s(at,t),s(ut,t),s(gt,t),s(mt,t),s(vt,t)}(ot);var At={};Object.defineProperty(At,"__esModule",{value:!0}),At.LightMap=void 0;const wt=ot,Lt=f,Ct=d,Bt=B;At.LightMap=class{constructor(t,e,i){this.lightMapDrawingDisabled=!1,this.rayHandler=t,this.gl=t.gl,this.vertBuffer=new Lt.VertexBufferObject(this.gl,this.gl.STATIC_DRAW,this.createVertices()),this.uvBuffer=new Lt.VertexBufferObject(this.gl,this.gl.STATIC_DRAW,this.createUvCoords()),e<=0&&(e=1),i<=0&&(i=1),this.frameBuffer=new Ct.FrameBuffer(this.gl,e,i),this.pingPongBuffer=new Ct.FrameBuffer(this.gl,e,i),this.shadowShader=(0,wt.createShadowShader)(this.gl),this.diffuseShader=(0,wt.createDiffuseShader)(this.gl),this.withoutShadowShader=(0,wt.createWithoutShadowShader)(this.gl),this.blurShader=(0,wt.createGaussianShader)(this.gl,e,i,Bt.lightSettings.isDiffuse)}render(){const t=this.rayHandler.lightRenderedLastFrame>0;if(!this.lightMapDrawingDisabled){if(this.frameBuffer.bindTexture(),this.rayHandler.shadows){const t=this.rayHandler.ambientLight;let e=this.shadowShader;Bt.lightSettings.isDiffuse?(e=this.diffuseShader,e.use(),this.rayHandler.diffuseBlendFunc.apply(),e.ambient.set(t.r,t.g,t.b,t.a)):(e.use(),this.rayHandler.shadowBlendFunc.apply(),e.ambient.set(t.r*t.a,t.g*t.a,t.b*t.a,1-t.a)),this.renderTriangleFan(e)}else t&&(this.rayHandler.simpleBlendFunc.apply(),this.withoutShadowShader.use(),this.renderTriangleFan(this.withoutShadowShader));this.gl.disable(this.gl.BLEND)}}renderTriangleFan(t){this.vertBuffer.bind(),t.a_position.enable(),t.a_position.set(2,this.gl.FLOAT,!1,0,0),this.vertBuffer.unbind(),this.uvBuffer.bind(),t.a_texCoord.enable(),t.a_texCoord.set(2,this.gl.FLOAT,!1,0,0),this.uvBuffer.unbind(),this.gl.drawArrays(this.gl.TRIANGLE_FAN,0,4),t.a_position.disable(),t.a_texCoord.disable()}gaussianBlur(){this.gl.disable(this.gl.BLEND);for(let t=0;t<this.rayHandler.blurNum;t++)this.frameBuffer.bindTexture(),this.pingPongBuffer.begin(),this.blurShader.use(),this.blurShader.dir.set(1,0),this.renderTriangleFan(this.blurShader),this.pingPongBuffer.endSimple(),this.pingPongBuffer.bindTexture(),this.frameBuffer.begin(),this.blurShader.use(),this.blurShader.dir.set(0,1),this.renderTriangleFan(this.blurShader),this.rayHandler.customViewport?this.frameBuffer.end(this.rayHandler.viewportX,this.rayHandler.viewportY,this.rayHandler.viewportWidth,this.rayHandler.viewportHeight):this.frameBuffer.endSimple();this.gl.enable(this.gl.BLEND)}dispose(){this.shadowShader.dispose(),this.blurShader.dispose(),this.vertBuffer.dispose(),this.uvBuffer.dispose(),this.frameBuffer.dispose(),this.pingPongBuffer.dispose()}createVertices(){return new Float32Array([-1,-1,1,-1,1,1,-1,1])}createUvCoords(){return new Float32Array([0,0,1,0,1,1,0,1])}};var Et={};Object.defineProperty(Et,"__esModule",{value:!0}),Et.RayHandler=void 0;const Rt=At,Ot=ot,Dt=a,Ft=E,Nt=B;Et.RayHandler=class{constructor(t,e,i,s,r){this.combined=new Float32Array(16),this.ambientLight=new Dt.LightColor,this.lightList=[],this.disabledLights=[],this.customLightShader=null,this.culling=!0,this.shadows=!0,this.blur=!0,this.blurNum=1,this.customViewport=!1,this.viewportX=0,this.viewportY=0,this.lightRenderedLastFrame=0,this.x1=0,this.x2=0,this.y1=0,this.y2=0,this.gl=t,this.diffuseBlendFunc=new Dt.BlendFunc(t,t.DST_COLOR,t.ZERO),this.shadowBlendFunc=new Dt.BlendFunc(t,t.ONE,t.ONE_MINUS_SRC_ALPHA),this.simpleBlendFunc=new Dt.BlendFunc(t,t.SRC_ALPHA,t.ONE),this.viewportWidth=s,this.viewportHeight=r,this.resizeFBO(e,i),this.lightShader=(0,Ot.createLightShader)(t,Nt.lightSettings.gammaCorrection!==Nt.NO_GAMMA_CORRECTION)}resizeFBO(t,e){var i;null===(i=this.lightMap)||void 0===i||i.dispose(),this.lightMap=new Rt.LightMap(this,t,e)}setCombinedMatrix(t,e,i,s,r){this.combined.set(t);const h=.5*s;this.x1=e-h,this.x2=e+h;const o=.5*r;this.y1=i-o,this.y2=i+o}intersect(t,e,i){return this.x1<t+i&&this.x2>t-i&&this.y1<e+i&&this.y2>e-i}updateAndRender(){this.update(),this.render()}update(){for(const t of this.lightList)t.update()}prepareRender(){var t;this.lightRenderedLastFrame=0,this.gl.depthMask(!1),this.gl.enable(this.gl.BLEND),this.simpleBlendFunc.apply();const e=this.shadows||this.blur;e&&(this.lightMap.frameBuffer.begin(),this.gl.clearColor(0,0,0,0),this.gl.clear(this.gl.COLOR_BUFFER_BIT));const i=null!==(t=this.customLightShader)&&void 0!==t?t:this.lightShader;i.use(),i.u_projTrans.set(!1,this.combined),this.customLightShader&&this.updateLightShader();for(const t of this.lightList)this.customLightShader&&this.updateLightShaderPerLight(t),t.render();if(e){this.customViewport?this.lightMap.frameBuffer.end(this.viewportX,this.viewportY,this.viewportWidth,this.viewportHeight):this.lightMap.frameBuffer.endSimple();this.lightRenderedLastFrame>0&&this.blur&&this.lightMap.gaussianBlur()}}render(){this.prepareRender(),this.lightMap.render()}renderOnly(){this.lightMap.render()}updateLightShader(){}updateLightShaderPerLight(t){}pointAtLight(t,e){return this.lightList.some((i=>i.contains(t,e)))}pointAtShadow(t,e){return!this.lightList.some((i=>i.contains(t,e)))}dispose(){this.removeAll(),this.lightMap&&this.lightMap.dispose(),this.lightShader&&this.lightShader.dispose()}removeAll(){this.lightList.forEach((t=>t.dispose())),this.lightList.length=0,this.disabledLights.forEach((t=>t.dispose())),this.disabledLights.length=0}removeLight(t){const e=t.isActive()?this.lightList:this.disabledLights;(0,Ft.removeFromArray)(e,t)}setLightShader(t){this.customLightShader=t}setCulling(t){this.culling=t}setBlur(t){this.blur=t}setBlurNum(t){this.blurNum=t}setShadows(t){this.shadows=t}setAmbientLightBrightness(t){this.ambientLight.a=Math.max(0,Math.min(1,t))}setAmbientLight(t,e,i,s){this.ambientLight.set(t,e,i,s)}setAmbientLightC(t){this.ambientLight.copy(t)}useCustomViewport(t,e,i,s){this.customViewport=!0,this.viewportX=t,this.viewportY=e,this.viewportWidth=i,this.viewportHeight=s}useDefaultViewport(){this.customViewport=!1}setLightMapRendering(t){this.lightMap.lightMapDrawingDisabled=!t}getLightMapBuffer(){return this.lightMap.frameBuffer}},function(t){var i=e&&e.__createBinding||(Object.create?function(t,e,i,s){void 0===s&&(s=i);var r=Object.getOwnPropertyDescriptor(e,i);r&&!("get"in r?!e.__esModule:r.writable||r.configurable)||(r={enumerable:!0,get:function(){return e[i]}}),Object.defineProperty(t,s,r)}:function(t,e,i,s){void 0===s&&(s=i),t[s]=e[i]}),r=e&&e.__exportStar||function(t,e){for(var s in t)"default"===s||Object.prototype.hasOwnProperty.call(e,s)||i(e,t,s)};Object.defineProperty(t,"__esModule",{value:!0}),r(s,t),r(a,t),r(ot,t),r(p,t),r(B,t),r(At,t),r(o,t),r(Et,t)}(i);var Pt=i.BlendFunc,Tt=i.ChainLight,Vt=i.ConeLight,Ht=i.DEG_TO_RAD,It=i.DirectionalLight,Yt=i.FrameBuffer,Xt=i.Light,jt=i.LightColor,Gt=i.LightMap,Ut=i.LightMesh,kt=i.Matrix3,Wt=i.NO_GAMMA_CORRECTION,$t=i.PointLight,qt=i.PositionalLight,zt=i.RAD_TO_DEG,Zt=i.RECOMMENDED_GAMMA_CORRECTION,Jt=i.RayHandler,Kt=i.Rectangle,Qt=i.Spinor,te=i.Vector2,ee=i.VertexBufferObject,ie=i.__esModule,se=i.cosDeg,re=i.createDiffuseShader,he=i.createGaussianShader,oe=i.createLightShader,ae=i.createShadowShader,ne=i.createWithoutShadowShader,le=i.lightSettings,de=i.makeNumberArray,ue=i.sinDeg;export{Pt as BlendFunc,Tt as ChainLight,Vt as ConeLight,Ht as DEG_TO_RAD,It as DirectionalLight,Yt as FrameBuffer,Xt as Light,jt as LightColor,Gt as LightMap,Ut as LightMesh,kt as Matrix3,Wt as NO_GAMMA_CORRECTION,$t as PointLight,qt as PositionalLight,zt as RAD_TO_DEG,Zt as RECOMMENDED_GAMMA_CORRECTION,Jt as RayHandler,Kt as Rectangle,Qt as Spinor,te as Vector2,ee as VertexBufferObject,ie as __esModule,se as cosDeg,re as createDiffuseShader,he as createGaussianShader,oe as createLightShader,ae as createShadowShader,ne as createWithoutShadowShader,i as default,le as lightSettings,de as makeNumberArray,ue as sinDeg};
//# sourceMappingURL=/sm/cba931e9b705105c5a0dc8587d707420962e48c2903065b447bed729fb6cd85d.map