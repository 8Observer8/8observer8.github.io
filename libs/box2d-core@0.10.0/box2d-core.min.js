/**
 * Bundled by jsDelivr using Rollup v2.79.1 and Terser v5.19.2.
 * Original file: /npm/@box2d/core@0.10.0/dist/index.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
var t="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{},e={},s={},i={};Object.defineProperty(i,"__esModule",{value:!0}),i.b2_maxPolygonVertices=i.b2_lengthUnitsPerMeter=void 0,i.b2_lengthUnitsPerMeter=1,i.b2_maxPolygonVertices=8,function(t){Object.defineProperty(t,"__esModule",{value:!0}),t.b2MakeArray=t.b2MakeBooleanArray=t.b2MakeNumberArray=t.b2_version=t.b2_angularSleepTolerance=t.b2_linearSleepTolerance=t.b2_timeToSleep=t.b2_toiBaumgarte=t.b2_baumgarte=t.b2_maxRotationSquared=t.b2_maxRotation=t.b2_maxTranslationSquared=t.b2_maxTranslation=t.b2_maxAngularCorrection=t.b2_maxLinearCorrection=t.b2_maxTOIContacts=t.b2_maxSubSteps=t.b2_polygonRadius=t.b2_angularSlop=t.b2_linearSlop=t.b2_aabbMultiplier=t.b2_aabbExtension=t.b2_maxManifoldPoints=t.b2_epsilon_sq=t.b2_epsilon=t.b2_maxFloat=t.b2Verify=t.b2Assert=void 0;const e=i;t.b2Assert=function(t,e){if(!t)throw new Error(e)},t.b2Verify=function(t){if(null===t)throw new Error;return t},t.b2_maxFloat=1e37,t.b2_epsilon=1e-5,t.b2_epsilon_sq=t.b2_epsilon*t.b2_epsilon,t.b2_maxManifoldPoints=2,t.b2_aabbExtension=.1*e.b2_lengthUnitsPerMeter,t.b2_aabbMultiplier=4,t.b2_linearSlop=.005*e.b2_lengthUnitsPerMeter,t.b2_angularSlop=2/180*Math.PI,t.b2_polygonRadius=2*t.b2_linearSlop,t.b2_maxSubSteps=8,t.b2_maxTOIContacts=32,t.b2_maxLinearCorrection=.2*e.b2_lengthUnitsPerMeter,t.b2_maxAngularCorrection=8/180*Math.PI,t.b2_maxTranslation=2*e.b2_lengthUnitsPerMeter,t.b2_maxTranslationSquared=t.b2_maxTranslation*t.b2_maxTranslation,t.b2_maxRotation=.5*Math.PI,t.b2_maxRotationSquared=t.b2_maxRotation*t.b2_maxRotation,t.b2_baumgarte=.2,t.b2_toiBaumgarte=.75,t.b2_timeToSleep=.5,t.b2_linearSleepTolerance=.01*e.b2_lengthUnitsPerMeter,t.b2_angularSleepTolerance=2/180*Math.PI,t.b2_version={major:2,minor:4,patch:0},t.b2MakeNumberArray=function(t,e=0){const s=new Array(t);for(let i=0;i<t;i++)s[i]=e;return s},t.b2MakeBooleanArray=function(t,e=!1){const s=new Array(t);for(let i=0;i<t;i++)s[i]=e;return s},t.b2MakeArray=function(t,e){const s=new Array(t);for(let i=0;i<t;i++)s[i]=new e;return s}}(s);var o={};!function(t){Object.defineProperty(t,"__esModule",{value:!0}),t.b2Sweep=t.b2Transform=t.b2Rot=t.b2Mat33=t.b2Mat22=t.b2Vec3=t.b2Vec2=t.b2RandomInt=t.b2RandomFloat=t.b2Random=t.b2IsPowerOfTwo=t.b2NextPowerOfTwo=t.b2RadToDeg=t.b2DegToRad=t.b2Clamp=t.b2_two_pi=t.b2_180_over_pi=t.b2_pi_over_180=void 0;const e=s;function i(t,e,s){return t<e?e:t>s?s:t}t.b2_pi_over_180=Math.PI/180,t.b2_180_over_pi=180/Math.PI,t.b2_two_pi=2*Math.PI,t.b2Clamp=i,t.b2DegToRad=function(e){return e*t.b2_pi_over_180},t.b2RadToDeg=function(e){return e*t.b2_180_over_pi},t.b2NextPowerOfTwo=function(t){return t|=t>>1,t|=t>>2,t|=t>>4,t|=t>>8,(t|=t>>16)+1},t.b2IsPowerOfTwo=function(t){return t>0&&0==(t&t-1)},t.b2Random=function(){return 2*Math.random()-1},t.b2RandomFloat=function(t,e){return(e-t)*Math.random()+t},t.b2RandomInt=function(t,e){return Math.round((e-t)*Math.random()+t)};class o{constructor(t=0,e=0){this.x=t,this.y=e}Clone(){return new o(this.x,this.y)}SetZero(){return this.x=0,this.y=0,this}Set(t,e){return this.x=t,this.y=e,this}Copy(t){return this.x=t.x,this.y=t.y,this}Add(t){return this.x+=t.x,this.y+=t.y,this}AddXY(t,e){return this.x+=t,this.y+=e,this}Subtract(t){return this.x-=t.x,this.y-=t.y,this}SubtractXY(t,e){return this.x-=t,this.y-=e,this}Scale(t){return this.x*=t,this.y*=t,this}AddScaled(t,e){return this.x+=t*e.x,this.y+=t*e.y,this}SubtractScaled(t,e){return this.x-=t*e.x,this.y-=t*e.y,this}Dot(t){return this.x*t.x+this.y*t.y}Cross(t){return this.x*t.y-this.y*t.x}Length(){const{x:t,y:e}=this;return Math.sqrt(t*t+e*e)}LengthSquared(){const{x:t,y:e}=this;return t*t+e*e}Normalize(){const t=this.Length();if(t<e.b2_epsilon)return 0;const s=1/t;return this.x*=s,this.y*=s,t}Rotate(t){const e=Math.cos(t),s=Math.sin(t),{x:i}=this;return this.x=e*i-s*this.y,this.y=s*i+e*this.y,this}RotateCosSin(t,e){const{x:s}=this;return this.x=t*s-e*this.y,this.y=e*s+t*this.y,this}IsValid(){return Number.isFinite(this.x)&&Number.isFinite(this.y)}Abs(){return this.x=Math.abs(this.x),this.y=Math.abs(this.y),this}GetAbs(t){return t.x=Math.abs(this.x),t.y=Math.abs(this.y),t}Negate(){return this.x=-this.x,this.y=-this.y,this}Skew(){const{x:t}=this;return this.x=-this.y,this.y=t,this}static Min(t,e,s){return s.x=Math.min(t.x,e.x),s.y=Math.min(t.y,e.y),s}static Max(t,e,s){return s.x=Math.max(t.x,e.x),s.y=Math.max(t.y,e.y),s}static Clamp(t,e,s,o){return o.x=i(t.x,e.x,s.x),o.y=i(t.y,e.y,s.y),o}static Rotate(t,e,s){const i=t.x,o=t.y,n=Math.cos(e),r=Math.sin(e);return s.x=n*i-r*o,s.y=r*i+n*o,s}static Dot(t,e){return t.x*e.x+t.y*e.y}static Cross(t,e){return t.x*e.y-t.y*e.x}static CrossVec2Scalar(t,e,s){const i=t.x;return s.x=e*t.y,s.y=-e*i,s}static CrossVec2One(t,e){const s=t.x;return e.x=t.y,e.y=-s,e}static CrossScalarVec2(t,e,s){const i=e.x;return s.x=-t*e.y,s.y=t*i,s}static CrossOneVec2(t,e){const s=t.x;return e.x=-t.y,e.y=s,e}static Add(t,e,s){return s.x=t.x+e.x,s.y=t.y+e.y,s}static Subtract(t,e,s){return s.x=t.x-e.x,s.y=t.y-e.y,s}static Scale(t,e,s){return s.x=e.x*t,s.y=e.y*t,s}static AddScaled(t,e,s,i){return i.x=t.x+e*s.x,i.y=t.y+e*s.y,i}static SubtractScaled(t,e,s,i){return i.x=t.x-e*s.x,i.y=t.y-e*s.y,i}static AddCrossScalarVec2(t,e,s,i){const o=s.x;return i.x=t.x-e*s.y,i.y=t.y+e*o,i}static Mid(t,e,s){return s.x=.5*(t.x+e.x),s.y=.5*(t.y+e.y),s}static Extents(t,e,s){return s.x=.5*(e.x-t.x),s.y=.5*(e.y-t.y),s}static Equals(t,e){return t.x===e.x&&t.y===e.y}static Distance(t,e){return Math.sqrt((t.x-e.x)**2+(t.y-e.y)**2)}static DistanceSquared(t,e){return(t.x-e.x)**2+(t.y-e.y)**2}static Negate(t,e){return e.x=-t.x,e.y=-t.y,e}static Normalize(t,s){const i=t.x**2+t.y**2;if(i>=e.b2_epsilon_sq){const e=1/Math.sqrt(i);s.x=e*t.x,s.y=e*t.y}else s.x=0,s.y=0;return s}static Skew(t,e){const{x:s}=t;return e.x=-t.y,e.y=s,e}}t.b2Vec2=o,o.ZERO=new o,o.UNITX=new o(1,0),o.UNITY=new o(0,1),o.s_t0=new o,o.s_t1=new o,o.s_t2=new o,o.s_t3=new o;class n{constructor(t=0,e=0,s=0){this.x=t,this.y=e,this.z=s}Clone(){return new n(this.x,this.y,this.z)}SetZero(){return this.x=0,this.y=0,this.z=0,this}Set(t,e,s){return this.x=t,this.y=e,this.z=s,this}Copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}Negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}Add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}AddXYZ(t,e,s){return this.x+=t,this.y+=e,this.z+=s,this}Subtract(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}SubtractXYZ(t,e,s){return this.x-=t,this.y-=e,this.z-=s,this}Scale(t){return this.x*=t,this.y*=t,this.z*=t,this}static Dot(t,e){return t.x*e.x+t.y*e.y+t.z*e.z}static Cross(t,e,s){const i=t.x,o=t.y,n=t.z,r=e.x,a=e.y,c=e.z;return s.x=o*c-n*a,s.y=n*r-i*c,s.z=i*a-o*r,s}}t.b2Vec3=n,n.ZERO=new n(0,0,0),n.s_t0=new n;class r{constructor(){this.ex=new o(1,0),this.ey=new o(0,1)}Clone(){return(new r).Copy(this)}static FromColumns(t,e){return(new r).SetColumns(t,e)}static FromScalars(t,e,s,i){return(new r).SetScalars(t,e,s,i)}static FromAngle(t){return(new r).SetAngle(t)}SetScalars(t,e,s,i){return this.ex.Set(t,s),this.ey.Set(e,i),this}SetColumns(t,e){return this.ex.Copy(t),this.ey.Copy(e),this}SetAngle(t){const e=Math.cos(t),s=Math.sin(t);return this.ex.Set(e,s),this.ey.Set(-s,e),this}Copy(t){return this.ex.Copy(t.ex),this.ey.Copy(t.ey),this}SetIdentity(){return this.ex.Set(1,0),this.ey.Set(0,1),this}SetZero(){return this.ex.SetZero(),this.ey.SetZero(),this}GetAngle(){return Math.atan2(this.ex.y,this.ex.x)}Solve(t,e,s){const i=this.ex.x,o=this.ey.x,n=this.ex.y,r=this.ey.y;let a=i*r-o*n;return 0!==a&&(a=1/a),s.x=a*(r*t-o*e),s.y=a*(i*e-n*t),s}Abs(){return this.ex.Abs(),this.ey.Abs(),this}Inverse(){return this.GetInverse(this),this}Add(t){return this.ex.Add(t.ex),this.ey.Add(t.ey),this}Subtract(t){return this.ex.Subtract(t.ex),this.ey.Subtract(t.ey),this}GetInverse(t){const e=this.ex.x,s=this.ey.x,i=this.ex.y,o=this.ey.y;let n=e*o-s*i;return 0!==n&&(n=1/n),t.ex.x=n*o,t.ey.x=-n*s,t.ex.y=-n*i,t.ey.y=n*e,t}GetAbs(t){return t.ex.x=Math.abs(this.ex.x),t.ex.y=Math.abs(this.ex.y),t.ey.x=Math.abs(this.ey.x),t.ey.y=Math.abs(this.ey.y),t}static MultiplyVec2(t,e,s){const i=e.x,o=e.y;return s.x=t.ex.x*i+t.ey.x*o,s.y=t.ex.y*i+t.ey.y*o,s}static TransposeMultiplyVec2(t,e,s){const i=e.x,o=e.y;return s.x=t.ex.x*i+t.ex.y*o,s.y=t.ey.x*i+t.ey.y*o,s}static Add(t,e,s){return s.ex.x=t.ex.x+e.ex.x,s.ex.y=t.ex.y+e.ex.y,s.ey.x=t.ey.x+e.ey.x,s.ey.y=t.ey.y+e.ey.y,s}static Multiply(t,e,s){const i=t.ex.x,o=t.ex.y,n=t.ey.x,r=t.ey.y,a=e.ex.x,c=e.ex.y,m=e.ey.x,l=e.ey.y;return s.ex.x=i*a+n*c,s.ex.y=o*a+r*c,s.ey.x=i*m+n*l,s.ey.y=o*m+r*l,s}static TransposeMultiply(t,e,s){const i=t.ex.x,o=t.ex.y,n=t.ey.x,r=t.ey.y,a=e.ex.x,c=e.ex.y,m=e.ey.x,l=e.ey.y;return s.ex.x=i*a+o*c,s.ex.y=n*a+r*c,s.ey.x=i*m+o*l,s.ey.y=n*m+r*l,s}}t.b2Mat22=r,r.IDENTITY=new r;class a{constructor(){this.ex=new n(1,0,0),this.ey=new n(0,1,0),this.ez=new n(0,0,1)}Clone(){return(new a).Copy(this)}SetColumns(t,e,s){return this.ex.Copy(t),this.ey.Copy(e),this.ez.Copy(s),this}Copy(t){return this.ex.Copy(t.ex),this.ey.Copy(t.ey),this.ez.Copy(t.ez),this}SetIdentity(){return this.ex.Set(1,0,0),this.ey.Set(0,1,0),this.ez.Set(0,0,1),this}SetZero(){return this.ex.SetZero(),this.ey.SetZero(),this.ez.SetZero(),this}Add(t){return this.ex.Add(t.ex),this.ey.Add(t.ey),this.ez.Add(t.ez),this}Solve33(t,e,s,i){const o=this.ex.x,n=this.ex.y,r=this.ex.z,a=this.ey.x,c=this.ey.y,m=this.ey.z,l=this.ez.x,h=this.ez.y,_=this.ez.z;let b=o*(c*_-m*h)+n*(m*l-a*_)+r*(a*h-c*l);return 0!==b&&(b=1/b),i.x=b*(t*(c*_-m*h)+e*(m*l-a*_)+s*(a*h-c*l)),i.y=b*(o*(e*_-s*h)+n*(s*l-t*_)+r*(t*h-e*l)),i.z=b*(o*(c*s-m*e)+n*(m*t-a*s)+r*(a*e-c*t)),i}Solve22(t,e,s){const i=this.ex.x,o=this.ey.x,n=this.ex.y,r=this.ey.y;let a=i*r-o*n;return 0!==a&&(a=1/a),s.x=a*(r*t-o*e),s.y=a*(i*e-n*t),s}GetInverse22(t){const e=this.ex.x,s=this.ey.x,i=this.ex.y,o=this.ey.y;let n=e*o-s*i;0!==n&&(n=1/n),t.ex.x=n*o,t.ey.x=-n*s,t.ex.z=0,t.ex.y=-n*i,t.ey.y=n*e,t.ey.z=0,t.ez.x=0,t.ez.y=0,t.ez.z=0}GetSymInverse33(t){let e=n.Dot(this.ex,n.Cross(this.ey,this.ez,n.s_t0));0!==e&&(e=1/e);const s=this.ex.x,i=this.ey.x,o=this.ez.x,r=this.ey.y,a=this.ez.y,c=this.ez.z;t.ex.x=e*(r*c-a*a),t.ex.y=e*(o*a-i*c),t.ex.z=e*(i*a-o*r),t.ey.x=t.ex.y,t.ey.y=e*(s*c-o*o),t.ey.z=e*(o*i-s*a),t.ez.x=t.ex.z,t.ez.y=t.ey.z,t.ez.z=e*(s*r-i*i)}static MultiplyVec3(t,e,s){const{x:i,y:o,z:n}=e;return s.x=t.ex.x*i+t.ey.x*o+t.ez.x*n,s.y=t.ex.y*i+t.ey.y*o+t.ez.y*n,s.z=t.ex.z*i+t.ey.z*o+t.ez.z*n,s}static MultiplyVec2(t,e,s){const{x:i,y:o}=e;return s.x=t.ex.x*i+t.ey.x*o,s.y=t.ex.y*i+t.ey.y*o,s}}t.b2Mat33=a,a.IDENTITY=new a;class c{constructor(t=0){this.s=0,this.c=1,t&&(this.s=Math.sin(t),this.c=Math.cos(t))}Clone(){return(new c).Copy(this)}Copy(t){return this.s=t.s,this.c=t.c,this}Set(t){return this.s=Math.sin(t),this.c=Math.cos(t),this}SetIdentity(){return this.s=0,this.c=1,this}GetAngle(){return Math.atan2(this.s,this.c)}GetXAxis(t){return t.x=this.c,t.y=this.s,t}GetYAxis(t){return t.x=-this.s,t.y=this.c,t}static Multiply(t,e,s){const i=t.s*e.c+t.c*e.s,o=t.c*e.c-t.s*e.s;return s.s=i,s.c=o,s}static TransposeMultiply(t,e,s){const i=t.c*e.s-t.s*e.c,o=t.c*e.c+t.s*e.s;return s.s=i,s.c=o,s}static MultiplyVec2(t,e,s){const i=e.x,o=e.y;return s.x=t.c*i-t.s*o,s.y=t.s*i+t.c*o,s}static TransposeMultiplyVec2(t,e,s){const i=e.x,o=e.y;return s.x=t.c*i+t.s*o,s.y=-t.s*i+t.c*o,s}}t.b2Rot=c,c.IDENTITY=new c;class m{constructor(){this.p=new o,this.q=new c}Clone(){return(new m).Copy(this)}Copy(t){return this.p.Copy(t.p),this.q.Copy(t.q),this}SetIdentity(){return this.p.SetZero(),this.q.SetIdentity(),this}SetPositionRotation(t,e){return this.p.Copy(t),this.q.Copy(e),this}SetPositionAngle(t,e){return this.p.Copy(t),this.q.Set(e),this}SetPosition(t){return this.p.Copy(t),this}SetPositionXY(t,e){return this.p.Set(t,e),this}SetRotation(t){return this.q.Copy(t),this}SetRotationAngle(t){return this.q.Set(t),this}GetPosition(){return this.p}GetRotation(){return this.q}GetAngle(){return this.q.GetAngle()}static MultiplyVec2(t,e,s){const i=e.x,o=e.y;return s.x=t.q.c*i-t.q.s*o+t.p.x,s.y=t.q.s*i+t.q.c*o+t.p.y,s}static TransposeMultiplyVec2(t,e,s){const i=e.x-t.p.x,o=e.y-t.p.y;return s.x=t.q.c*i+t.q.s*o,s.y=-t.q.s*i+t.q.c*o,s}static Multiply(t,e,s){return c.Multiply(t.q,e.q,s.q),c.MultiplyVec2(t.q,e.p,s.p).Add(t.p),s}static TransposeMultiply(t,e,s){return c.TransposeMultiply(t.q,e.q,s.q),c.TransposeMultiplyVec2(t.q,o.Subtract(e.p,t.p,s.p),s.p),s}}t.b2Transform=m,m.IDENTITY=new m;class l{constructor(){this.localCenter=new o,this.c0=new o,this.c=new o,this.a0=0,this.a=0,this.alpha0=0}Clone(){return(new l).Copy(this)}Copy(t){return this.localCenter.Copy(t.localCenter),this.c0.Copy(t.c0),this.c.Copy(t.c),this.a0=t.a0,this.a=t.a,this.alpha0=t.alpha0,this}GetTransform(t,e){const s=1-e;t.p.x=s*this.c0.x+e*this.c.x,t.p.y=s*this.c0.y+e*this.c.y;const i=s*this.a0+e*this.a;return t.q.Set(i),t.p.Subtract(c.MultiplyVec2(t.q,this.localCenter,o.s_t0)),t}Advance(t){const e=(t-this.alpha0)/(1-this.alpha0);this.c0.x+=e*(this.c.x-this.c0.x),this.c0.y+=e*(this.c.y-this.c0.y),this.a0+=e*(this.a-this.a0),this.alpha0=t}Normalize(){const e=t.b2_two_pi*Math.floor(this.a0/t.b2_two_pi);this.a0-=e,this.a-=e}}t.b2Sweep=l}(o);var n={};Object.defineProperty(n,"__esModule",{value:!0}),n.debugColors=n.b2Color=void 0;class r{constructor(t=.5,e=.5,s=.5,i=1){this.r=t,this.g=e,this.b=s,this.a=i}Clone(){return new r(this.r,this.g,this.b,this.a)}Copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this.a=t.a,this}IsEqual(t){return this.r===t.r&&this.g===t.g&&this.b===t.b&&this.a===t.a}IsZero(){return 0===this.r&&0===this.g&&0===this.b&&0===this.a}SetByteRGB(t,e,s){return this.r=t/255,this.g=e/255,this.b=s/255,this}SetByteRGBA(t,e,s,i){return this.r=t/255,this.g=e/255,this.b=s/255,this.a=i/255,this}SetRGB(t,e,s){return this.r=t,this.g=e,this.b=s,this}SetRGBA(t,e,s,i){return this.r=t,this.g=e,this.b=s,this.a=i,this}Add(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this.a+=t.a,this}Subtract(t){return this.r-=t.r,this.g-=t.g,this.b-=t.b,this.a-=t.a,this}Scale(t){return this.r*=t,this.g*=t,this.b*=t,this.a*=t,this}Mix(t,e){r.MixColors(this,t,e)}static Add(t,e,s){return s.r=t.r+e.r,s.g=t.g+e.g,s.b=t.b+e.b,s.a=t.a+e.a,s}static Subtract(t,e,s){return s.r=t.r-e.r,s.g=t.g-e.g,s.b=t.b-e.b,s.a=t.a-e.a,s}static Scale(t,e,s){return s.r=t.r*e,s.g=t.g*e,s.b=t.b*e,s.a=t.a*e,s}static MixColors(t,e,s){const i=s*(e.r-t.r),o=s*(e.g-t.g),n=s*(e.b-t.b),r=s*(e.a-t.a);t.r+=i,t.g+=o,t.b+=n,t.a+=r,e.r-=i,e.g-=o,e.b-=n,e.a-=r}}n.b2Color=r,r.ZERO=new r(0,0,0,0),r.RED=new r(1,0,0),r.GREEN=new r(0,1,0),r.BLUE=new r(0,0,1),r.WHITE=new r(1,1,1),r.BLACK=new r(0,0,0),n.debugColors={badBody:new r(1,0,0),disabledBody:new r(.5,.5,.3),staticBody:new r(.5,.9,.5),kinematicBody:new r(.5,.5,.9),sleepingBody:new r(.6,.6,.6),body:new r(.9,.7,.7),pair:new r(.3,.9,.9),aabb:new r(.9,.3,.9),joint1:new r(.7,.7,.7),joint2:new r(.3,.9,.3),joint3:new r(.9,.3,.3),joint4:new r(.3,.3,.9),joint5:new r(.4,.4,.4),joint6:new r(.5,.8,.8),joint7:new r(0,1,0),joint8:new r(.8,.8,.8),rope:new r(.4,.5,.7),ropePointG:new r(.1,.8,.1),ropePointD:new r(.7,.2,.4)};var a={},c={},m={};!function(t){Object.defineProperty(t,"__esModule",{value:!0}),t.b2Shape=t.b2ShapeType=t.b2MassData=void 0;const e=o;t.b2MassData=class{constructor(){this.mass=0,this.center=new e.b2Vec2,this.I=0}},function(t){t[t.e_unknown=-1]="e_unknown",t[t.e_circle=0]="e_circle",t[t.e_edge=1]="e_edge",t[t.e_polygon=2]="e_polygon",t[t.e_chain=3]="e_chain",t[t.e_typeCount=4]="e_typeCount"}(t.b2ShapeType||(t.b2ShapeType={}));t.b2Shape=class{constructor(t,e){this.m_radius=0,this.m_type=t,this.m_radius=e}Copy(t){return this.m_radius=t.m_radius,this}GetType(){return this.m_type}}}(m);var l={},h={},_={};!function(t){Object.defineProperty(t,"__esModule",{value:!0}),t.b2ShapeCast=t.b2Distance=t.b2Gjk=t.b2ShapeCastOutput=t.b2ShapeCastInput=t.b2DistanceOutput=t.b2DistanceInput=t.b2SimplexCache=t.b2DistanceProxy=void 0;const e=s,i=o;class n{constructor(){this.m_buffer=(0,e.b2MakeArray)(2,i.b2Vec2),this.m_vertices=this.m_buffer,this.m_count=0,this.m_radius=0}Copy(t){return t.m_vertices===t.m_buffer?(this.m_vertices=this.m_buffer,this.m_buffer[0].Copy(t.m_buffer[0]),this.m_buffer[1].Copy(t.m_buffer[1])):this.m_vertices=t.m_vertices,this.m_count=t.m_count,this.m_radius=t.m_radius,this}Reset(){return this.m_vertices=this.m_buffer,this.m_count=0,this.m_radius=0,this}SetShape(t,e){t.SetupDistanceProxy(this,e)}SetVerticesRadius(t,e,s){this.m_vertices=t,this.m_count=e,this.m_radius=s}GetSupport(t){let e=0,s=i.b2Vec2.Dot(this.m_vertices[0],t);for(let o=1;o<this.m_count;++o){const n=i.b2Vec2.Dot(this.m_vertices[o],t);n>s&&(e=o,s=n)}return e}GetSupportVertex(t){let e=0,s=i.b2Vec2.Dot(this.m_vertices[0],t);for(let o=1;o<this.m_count;++o){const n=i.b2Vec2.Dot(this.m_vertices[o],t);n>s&&(e=o,s=n)}return this.m_vertices[e]}GetVertexCount(){return this.m_count}GetVertex(t){return this.m_vertices[t]}}t.b2DistanceProxy=n;t.b2SimplexCache=class{constructor(){this.metric=0,this.count=0,this.indexA=[0,0,0],this.indexB=[0,0,0]}Reset(){return this.metric=0,this.count=0,this}};t.b2DistanceInput=class{constructor(){this.proxyA=new n,this.proxyB=new n,this.transformA=new i.b2Transform,this.transformB=new i.b2Transform,this.useRadii=!1}Reset(){return this.proxyA.Reset(),this.proxyB.Reset(),this.transformA.SetIdentity(),this.transformB.SetIdentity(),this.useRadii=!1,this}};t.b2DistanceOutput=class{constructor(){this.pointA=new i.b2Vec2,this.pointB=new i.b2Vec2,this.distance=0,this.iterations=0}Reset(){return this.pointA.SetZero(),this.pointB.SetZero(),this.distance=0,this.iterations=0,this}};t.b2ShapeCastInput=class{constructor(){this.proxyA=new n,this.proxyB=new n,this.transformA=new i.b2Transform,this.transformB=new i.b2Transform,this.translationB=new i.b2Vec2}};t.b2ShapeCastOutput=class{constructor(){this.point=new i.b2Vec2,this.normal=new i.b2Vec2,this.lambda=0,this.iterations=0}},t.b2Gjk={calls:0,iters:0,maxIters:0,reset(){this.calls=0,this.iters=0,this.maxIters=0}};class r{constructor(){this.wA=new i.b2Vec2,this.wB=new i.b2Vec2,this.w=new i.b2Vec2,this.a=0,this.indexA=0,this.indexB=0}Copy(t){return this.wA.Copy(t.wA),this.wB.Copy(t.wB),this.w.Copy(t.w),this.a=t.a,this.indexA=t.indexA,this.indexB=t.indexB,this}}class a{constructor(){this.m_v1=new r,this.m_v2=new r,this.m_v3=new r,this.m_count=0,this.m_vertices=[this.m_v1,this.m_v2,this.m_v3]}ReadCache(t,s,o,n,r){this.m_count=t.count;const a=this.m_vertices;for(let e=0;e<this.m_count;++e){const c=a[e];c.indexA=t.indexA[e],c.indexB=t.indexB[e];const m=s.GetVertex(c.indexA),l=n.GetVertex(c.indexB);i.b2Transform.MultiplyVec2(o,m,c.wA),i.b2Transform.MultiplyVec2(r,l,c.wB),i.b2Vec2.Subtract(c.wB,c.wA,c.w),c.a=0}if(this.m_count>1){const s=t.metric,i=this.GetMetric();(i<.5*s||2*s<i||i<e.b2_epsilon)&&(this.m_count=0)}if(0===this.m_count){const t=a[0];t.indexA=0,t.indexB=0;const e=s.GetVertex(0),c=n.GetVertex(0);i.b2Transform.MultiplyVec2(o,e,t.wA),i.b2Transform.MultiplyVec2(r,c,t.wB),i.b2Vec2.Subtract(t.wB,t.wA,t.w),t.a=1,this.m_count=1}}WriteCache(t){t.metric=this.GetMetric(),t.count=this.m_count;const e=this.m_vertices;for(let s=0;s<this.m_count;++s)t.indexA[s]=e[s].indexA,t.indexB[s]=e[s].indexB}GetSearchDirection(t){switch(this.m_count){case 1:return i.b2Vec2.Negate(this.m_v1.w,t);case 2:{const e=i.b2Vec2.Subtract(this.m_v2.w,this.m_v1.w,t);return i.b2Vec2.Cross(e,i.b2Vec2.Negate(this.m_v1.w,i.b2Vec2.s_t0))>0?i.b2Vec2.CrossOneVec2(e,t):i.b2Vec2.CrossVec2One(e,t)}default:return t.SetZero()}}GetClosestPoint(t){switch(this.m_count){case 0:case 3:default:return t.SetZero();case 1:return t.Copy(this.m_v1.w);case 2:return t.Set(this.m_v1.a*this.m_v1.w.x+this.m_v2.a*this.m_v2.w.x,this.m_v1.a*this.m_v1.w.y+this.m_v2.a*this.m_v2.w.y)}}GetWitnessPoints(t,e){switch(this.m_count){case 0:break;case 1:t.Copy(this.m_v1.wA),e.Copy(this.m_v1.wB);break;case 2:t.x=this.m_v1.a*this.m_v1.wA.x+this.m_v2.a*this.m_v2.wA.x,t.y=this.m_v1.a*this.m_v1.wA.y+this.m_v2.a*this.m_v2.wA.y,e.x=this.m_v1.a*this.m_v1.wB.x+this.m_v2.a*this.m_v2.wB.x,e.y=this.m_v1.a*this.m_v1.wB.y+this.m_v2.a*this.m_v2.wB.y;break;case 3:e.x=t.x=this.m_v1.a*this.m_v1.wA.x+this.m_v2.a*this.m_v2.wA.x+this.m_v3.a*this.m_v3.wA.x,e.y=t.y=this.m_v1.a*this.m_v1.wA.y+this.m_v2.a*this.m_v2.wA.y+this.m_v3.a*this.m_v3.wA.y}}GetMetric(){switch(this.m_count){case 0:case 1:default:return 0;case 2:return i.b2Vec2.Distance(this.m_v1.w,this.m_v2.w);case 3:return i.b2Vec2.Cross(i.b2Vec2.Subtract(this.m_v2.w,this.m_v1.w,i.b2Vec2.s_t0),i.b2Vec2.Subtract(this.m_v3.w,this.m_v1.w,i.b2Vec2.s_t1))}}Solve2(){const t=this.m_v1.w,e=this.m_v2.w,s=i.b2Vec2.Subtract(e,t,a.s_e12),o=-i.b2Vec2.Dot(t,s);if(o<=0)return this.m_v1.a=1,void(this.m_count=1);const n=i.b2Vec2.Dot(e,s);if(n<=0)return this.m_v2.a=1,this.m_count=1,void this.m_v1.Copy(this.m_v2);const r=1/(n+o);this.m_v1.a=n*r,this.m_v2.a=o*r,this.m_count=2}Solve3(){const t=this.m_v1.w,e=this.m_v2.w,s=this.m_v3.w,o=i.b2Vec2.Subtract(e,t,a.s_e12),n=i.b2Vec2.Dot(t,o),r=i.b2Vec2.Dot(e,o),c=-n,m=i.b2Vec2.Subtract(s,t,a.s_e13),l=i.b2Vec2.Dot(t,m),h=i.b2Vec2.Dot(s,m),_=-l,b=i.b2Vec2.Subtract(s,e,a.s_e23),u=i.b2Vec2.Dot(e,b),d=i.b2Vec2.Dot(s,b),p=-u,y=i.b2Vec2.Cross(o,m),A=y*i.b2Vec2.Cross(e,s),x=y*i.b2Vec2.Cross(s,t),V=y*i.b2Vec2.Cross(t,e);if(c<=0&&_<=0)return this.m_v1.a=1,void(this.m_count=1);if(r>0&&c>0&&V<=0){const t=1/(r+c);return this.m_v1.a=r*t,this.m_v2.a=c*t,void(this.m_count=2)}if(h>0&&_>0&&x<=0){const t=1/(h+_);return this.m_v1.a=h*t,this.m_v3.a=_*t,this.m_count=2,void this.m_v2.Copy(this.m_v3)}if(r<=0&&p<=0)return this.m_v2.a=1,this.m_count=1,void this.m_v1.Copy(this.m_v2);if(h<=0&&d<=0)return this.m_v3.a=1,this.m_count=1,void this.m_v1.Copy(this.m_v3);if(d>0&&p>0&&A<=0){const t=1/(d+p);return this.m_v2.a=d*t,this.m_v3.a=p*t,this.m_count=2,void this.m_v1.Copy(this.m_v3)}const S=1/(A+x+V);this.m_v1.a=A*S,this.m_v2.a=x*S,this.m_v3.a=V*S,this.m_count=3}}a.s_e12=new i.b2Vec2,a.s_e13=new i.b2Vec2,a.s_e23=new i.b2Vec2;const c=new a,m=[0,0,0],l=[0,0,0],h=new i.b2Vec2,_=new i.b2Vec2,b=new i.b2Vec2,u=new i.b2Vec2,d=new i.b2Vec2;t.b2Distance=function(s,o,n){++t.b2Gjk.calls;const{proxyA:r,proxyB:a,transformA:p,transformB:y}=n,A=c;A.ReadCache(o,r,p,a,y);const x=A.m_vertices,V=m,S=l;let v=0,f=0;for(;f<20;){v=A.m_count;for(let t=0;t<v;++t)V[t]=x[t].indexA,S[t]=x[t].indexB;switch(A.m_count){case 1:break;case 2:A.Solve2();break;case 3:A.Solve3()}if(3===A.m_count)break;const s=A.GetSearchDirection(_);if(s.LengthSquared()<e.b2_epsilon_sq)break;const o=x[A.m_count];o.indexA=r.GetSupport(i.b2Rot.TransposeMultiplyVec2(p.q,i.b2Vec2.Negate(s,i.b2Vec2.s_t0),u)),i.b2Transform.MultiplyVec2(p,r.GetVertex(o.indexA),o.wA),o.indexB=a.GetSupport(i.b2Rot.TransposeMultiplyVec2(y.q,s,d)),i.b2Transform.MultiplyVec2(y,a.GetVertex(o.indexB),o.wB),i.b2Vec2.Subtract(o.wB,o.wA,o.w),++f,++t.b2Gjk.iters;let n=!1;for(let t=0;t<v;++t)if(o.indexA===V[t]&&o.indexB===S[t]){n=!0;break}if(n)break;++A.m_count}if(t.b2Gjk.maxIters=Math.max(t.b2Gjk.maxIters,f),A.GetWitnessPoints(s.pointA,s.pointB),s.distance=i.b2Vec2.Distance(s.pointA,s.pointB),s.iterations=f,A.WriteCache(o),n.useRadii){const t=r.m_radius,o=a.m_radius;if(s.distance>t+o&&s.distance>e.b2_epsilon){s.distance-=t+o;const e=i.b2Vec2.Subtract(s.pointB,s.pointA,b);e.Normalize(),s.pointA.AddScaled(t,e),s.pointB.SubtractScaled(o,e)}else{const t=i.b2Vec2.Mid(s.pointA,s.pointB,h);s.pointA.Copy(t),s.pointB.Copy(t),s.distance=0}}};const p=new i.b2Vec2,y=new a,A=new i.b2Vec2,x=new i.b2Vec2,V=new i.b2Vec2,S=new i.b2Vec2,v=new i.b2Vec2,f=new i.b2Vec2;t.b2ShapeCast=function(t,s){t.iterations=0,t.lambda=1,t.normal.SetZero(),t.point.SetZero();const{proxyA:o,proxyB:n}=s,r=Math.max(o.m_radius,e.b2_polygonRadius),a=r+Math.max(n.m_radius,e.b2_polygonRadius),c=s.transformA,m=s.transformB,l=s.translationB,h=p.SetZero();let _=0;const b=y;b.m_count=0;const u=b.m_vertices;let d=o.GetSupport(i.b2Rot.TransposeMultiplyVec2(c.q,i.b2Vec2.Negate(l,i.b2Vec2.s_t1),i.b2Vec2.s_t0)),C=i.b2Transform.MultiplyVec2(c,o.GetVertex(d),A),B=n.GetSupport(i.b2Rot.TransposeMultiplyVec2(m.q,l,i.b2Vec2.s_t0)),w=i.b2Transform.MultiplyVec2(m,n.GetVertex(B),x);const g=i.b2Vec2.Subtract(C,w,V),M=Math.max(e.b2_polygonRadius,a-e.b2_polygonRadius),I=.5*e.b2_linearSlop;let T=0;for(;T<20&&g.Length()-M>I;){t.iterations+=1,d=o.GetSupport(i.b2Rot.TransposeMultiplyVec2(c.q,i.b2Vec2.Negate(g,i.b2Vec2.s_t1),i.b2Vec2.s_t0)),C=i.b2Transform.MultiplyVec2(c,o.GetVertex(d),A),B=n.GetSupport(i.b2Rot.TransposeMultiplyVec2(m.q,g,i.b2Vec2.s_t0)),w=i.b2Transform.MultiplyVec2(m,n.GetVertex(B),x);const e=i.b2Vec2.Subtract(C,w,S);g.Normalize();const s=i.b2Vec2.Dot(g,e),r=i.b2Vec2.Dot(g,l);if(s-M>_*r){if(r<=0)return!1;if(_=(s-M)/r,_>1)return!1;i.b2Vec2.Negate(g,h),b.m_count=0}const a=u[b.m_count];switch(a.indexA=B,i.b2Vec2.AddScaled(w,_,l,a.wA),a.indexB=d,a.wB.Copy(C),i.b2Vec2.Subtract(a.wB,a.wA,a.w),a.a=1,b.m_count+=1,b.m_count){case 1:break;case 2:b.Solve2();break;case 3:b.Solve3()}if(3===b.m_count)return!1;b.GetClosestPoint(g),++T}if(0===T)return!1;const D=v,G=f;return b.GetWitnessPoints(D,G),g.LengthSquared()>0&&(i.b2Vec2.Negate(g,h),h.Normalize()),i.b2Vec2.AddScaled(D,r,h,t.point),t.normal.Copy(h),t.lambda=_,t.iterations=T,!0}}(_),function(t){Object.defineProperty(t,"__esModule",{value:!0}),t.b2TestOverlap=t.b2ClipSegmentToLine=t.b2AABB=t.b2RayCastOutput=t.b2RayCastInput=t.b2ClipVertex=t.b2GetPointStates=t.b2PointState=t.b2WorldManifold=t.b2Manifold=t.b2ManifoldType=t.b2ManifoldPoint=t.b2ContactID=t.b2ContactFeature=t.b2ContactFeatureType=void 0;const e=s,i=o,n=_;var r,a,c;!function(t){t[t.e_vertex=0]="e_vertex",t[t.e_face=1]="e_face"}(r=t.b2ContactFeatureType||(t.b2ContactFeatureType={}));class m{constructor(){this.m_key=0,this.m_key_invalid=!1,this.m_indexA=0,this.m_indexB=0,this.m_typeA=r.e_vertex,this.m_typeB=r.e_vertex}get key(){return this.m_key_invalid&&(this.m_key_invalid=!1,this.m_key=this.m_indexA|this.m_indexB<<8|this.m_typeA<<16|this.m_typeB<<24),this.m_key}set key(t){this.m_key=t,this.m_key_invalid=!1,this.m_indexA=255&this.m_key,this.m_indexB=this.m_key>>8&255,this.m_typeA=this.m_key>>16&255,this.m_typeB=this.m_key>>24&255}get indexA(){return this.m_indexA}set indexA(t){this.m_indexA=t,this.m_key_invalid=!0}get indexB(){return this.m_indexB}set indexB(t){this.m_indexB=t,this.m_key_invalid=!0}get typeA(){return this.m_typeA}set typeA(t){this.m_typeA=t,this.m_key_invalid=!0}get typeB(){return this.m_typeB}set typeB(t){this.m_typeB=t,this.m_key_invalid=!0}}t.b2ContactFeature=m;class l{constructor(){this.cf=new m}Copy(t){return this.key=t.key,this}Clone(){return(new l).Copy(this)}get key(){return this.cf.key}set key(t){this.cf.key=t}}t.b2ContactID=l;class h{constructor(){this.localPoint=new i.b2Vec2,this.normalImpulse=0,this.tangentImpulse=0,this.id=new l}Reset(){this.localPoint.SetZero(),this.normalImpulse=0,this.tangentImpulse=0,this.id.key=0}Copy(t){return this.localPoint.Copy(t.localPoint),this.normalImpulse=t.normalImpulse,this.tangentImpulse=t.tangentImpulse,this.id.Copy(t.id),this}}t.b2ManifoldPoint=h,function(t){t[t.e_circles=0]="e_circles",t[t.e_faceA=1]="e_faceA",t[t.e_faceB=2]="e_faceB"}(a=t.b2ManifoldType||(t.b2ManifoldType={}));class b{constructor(){this.points=(0,e.b2MakeArray)(e.b2_maxManifoldPoints,h),this.localNormal=new i.b2Vec2,this.localPoint=new i.b2Vec2,this.type=a.e_circles,this.pointCount=0}Reset(){for(let t=0;t<e.b2_maxManifoldPoints;++t)this.points[t].Reset();this.localNormal.SetZero(),this.localPoint.SetZero(),this.type=a.e_circles,this.pointCount=0}Copy(t){this.pointCount=t.pointCount;for(let s=0;s<e.b2_maxManifoldPoints;++s)this.points[s].Copy(t.points[s]);return this.localNormal.Copy(t.localNormal),this.localPoint.Copy(t.localPoint),this.type=t.type,this}Clone(){return(new b).Copy(this)}}t.b2Manifold=b;class u{constructor(){this.normal=new i.b2Vec2,this.points=(0,e.b2MakeArray)(e.b2_maxManifoldPoints,i.b2Vec2),this.separations=(0,e.b2MakeNumberArray)(e.b2_maxManifoldPoints)}Initialize(t,s,o,n,r){if(0!==t.pointCount)switch(t.type){case a.e_circles:{this.normal.Set(1,0);const a=i.b2Transform.MultiplyVec2(s,t.localPoint,u.Initialize_s_pointA),c=i.b2Transform.MultiplyVec2(n,t.points[0].localPoint,u.Initialize_s_pointB);i.b2Vec2.DistanceSquared(a,c)>e.b2_epsilon_sq&&i.b2Vec2.Subtract(c,a,this.normal).Normalize();const m=i.b2Vec2.AddScaled(a,o,this.normal,u.Initialize_s_cA),l=i.b2Vec2.SubtractScaled(c,r,this.normal,u.Initialize_s_cB);i.b2Vec2.Mid(m,l,this.points[0]),this.separations[0]=i.b2Vec2.Dot(i.b2Vec2.Subtract(l,m,i.b2Vec2.s_t0),this.normal);break}case a.e_faceA:{i.b2Rot.MultiplyVec2(s.q,t.localNormal,this.normal);const e=i.b2Transform.MultiplyVec2(s,t.localPoint,u.Initialize_s_planePoint);for(let s=0;s<t.pointCount;++s){const a=i.b2Transform.MultiplyVec2(n,t.points[s].localPoint,u.Initialize_s_clipPoint),c=o-i.b2Vec2.Dot(i.b2Vec2.Subtract(a,e,i.b2Vec2.s_t0),this.normal),m=i.b2Vec2.AddScaled(a,c,this.normal,u.Initialize_s_cA),l=i.b2Vec2.SubtractScaled(a,r,this.normal,u.Initialize_s_cB);i.b2Vec2.Mid(m,l,this.points[s]),this.separations[s]=i.b2Vec2.Dot(i.b2Vec2.Subtract(l,m,i.b2Vec2.s_t0),this.normal)}break}case a.e_faceB:{i.b2Rot.MultiplyVec2(n.q,t.localNormal,this.normal);const e=i.b2Transform.MultiplyVec2(n,t.localPoint,u.Initialize_s_planePoint);for(let n=0;n<t.pointCount;++n){const a=i.b2Transform.MultiplyVec2(s,t.points[n].localPoint,u.Initialize_s_clipPoint),c=r-i.b2Vec2.Dot(i.b2Vec2.Subtract(a,e,i.b2Vec2.s_t0),this.normal),m=i.b2Vec2.AddScaled(a,c,this.normal,u.Initialize_s_cB),l=i.b2Vec2.SubtractScaled(a,o,this.normal,u.Initialize_s_cA);i.b2Vec2.Mid(l,m,this.points[n]),this.separations[n]=i.b2Vec2.Dot(i.b2Vec2.Subtract(l,m,i.b2Vec2.s_t0),this.normal)}this.normal.Negate();break}}}}t.b2WorldManifold=u,u.Initialize_s_pointA=new i.b2Vec2,u.Initialize_s_pointB=new i.b2Vec2,u.Initialize_s_cA=new i.b2Vec2,u.Initialize_s_cB=new i.b2Vec2,u.Initialize_s_planePoint=new i.b2Vec2,u.Initialize_s_clipPoint=new i.b2Vec2,function(t){t[t.b2_nullState=0]="b2_nullState",t[t.b2_addState=1]="b2_addState",t[t.b2_persistState=2]="b2_persistState",t[t.b2_removeState=3]="b2_removeState"}(c=t.b2PointState||(t.b2PointState={})),t.b2GetPointStates=function(t,s,i,o){let n;for(n=0;n<i.pointCount;++n){const{key:e}=i.points[n].id;t[n]=c.b2_removeState;for(let s=0;s<o.pointCount;++s)if(o.points[s].id.key===e){t[n]=c.b2_persistState;break}}for(;n<e.b2_maxManifoldPoints;++n)t[n]=c.b2_nullState;for(n=0;n<o.pointCount;++n){const{key:t}=o.points[n].id;s[n]=c.b2_addState;for(let e=0;e<i.pointCount;++e)if(i.points[e].id.key===t){s[n]=c.b2_persistState;break}}for(;n<e.b2_maxManifoldPoints;++n)s[n]=c.b2_nullState};t.b2ClipVertex=class{constructor(){this.v=new i.b2Vec2,this.id=new l}Copy(t){return this.v.Copy(t.v),this.id.Copy(t.id),this}};t.b2RayCastInput=class{constructor(){this.p1=new i.b2Vec2,this.p2=new i.b2Vec2,this.maxFraction=1}Copy(t){return this.p1.Copy(t.p1),this.p2.Copy(t.p2),this.maxFraction=t.maxFraction,this}};t.b2RayCastOutput=class{constructor(){this.normal=new i.b2Vec2,this.fraction=0}Copy(t){return this.normal.Copy(t.normal),this.fraction=t.fraction,this}};t.b2AABB=class{constructor(){this.lowerBound=new i.b2Vec2,this.upperBound=new i.b2Vec2}Copy(t){return this.lowerBound.Copy(t.lowerBound),this.upperBound.Copy(t.upperBound),this}IsValid(){return this.lowerBound.IsValid()&&this.upperBound.IsValid()&&this.upperBound.x>=this.lowerBound.x&&this.upperBound.y>=this.lowerBound.y}GetCenter(t){return i.b2Vec2.Mid(this.lowerBound,this.upperBound,t)}GetExtents(t){return i.b2Vec2.Extents(this.lowerBound,this.upperBound,t)}GetPerimeter(){return 2*(this.upperBound.x-this.lowerBound.x+(this.upperBound.y-this.lowerBound.y))}Combine1(t){return this.lowerBound.x=Math.min(this.lowerBound.x,t.lowerBound.x),this.lowerBound.y=Math.min(this.lowerBound.y,t.lowerBound.y),this.upperBound.x=Math.max(this.upperBound.x,t.upperBound.x),this.upperBound.y=Math.max(this.upperBound.y,t.upperBound.y),this}Combine2(t,e){return this.lowerBound.x=Math.min(t.lowerBound.x,e.lowerBound.x),this.lowerBound.y=Math.min(t.lowerBound.y,e.lowerBound.y),this.upperBound.x=Math.max(t.upperBound.x,e.upperBound.x),this.upperBound.y=Math.max(t.upperBound.y,e.upperBound.y),this}static Combine(t,e,s){return s.Combine2(t,e),s}Contains(t){return this.lowerBound.x<=t.lowerBound.x&&this.lowerBound.y<=t.lowerBound.y&&t.upperBound.x<=this.upperBound.x&&t.upperBound.y<=this.upperBound.y}RayCast(t,s){let i=-e.b2_maxFloat,o=e.b2_maxFloat;const n=s.p1.x,r=s.p1.y,a=s.p2.x-s.p1.x,c=s.p2.y-s.p1.y,m=Math.abs(a),l=Math.abs(c),{normal:h}=t;if(m<e.b2_epsilon){if(n<this.lowerBound.x||this.upperBound.x<n)return!1}else{const t=1/a;let e=(this.lowerBound.x-n)*t,s=(this.upperBound.x-n)*t,r=-1;if(e>s){const t=e;e=s,s=t,r=1}if(e>i&&(h.x=r,h.y=0,i=e),o=Math.min(o,s),i>o)return!1}if(l<e.b2_epsilon){if(r<this.lowerBound.y||this.upperBound.y<r)return!1}else{const t=1/c;let e=(this.lowerBound.y-r)*t,s=(this.upperBound.y-r)*t,n=-1;if(e>s){const t=e;e=s,s=t,n=1}if(e>i&&(h.x=0,h.y=n,i=e),o=Math.min(o,s),i>o)return!1}return!(i<0||s.maxFraction<i)&&(t.fraction=i,!0)}TestContain(t){return!(t.x<this.lowerBound.x||this.upperBound.x<t.x)&&!(t.y<this.lowerBound.y||this.upperBound.y<t.y)}TestOverlap(t){return!(this.upperBound.x<t.lowerBound.x)&&(!(this.upperBound.y<t.lowerBound.y)&&(!(t.upperBound.x<this.lowerBound.x)&&!(t.upperBound.y<this.lowerBound.y)))}},t.b2ClipSegmentToLine=function(t,[e,s],o,n,a){let c=0;const m=i.b2Vec2.Dot(o,e.v)-n,l=i.b2Vec2.Dot(o,s.v)-n;if(m<=0&&t[c++].Copy(e),l<=0&&t[c++].Copy(s),m*l<0){const i=m/(m-l),{v:o,id:n}=t[c];o.x=e.v.x+i*(s.v.x-e.v.x),o.y=e.v.y+i*(s.v.y-e.v.y),n.cf.indexA=a,n.cf.indexB=e.id.cf.indexB,n.cf.typeA=r.e_vertex,n.cf.typeB=r.e_face,++c}return c};const d=new n.b2DistanceInput,p=new n.b2SimplexCache,y=new n.b2DistanceOutput;t.b2TestOverlap=function(t,s,i,o,r,a){const c=d.Reset();c.proxyA.SetShape(t,s),c.proxyB.SetShape(i,o),c.transformA.Copy(r),c.transformB.Copy(a),c.useRadii=!0;const m=p.Reset();m.count=0;const l=y.Reset();return(0,n.b2Distance)(l,m,c),l.distance<10*e.b2_epsilon}}(h),function(t){Object.defineProperty(t,"__esModule",{value:!0}),t.b2Fixture=t.b2FixtureProxy=t.b2DefaultFilter=void 0;const e=o,n=h,r=m,a=s,c=i,l={c1:new e.b2Vec2,c2:new e.b2Vec2};t.b2DefaultFilter={categoryBits:1,maskBits:65535,groupIndex:0};class _{constructor(t,e,s,i){this.aabb=new n.b2AABB,this.fixture=t,this.childIndex=i,t.m_shape.ComputeAABB(this.aabb,s,i),this.treeNode=e.CreateProxy(this.aabb,this)}}t.b2FixtureProxy=_;const b=new n.b2AABB,u=new n.b2AABB,d=new e.b2Vec2;t.b2Fixture=class{constructor(e,s){var i,o,n,r,a;this.m_density=0,this.m_next=null,this.m_friction=0,this.m_restitution=0,this.m_restitutionThreshold=0,this.m_proxies=[],this.m_isSensor=!1,this.m_userData=null,this.m_body=e,this.m_shape=s.shape.Clone(),this.m_userData=s.userData,this.m_friction=null!==(i=s.friction)&&void 0!==i?i:.2,this.m_restitution=null!==(o=s.restitution)&&void 0!==o?o:0,this.m_restitutionThreshold=null!==(n=s.restitutionThreshold)&&void 0!==n?n:c.b2_lengthUnitsPerMeter,this.m_filter={...t.b2DefaultFilter,...s.filter},this.m_isSensor=null!==(r=s.isSensor)&&void 0!==r&&r,this.m_density=null!==(a=s.density)&&void 0!==a?a:0}get m_proxyCount(){return this.m_proxies.length}GetType(){return this.m_shape.GetType()}GetShape(){return this.m_shape}SetSensor(t){t!==this.m_isSensor&&(this.m_body.SetAwake(!0),this.m_isSensor=t)}IsSensor(){return this.m_isSensor}SetFilterData(e){var s,i,o;this.m_filter.categoryBits=null!==(s=e.categoryBits)&&void 0!==s?s:t.b2DefaultFilter.categoryBits,this.m_filter.groupIndex=null!==(i=e.groupIndex)&&void 0!==i?i:t.b2DefaultFilter.groupIndex,this.m_filter.maskBits=null!==(o=e.maskBits)&&void 0!==o?o:t.b2DefaultFilter.maskBits,this.Refilter()}GetFilterData(){return this.m_filter}Refilter(){let t=this.m_body.GetContactList();for(;t;){const{contact:e}=t,s=e.GetFixtureA(),i=e.GetFixtureB();s!==this&&i!==this||e.FlagForFiltering(),t=t.next}const e=this.m_body.GetWorld().m_contactManager.m_broadPhase;for(const t of this.m_proxies)e.TouchProxy(t.treeNode)}GetBody(){return this.m_body}GetNext(){return this.m_next}GetUserData(){return this.m_userData}SetUserData(t){this.m_userData=t}TestPoint(t){return this.m_shape.TestPoint(this.m_body.GetTransform(),t)}RayCast(t,e,s){return this.m_shape.RayCast(t,e,this.m_body.GetTransform(),s)}GetMassData(t=new r.b2MassData){return this.m_shape.ComputeMass(t,this.m_density),t}SetDensity(t){this.m_density=t}GetDensity(){return this.m_density}GetFriction(){return this.m_friction}SetFriction(t){this.m_friction=t}GetRestitution(){return this.m_restitution}SetRestitution(t){this.m_restitution=t}SetRestitutionThreshold(t){this.m_restitutionThreshold=t}GetAABB(t){return this.m_proxies[t].aabb}CreateProxies(t,e){(0,a.b2Assert)(0===this.m_proxies.length),this.m_proxies.length=this.m_shape.GetChildCount();for(let s=0;s<this.m_proxies.length;++s)this.m_proxies[s]=new _(this,t,e,s)}DestroyProxies(t){for(const e of this.m_proxies)t.DestroyProxy(e.treeNode);this.m_proxies.length=0}Synchronize(t,s,i){const{c1:o,c2:n}=l,r=d;for(const a of this.m_proxies){const c=b,m=u;this.m_shape.ComputeAABB(c,s,a.childIndex),this.m_shape.ComputeAABB(m,i,a.childIndex),a.aabb.Combine2(c,m),e.b2Vec2.Subtract(m.GetCenter(n),c.GetCenter(o),r),t.MoveProxy(a.treeNode,a.aabb,r)}}}}(l),function(t){Object.defineProperty(t,"__esModule",{value:!0}),t.b2Body=t.b2BodyType=void 0;const e=o,i=m,n=l,r=s;var a;!function(t){t[t.b2_staticBody=0]="b2_staticBody",t[t.b2_kinematicBody=1]="b2_kinematicBody",t[t.b2_dynamicBody=2]="b2_dynamicBody"}(a=t.b2BodyType||(t.b2BodyType={}));class c{constructor(t,s){var i,o,n,r,c,m,l,h,_,b,u,d,p,y;this.m_type=a.b2_staticBody,this.m_islandFlag=!1,this.m_awakeFlag=!1,this.m_autoSleepFlag=!1,this.m_bulletFlag=!1,this.m_fixedRotationFlag=!1,this.m_enabledFlag=!1,this.m_toiFlag=!1,this.m_islandIndex=0,this.m_xf=new e.b2Transform,this.m_sweep=new e.b2Sweep,this.m_linearVelocity=new e.b2Vec2,this.m_angularVelocity=0,this.m_force=new e.b2Vec2,this.m_torque=0,this.m_prev=null,this.m_next=null,this.m_fixtureList=null,this.m_fixtureCount=0,this.m_jointList=null,this.m_contactList=null,this.m_mass=1,this.m_invMass=1,this.m_I=0,this.m_invI=0,this.m_linearDamping=0,this.m_angularDamping=0,this.m_gravityScale=1,this.m_sleepTime=0,this.m_userData=null,this.m_bulletFlag=null!==(i=t.bullet)&&void 0!==i&&i,this.m_fixedRotationFlag=null!==(o=t.fixedRotation)&&void 0!==o&&o,this.m_autoSleepFlag=null===(n=t.allowSleep)||void 0===n||n,null!==(r=t.awake)&&void 0!==r&&!r||(null!==(c=t.type)&&void 0!==c?c:a.b2_staticBody)===a.b2_staticBody||(this.m_awakeFlag=!0),this.m_enabledFlag=null===(m=t.enabled)||void 0===m||m,this.m_world=s,this.m_xf.p.Copy(null!==(l=t.position)&&void 0!==l?l:e.b2Vec2.ZERO),this.m_xf.q.Set(null!==(h=t.angle)&&void 0!==h?h:0),this.m_sweep.localCenter.SetZero(),this.m_sweep.c0.Copy(this.m_xf.p),this.m_sweep.c.Copy(this.m_xf.p),this.m_sweep.a0=this.m_sweep.a=this.m_xf.q.GetAngle(),this.m_sweep.alpha0=0,this.m_linearVelocity.Copy(null!==(_=t.linearVelocity)&&void 0!==_?_:e.b2Vec2.ZERO),this.m_angularVelocity=null!==(b=t.angularVelocity)&&void 0!==b?b:0,this.m_linearDamping=null!==(u=t.linearDamping)&&void 0!==u?u:0,this.m_angularDamping=null!==(d=t.angularDamping)&&void 0!==d?d:0,this.m_gravityScale=null!==(p=t.gravityScale)&&void 0!==p?p:1,this.m_force.SetZero(),this.m_torque=0,this.m_sleepTime=0,this.m_type=null!==(y=t.type)&&void 0!==y?y:a.b2_staticBody,this.m_mass=0,this.m_invMass=0,this.m_I=0,this.m_invI=0,this.m_userData=t.userData,this.m_fixtureList=null,this.m_fixtureCount=0}CreateFixture(t){(0,r.b2Assert)(!this.m_world.IsLocked());const e=new n.b2Fixture(this,t);if(this.m_enabledFlag){const t=this.m_world.m_contactManager.m_broadPhase;e.CreateProxies(t,this.m_xf)}return e.m_next=this.m_fixtureList,this.m_fixtureList=e,++this.m_fixtureCount,e.m_density>0&&this.ResetMassData(),this.m_world.m_newContacts=!0,e}DestroyFixture(t){(0,r.b2Assert)(!this.m_world.IsLocked());let e=this.m_fixtureList,s=null;for(;null!==e;){if(e===t){s?s.m_next=t.m_next:this.m_fixtureList=t.m_next;break}s=e,e=e.m_next}let i=this.m_contactList;for(;i;){const e=i.contact;i=i.next;const s=e.GetFixtureA(),o=e.GetFixtureB();t!==s&&t!==o||this.m_world.m_contactManager.Destroy(e)}if(this.m_enabledFlag){const e=this.m_world.m_contactManager.m_broadPhase;t.DestroyProxies(e)}t.m_next=null,--this.m_fixtureCount,this.ResetMassData()}SetTransformVec(t,e){this.SetTransformXY(t.x,t.y,e)}SetTransformXY(t,s,i){(0,r.b2Assert)(!this.m_world.IsLocked()),this.m_xf.q.Set(i),this.m_xf.p.Set(t,s),e.b2Transform.MultiplyVec2(this.m_xf,this.m_sweep.localCenter,this.m_sweep.c),this.m_sweep.a=i,this.m_sweep.c0.Copy(this.m_sweep.c),this.m_sweep.a0=i;const o=this.m_world.m_contactManager.m_broadPhase;for(let t=this.m_fixtureList;t;t=t.m_next)t.Synchronize(o,this.m_xf,this.m_xf);this.m_world.m_newContacts=!0}SetTransform(t){this.SetTransformVec(t.p,t.GetAngle())}GetTransform(){return this.m_xf}GetPosition(){return this.m_xf.p}GetAngle(){return this.m_sweep.a}SetAngle(t){this.SetTransformVec(this.GetPosition(),t)}GetWorldCenter(){return this.m_sweep.c}GetLocalCenter(){return this.m_sweep.localCenter}SetLinearVelocity(t){this.m_type!==a.b2_staticBody&&(e.b2Vec2.Dot(t,t)>0&&this.SetAwake(!0),this.m_linearVelocity.Copy(t))}GetLinearVelocity(){return this.m_linearVelocity}SetAngularVelocity(t){this.m_type!==a.b2_staticBody&&(t*t>0&&this.SetAwake(!0),this.m_angularVelocity=t)}GetAngularVelocity(){return this.m_angularVelocity}ApplyForce(t,e,s=!0){this.m_type===a.b2_dynamicBody&&(s&&!this.m_awakeFlag&&this.SetAwake(!0),this.m_awakeFlag&&(this.m_force.x+=t.x,this.m_force.y+=t.y,this.m_torque+=(e.x-this.m_sweep.c.x)*t.y-(e.y-this.m_sweep.c.y)*t.x))}ApplyForceToCenter(t,e=!0){this.m_type===a.b2_dynamicBody&&(e&&!this.m_awakeFlag&&this.SetAwake(!0),this.m_awakeFlag&&(this.m_force.x+=t.x,this.m_force.y+=t.y))}ApplyTorque(t,e=!0){this.m_type===a.b2_dynamicBody&&(e&&!this.m_awakeFlag&&this.SetAwake(!0),this.m_awakeFlag&&(this.m_torque+=t))}ApplyLinearImpulse(t,e,s=!0){this.m_type===a.b2_dynamicBody&&(s&&!this.m_awakeFlag&&this.SetAwake(!0),this.m_awakeFlag&&(this.m_linearVelocity.x+=this.m_invMass*t.x,this.m_linearVelocity.y+=this.m_invMass*t.y,this.m_angularVelocity+=this.m_invI*((e.x-this.m_sweep.c.x)*t.y-(e.y-this.m_sweep.c.y)*t.x)))}ApplyLinearImpulseToCenter(t,e=!0){this.m_type===a.b2_dynamicBody&&(e&&!this.m_awakeFlag&&this.SetAwake(!0),this.m_awakeFlag&&(this.m_linearVelocity.x+=this.m_invMass*t.x,this.m_linearVelocity.y+=this.m_invMass*t.y))}ApplyAngularImpulse(t,e=!0){this.m_type===a.b2_dynamicBody&&(e&&!this.m_awakeFlag&&this.SetAwake(!0),this.m_awakeFlag&&(this.m_angularVelocity+=this.m_invI*t))}GetMass(){return this.m_mass}GetInertia(){return this.m_I+this.m_mass*e.b2Vec2.Dot(this.m_sweep.localCenter,this.m_sweep.localCenter)}GetMassData(t){return t.mass=this.m_mass,t.I=this.m_I+this.m_mass*e.b2Vec2.Dot(this.m_sweep.localCenter,this.m_sweep.localCenter),t.center.Copy(this.m_sweep.localCenter),t}SetMassData(t){if((0,r.b2Assert)(!this.m_world.IsLocked()),this.m_type!==a.b2_dynamicBody)return;this.m_invMass=0,this.m_I=0,this.m_invI=0,this.m_mass=t.mass,this.m_mass<=0&&(this.m_mass=1),this.m_invMass=1/this.m_mass,t.I>0&&!this.m_fixedRotationFlag&&(this.m_I=t.I-this.m_mass*e.b2Vec2.Dot(t.center,t.center),this.m_invI=1/this.m_I);const s=c.SetMassData_s_oldCenter.Copy(this.m_sweep.c);this.m_sweep.localCenter.Copy(t.center),e.b2Transform.MultiplyVec2(this.m_xf,this.m_sweep.localCenter,this.m_sweep.c),this.m_sweep.c0.Copy(this.m_sweep.c),e.b2Vec2.AddCrossScalarVec2(this.m_linearVelocity,this.m_angularVelocity,e.b2Vec2.Subtract(this.m_sweep.c,s,e.b2Vec2.s_t0),this.m_linearVelocity)}ResetMassData(){if(this.m_mass=0,this.m_invMass=0,this.m_I=0,this.m_invI=0,this.m_sweep.localCenter.SetZero(),this.m_type===a.b2_staticBody||this.m_type===a.b2_kinematicBody)return this.m_sweep.c0.Copy(this.m_xf.p),this.m_sweep.c.Copy(this.m_xf.p),void(this.m_sweep.a0=this.m_sweep.a);const t=c.ResetMassData_s_localCenter.SetZero();for(let e=this.m_fixtureList;e;e=e.m_next){if(0===e.m_density)continue;const s=e.GetMassData(c.ResetMassData_s_massData);this.m_mass+=s.mass,t.AddScaled(s.mass,s.center),this.m_I+=s.I}this.m_mass>0&&(this.m_invMass=1/this.m_mass,t.Scale(this.m_invMass)),this.m_I>0&&!this.m_fixedRotationFlag?(this.m_I-=this.m_mass*e.b2Vec2.Dot(t,t),this.m_invI=1/this.m_I):(this.m_I=0,this.m_invI=0);const s=c.ResetMassData_s_oldCenter.Copy(this.m_sweep.c);this.m_sweep.localCenter.Copy(t),e.b2Transform.MultiplyVec2(this.m_xf,this.m_sweep.localCenter,this.m_sweep.c),this.m_sweep.c0.Copy(this.m_sweep.c),e.b2Vec2.AddCrossScalarVec2(this.m_linearVelocity,this.m_angularVelocity,e.b2Vec2.Subtract(this.m_sweep.c,s,e.b2Vec2.s_t0),this.m_linearVelocity)}GetWorldPoint(t,s){return e.b2Transform.MultiplyVec2(this.m_xf,t,s)}GetWorldVector(t,s){return e.b2Rot.MultiplyVec2(this.m_xf.q,t,s)}GetLocalPoint(t,s){return e.b2Transform.TransposeMultiplyVec2(this.m_xf,t,s)}GetLocalVector(t,s){return e.b2Rot.TransposeMultiplyVec2(this.m_xf.q,t,s)}GetLinearVelocityFromWorldPoint(t,s){return e.b2Vec2.AddCrossScalarVec2(this.m_linearVelocity,this.m_angularVelocity,e.b2Vec2.Subtract(t,this.m_sweep.c,e.b2Vec2.s_t0),s)}GetLinearVelocityFromLocalPoint(t,e){return this.GetLinearVelocityFromWorldPoint(this.GetWorldPoint(t,e),e)}GetLinearDamping(){return this.m_linearDamping}SetLinearDamping(t){this.m_linearDamping=t}GetAngularDamping(){return this.m_angularDamping}SetAngularDamping(t){this.m_angularDamping=t}GetGravityScale(){return this.m_gravityScale}SetGravityScale(t){this.m_gravityScale=t}SetType(t){if((0,r.b2Assert)(!this.m_world.IsLocked()),this.m_type===t)return;this.m_type=t,this.ResetMassData(),this.m_type===a.b2_staticBody&&(this.m_linearVelocity.SetZero(),this.m_angularVelocity=0,this.m_sweep.a0=this.m_sweep.a,this.m_sweep.c0.Copy(this.m_sweep.c),this.m_awakeFlag=!1,this.SynchronizeFixtures()),this.SetAwake(!0),this.m_force.SetZero(),this.m_torque=0;let e=this.m_contactList;for(;e;){const t=e;e=e.next,this.m_world.m_contactManager.Destroy(t.contact)}this.m_contactList=null;const s=this.m_world.m_contactManager.m_broadPhase;for(let t=this.m_fixtureList;t;t=t.m_next)for(const e of t.m_proxies)s.TouchProxy(e.treeNode)}GetType(){return this.m_type}SetBullet(t){this.m_bulletFlag=t}IsBullet(){return this.m_bulletFlag}SetSleepingAllowed(t){this.m_autoSleepFlag=t,t||this.SetAwake(!0)}IsSleepingAllowed(){return this.m_autoSleepFlag}SetAwake(t){this.m_type!==a.b2_staticBody&&(t?(this.m_awakeFlag=!0,this.m_sleepTime=0):(this.m_awakeFlag=!1,this.m_sleepTime=0,this.m_linearVelocity.SetZero(),this.m_angularVelocity=0,this.m_force.SetZero(),this.m_torque=0))}IsAwake(){return this.m_awakeFlag}SetEnabled(t){if((0,r.b2Assert)(!this.m_world.IsLocked()),t===this.IsEnabled())return;this.m_enabledFlag=t;const e=this.m_world.m_contactManager.m_broadPhase;if(t){for(let t=this.m_fixtureList;t;t=t.m_next)t.CreateProxies(e,this.m_xf);this.m_world.m_newContacts=!0}else{for(let t=this.m_fixtureList;t;t=t.m_next)t.DestroyProxies(e);let t=this.m_contactList;for(;t;){const e=t;t=t.next,this.m_world.m_contactManager.Destroy(e.contact)}this.m_contactList=null}}IsEnabled(){return this.m_enabledFlag}SetFixedRotation(t){this.m_fixedRotationFlag!==t&&(this.m_fixedRotationFlag=t,this.m_angularVelocity=0,this.ResetMassData())}IsFixedRotation(){return this.m_fixedRotationFlag}GetFixtureList(){return this.m_fixtureList}GetJointList(){return this.m_jointList}GetContactList(){return this.m_contactList}GetNext(){return this.m_next}GetUserData(){return this.m_userData}SetUserData(t){this.m_userData=t}GetWorld(){return this.m_world}SynchronizeFixtures(){const t=this.m_world.m_contactManager.m_broadPhase;if(this.m_awakeFlag){const s=c.SynchronizeFixtures_s_xf1;s.q.Set(this.m_sweep.a0),e.b2Rot.MultiplyVec2(s.q,this.m_sweep.localCenter,s.p),e.b2Vec2.Subtract(this.m_sweep.c0,s.p,s.p);for(let e=this.m_fixtureList;e;e=e.m_next)e.Synchronize(t,s,this.m_xf)}else for(let e=this.m_fixtureList;e;e=e.m_next)e.Synchronize(t,this.m_xf,this.m_xf)}SynchronizeTransform(){this.m_xf.q.Set(this.m_sweep.a),e.b2Rot.MultiplyVec2(this.m_xf.q,this.m_sweep.localCenter,this.m_xf.p),e.b2Vec2.Subtract(this.m_sweep.c,this.m_xf.p,this.m_xf.p)}ShouldCollide(t){return(this.m_type===a.b2_dynamicBody||t.m_type===a.b2_dynamicBody)&&this.ShouldCollideConnected(t)}ShouldCollideConnected(t){for(let e=this.m_jointList;e;e=e.next)if(e.other===t&&!e.joint.m_collideConnected)return!1;return!0}Advance(t){this.m_sweep.Advance(t),this.m_sweep.c.Copy(this.m_sweep.c0),this.m_sweep.a=this.m_sweep.a0,this.m_xf.q.Set(this.m_sweep.a),e.b2Rot.MultiplyVec2(this.m_xf.q,this.m_sweep.localCenter,this.m_xf.p),e.b2Vec2.Subtract(this.m_sweep.c,this.m_xf.p,this.m_xf.p)}}t.b2Body=c,c.SetMassData_s_oldCenter=new e.b2Vec2,c.ResetMassData_s_localCenter=new e.b2Vec2,c.ResetMassData_s_oldCenter=new e.b2Vec2,c.ResetMassData_s_massData=new i.b2MassData,c.SynchronizeFixtures_s_xf1=new e.b2Transform}(c),Object.defineProperty(a,"__esModule",{value:!0}),a.DrawCenterOfMasses=a.DrawAABBs=a.DrawPairs=a.DrawJoints=a.DrawShapes=a.GetShapeColor=void 0;const b=o,u=n,d=c,p=s,y={cA:new b.b2Vec2,cB:new b.b2Vec2,vs:(0,p.b2MakeArray)(4,b.b2Vec2),xf:new b.b2Transform};function A(t){return t.GetType()===d.b2BodyType.b2_dynamicBody&&0===t.m_mass?u.debugColors.badBody:t.IsEnabled()?t.GetType()===d.b2BodyType.b2_staticBody?u.debugColors.staticBody:t.GetType()===d.b2BodyType.b2_kinematicBody?u.debugColors.kinematicBody:t.IsAwake()?u.debugColors.body:u.debugColors.sleepingBody:u.debugColors.disabledBody}function x(t,e){for(let s=0;s<t.m_proxyCount;s++)if(e.TestOverlap(t.GetAABB(s)))return!0;return!1}a.GetShapeColor=A,a.DrawShapes=function(t,e,s){for(let i=e.GetBodyList();i;i=i.m_next){const e=i.m_xf;t.PushTransform(e);for(let e=i.GetFixtureList();e;e=e.m_next)s&&!x(e,s)||e.GetShape().Draw(t,A(i));t.PopTransform(e)}},a.DrawJoints=function(t,e){for(let s=e.GetJointList();s;s=s.m_next)s.Draw(t)},a.DrawPairs=function(t,e){for(let s=e.GetContactList();s;s=s.m_next){const e=s.GetFixtureA(),i=s.GetFixtureB(),o=s.GetChildIndexA(),n=s.GetChildIndexB(),r=e.GetAABB(o).GetCenter(y.cA),a=i.GetAABB(n).GetCenter(y.cB);t.DrawSegment(r,a,u.debugColors.pair)}},a.DrawAABBs=function(t,e,s){const{vs:i}=y;for(let o=e.GetBodyList();o;o=o.m_next)if(o.IsEnabled())for(let e=o.GetFixtureList();e;e=e.m_next)for(let o=0;o<e.m_proxyCount;++o){const{aabb:n}=e.m_proxies[o].treeNode;s&&!s.TestOverlap(n)||(i[0].Set(n.lowerBound.x,n.lowerBound.y),i[1].Set(n.upperBound.x,n.lowerBound.y),i[2].Set(n.upperBound.x,n.upperBound.y),i[3].Set(n.lowerBound.x,n.upperBound.y),t.DrawPolygon(i,4,u.debugColors.aabb))}},a.DrawCenterOfMasses=function(t,e){const{xf:s}=y;for(let i=e.GetBodyList();i;i=i.m_next)s.q.Copy(i.m_xf.q),s.p.Copy(i.GetWorldCenter()),t.DrawTransform(s)};var V={};Object.defineProperty(V,"__esModule",{value:!0}),V.b2Timer=void 0;V.b2Timer=class{constructor(){this.m_start=performance.now()}Reset(){return this.m_start=performance.now(),this}GetMilliseconds(){return performance.now()-this.m_start}};var S={};Object.defineProperty(S,"__esModule",{value:!0}),S.b2_augment=void 0,S.b2_augment=function(t,e){for(const s of Object.keys(e)){const i=e[s],o=t[s],n=function(...t){return i.call(this,o.bind(this),...t)};Object.defineProperty(n,"name",{value:s}),t[s]=n}};var v={},f={};Object.defineProperty(f,"__esModule",{value:!0}),f.b2DynamicTree=f.b2TreeNode=void 0;const C=s,B=o,w=h,g={stack:[],t:new B.b2Vec2,r:new B.b2Vec2,v:new B.b2Vec2,abs_v:new B.b2Vec2,segmentAABB:new w.b2AABB,subInput:new w.b2RayCastInput,combinedAABB:new w.b2AABB,aabb:new w.b2AABB,fatAABB:new w.b2AABB,hugeAABB:new w.b2AABB,c:new B.b2Vec2,h:new B.b2Vec2};let M=0;class I{constructor(){this.aabb=new w.b2AABB,this.userData=null,this.parent=null,this.child1=null,this.child2=null,this.height=0,this.moved=!1,this.id=M++}Reset(){this.child1=null,this.child2=null,this.height=-1,this.userData=null}IsLeaf(){return null===this.child1}GetArea(){if(this.IsLeaf())return 0;let t=this.aabb.GetPerimeter();return this.child1&&(t+=this.child1.GetArea()),this.child2&&(t+=this.child2.GetArea()),t}ComputeHeight(){if(this.IsLeaf())return 0;(0,C.b2Assert)(null!==this.child1&&null!==this.child2);const t=(0,C.b2Verify)(this.child1).ComputeHeight(),e=(0,C.b2Verify)(this.child2).ComputeHeight();return 1+Math.max(t,e)}GetMaxBalance(){if(this.height<=1)return 0;const t=(0,C.b2Verify)(this.child1),e=(0,C.b2Verify)(this.child2);return Math.max(t.GetMaxBalance(),e.GetMaxBalance(),Math.abs(e.height-t.height))}ShiftOrigin(t){this.height<=1||((0,C.b2Verify)(this.child1).ShiftOrigin(t),(0,C.b2Verify)(this.child2).ShiftOrigin(t),this.aabb.lowerBound.Subtract(t),this.aabb.upperBound.Subtract(t))}}f.b2TreeNode=I;f.b2DynamicTree=class{constructor(){this.m_root=null,this.m_freeList=null}Query(t,e){const s=g.stack;s.length=0;let i=this.m_root;for(;i;){if(i.aabb.TestOverlap(t))if(i.IsLeaf()){if(!e(i))return}else s.push(i.child1),s.push(i.child2);i=s.pop()}}QueryPoint(t,e){const s=g.stack;s.length=0;let i=this.m_root;for(;i;){if(i.aabb.TestContain(t))if(i.IsLeaf()){if(!e(i))return}else s.push(i.child1),s.push(i.child2);i=s.pop()}}RayCast(t,e){const{p1:s,p2:i}=t,o=B.b2Vec2.Subtract(i,s,g.r);o.Normalize();const n=B.b2Vec2.CrossOneVec2(o,g.v),r=n.GetAbs(g.abs_v);let{maxFraction:a}=t;const{segmentAABB:c,subInput:m,c:l,h:h,t:_}=g;B.b2Vec2.AddScaled(s,a,B.b2Vec2.Subtract(i,s,_),_),B.b2Vec2.Min(s,_,c.lowerBound),B.b2Vec2.Max(s,_,c.upperBound);const b=g.stack;b.length=0;let u=this.m_root;for(;u;){if(!u.aabb.TestOverlap(c)){u=b.pop();continue}u.aabb.GetCenter(l),u.aabb.GetExtents(h);if(Math.abs(B.b2Vec2.Dot(n,B.b2Vec2.Subtract(s,l,B.b2Vec2.s_t0)))-B.b2Vec2.Dot(r,h)>0)u=b.pop();else{if(u.IsLeaf()){m.p1.Copy(t.p1),m.p2.Copy(t.p2),m.maxFraction=a;const o=e(m,u);if(0===o)return;o>0&&(a=o,B.b2Vec2.AddScaled(s,a,B.b2Vec2.Subtract(i,s,_),_),B.b2Vec2.Min(s,_,c.lowerBound),B.b2Vec2.Max(s,_,c.upperBound))}else b.push(u.child1),b.push(u.child2);u=b.pop()}}}AllocateNode(){if(null===this.m_freeList)return new I;const t=this.m_freeList;return this.m_freeList=t.parent,t.parent=null,t.child1=null,t.child2=null,t.height=0,t.moved=!1,t}FreeNode(t){t.parent=this.m_freeList,t.Reset(),this.m_freeList=t}CreateProxy(t,e){const s=this.AllocateNode(),i=C.b2_aabbExtension;return s.aabb.lowerBound.Set(t.lowerBound.x-i,t.lowerBound.y-i),s.aabb.upperBound.Set(t.upperBound.x+i,t.upperBound.y+i),s.userData=e,s.height=0,s.moved=!0,this.InsertLeaf(s),s}DestroyProxy(t){this.RemoveLeaf(t),this.FreeNode(t)}MoveProxy(t,e,s){const{fatAABB:i,hugeAABB:o}=g,n=C.b2_aabbExtension;i.lowerBound.Set(e.lowerBound.x-n,e.lowerBound.y-n),i.upperBound.Set(e.upperBound.x+n,e.upperBound.y+n);const r=C.b2_aabbMultiplier*s.x,a=C.b2_aabbMultiplier*s.y;r<0?i.lowerBound.x+=r:i.upperBound.x+=r,a<0?i.lowerBound.y+=a:i.upperBound.y+=a;const c=t.aabb;if(c.Contains(e)){const t=4*C.b2_aabbExtension;if(o.lowerBound.Set(i.lowerBound.x-t,e.lowerBound.y-t),o.upperBound.Set(i.upperBound.x+t,e.upperBound.y+t),o.Contains(c))return!1}return this.RemoveLeaf(t),t.aabb.Copy(i),this.InsertLeaf(t),t.moved=!0,!0}InsertLeaf(t){if(null===this.m_root)return this.m_root=t,void(this.m_root.parent=null);const{combinedAABB:e,aabb:s}=g,i=t.aabb;let o=this.m_root;for(;!o.IsLeaf();){const t=(0,C.b2Verify)(o.child1),n=(0,C.b2Verify)(o.child2),r=o.aabb.GetPerimeter();e.Combine2(o.aabb,i);const a=e.GetPerimeter(),c=2*a,m=2*(a-r);let l,h,_,b;if(t.IsLeaf()?(s.Combine2(i,t.aabb),l=s.GetPerimeter()+m):(s.Combine2(i,t.aabb),h=t.aabb.GetPerimeter(),_=s.GetPerimeter(),l=_-h+m),n.IsLeaf()?(s.Combine2(i,n.aabb),b=s.GetPerimeter()+m):(s.Combine2(i,n.aabb),h=n.aabb.GetPerimeter(),_=s.GetPerimeter(),b=_-h+m),c<l&&c<b)break;o=l<b?t:n}const n=o.parent,r=this.AllocateNode();r.parent=n,r.userData=null,r.aabb.Combine2(i,o.aabb),r.height=o.height+1,null!==n?(n.child1===o?n.child1=r:n.child2=r,r.child1=o,r.child2=t,o.parent=r,t.parent=r):(r.child1=o,r.child2=t,o.parent=r,t.parent=r,this.m_root=r);let a=t.parent;for(;null!==a;){a=this.Balance(a);const t=(0,C.b2Verify)(a.child1),e=(0,C.b2Verify)(a.child2);a.height=1+Math.max(t.height,e.height),a.aabb.Combine2(t.aabb,e.aabb),a=a.parent}}RemoveLeaf(t){if(t===this.m_root)return void(this.m_root=null);const e=(0,C.b2Verify)(t.parent),s=e.parent,i=(0,C.b2Verify)(e.child1===t?e.child2:e.child1);if(null!==s){s.child1===e?s.child1=i:s.child2=i,i.parent=s,this.FreeNode(e);let t=s;for(;null!==t;){t=this.Balance(t);const e=(0,C.b2Verify)(t.child1),s=(0,C.b2Verify)(t.child2);t.aabb.Combine2(e.aabb,s.aabb),t.height=1+Math.max(e.height,s.height),t=t.parent}}else this.m_root=i,i.parent=null,this.FreeNode(e)}Balance(t){if(t.IsLeaf()||t.height<2)return t;const e=(0,C.b2Verify)(t.child1),s=(0,C.b2Verify)(t.child2),i=s.height-e.height;if(i>1){const i=(0,C.b2Verify)(s.child1),o=(0,C.b2Verify)(s.child2);return s.child1=t,s.parent=t.parent,t.parent=s,null!==s.parent?s.parent.child1===t?s.parent.child1=s:s.parent.child2=s:this.m_root=s,i.height>o.height?(s.child2=i,t.child2=o,o.parent=t,t.aabb.Combine2(e.aabb,o.aabb),s.aabb.Combine2(t.aabb,i.aabb),t.height=1+Math.max(e.height,o.height),s.height=1+Math.max(t.height,i.height)):(s.child2=o,t.child2=i,i.parent=t,t.aabb.Combine2(e.aabb,i.aabb),s.aabb.Combine2(t.aabb,o.aabb),t.height=1+Math.max(e.height,i.height),s.height=1+Math.max(t.height,o.height)),s}if(i<-1){const i=(0,C.b2Verify)(e.child1),o=(0,C.b2Verify)(e.child2);return e.child1=t,e.parent=t.parent,t.parent=e,null!==e.parent?e.parent.child1===t?e.parent.child1=e:e.parent.child2=e:this.m_root=e,i.height>o.height?(e.child2=i,t.child1=o,o.parent=t,t.aabb.Combine2(s.aabb,o.aabb),e.aabb.Combine2(t.aabb,i.aabb),t.height=1+Math.max(s.height,o.height),e.height=1+Math.max(t.height,i.height)):(e.child2=o,t.child1=i,i.parent=t,t.aabb.Combine2(s.aabb,i.aabb),e.aabb.Combine2(t.aabb,o.aabb),t.height=1+Math.max(s.height,i.height),e.height=1+Math.max(t.height,o.height)),e}return t}GetHeight(){return null===this.m_root?0:this.m_root.height}GetAreaRatio(){if(null===this.m_root)return 0;const t=this.m_root,e=t.aabb.GetPerimeter();return t.GetArea()/e}GetMaxBalance(){return null===this.m_root?0:this.m_root.GetMaxBalance()}ShiftOrigin(t){var e;null===(e=this.m_root)||void 0===e||e.ShiftOrigin(t)}},Object.defineProperty(v,"__esModule",{value:!0}),v.b2BroadPhase=void 0;const T=s,D=f;v.b2BroadPhase=class{constructor(){this.m_tree=new D.b2DynamicTree,this.m_proxyCount=0,this.m_moveCount=0,this.m_moveBuffer=[],this.m_pairCount=0,this.m_pairBuffer=[],this.m_queryProxy=new D.b2TreeNode,this.QueryCallback=t=>(t.id===this.m_queryProxy.id||t.moved&&t.id>this.m_queryProxy.id||(this.m_pairBuffer[this.m_pairCount]=t.id<this.m_queryProxy.id?[t,this.m_queryProxy]:[this.m_queryProxy,t],++this.m_pairCount),!0)}CreateProxy(t,e){const s=this.m_tree.CreateProxy(t,e);return++this.m_proxyCount,this.BufferMove(s),s}DestroyProxy(t){this.UnBufferMove(t),--this.m_proxyCount,this.m_tree.DestroyProxy(t)}MoveProxy(t,e,s){this.m_tree.MoveProxy(t,e,s)&&this.BufferMove(t)}TouchProxy(t){this.BufferMove(t)}GetProxyCount(){return this.m_proxyCount}UpdatePairs(t){this.m_pairCount=0;for(let t=0;t<this.m_moveCount;++t){const e=this.m_moveBuffer[t];if(null===e)continue;this.m_queryProxy=e;const s=e.aabb;this.m_tree.Query(s,this.QueryCallback)}for(let e=0;e<this.m_pairCount;++e){const s=this.m_pairBuffer[e];t((0,T.b2Verify)(s[0].userData),(0,T.b2Verify)(s[1].userData))}for(let t=0;t<this.m_moveCount;++t){const e=this.m_moveBuffer[t];e&&(e.moved=!1)}this.m_moveCount=0}Query(t,e){this.m_tree.Query(t,e)}QueryPoint(t,e){this.m_tree.QueryPoint(t,e)}RayCast(t,e){this.m_tree.RayCast(t,e)}GetTreeHeight(){return this.m_tree.GetHeight()}GetTreeBalance(){return this.m_tree.GetMaxBalance()}GetTreeQuality(){return this.m_tree.GetAreaRatio()}ShiftOrigin(t){this.m_tree.ShiftOrigin(t)}BufferMove(t){this.m_moveBuffer[this.m_moveCount]=t,++this.m_moveCount}UnBufferMove(t){const e=this.m_moveBuffer.indexOf(t);this.m_moveBuffer[e]=null}};var G={};!function(t){Object.defineProperty(t,"__esModule",{value:!0}),t.b2TimeOfImpact=t.b2TOIOutput=t.b2TOIOutputState=t.b2TOIInput=t.b2Toi=void 0;const e=s,n=i,r=o,a=V,c=_;t.b2Toi={time:0,maxTime:0,calls:0,iters:0,maxIters:0,rootIters:0,maxRootIters:0,reset(){this.time=0,this.maxTime=0,this.calls=0,this.iters=0,this.maxIters=0,this.rootIters=0,this.maxRootIters=0}};const m=new r.b2Transform,l=new r.b2Transform,h=new r.b2Vec2,b=new r.b2Vec2,u=new r.b2Vec2,d=new r.b2Vec2,p=new r.b2Vec2;var y,A;t.b2TOIInput=class{constructor(){this.proxyA=new c.b2DistanceProxy,this.proxyB=new c.b2DistanceProxy,this.sweepA=new r.b2Sweep,this.sweepB=new r.b2Sweep,this.tMax=0}},function(t){t[t.e_unknown=0]="e_unknown",t[t.e_failed=1]="e_failed",t[t.e_overlapped=2]="e_overlapped",t[t.e_touching=3]="e_touching",t[t.e_separated=4]="e_separated"}(y=t.b2TOIOutputState||(t.b2TOIOutputState={}));t.b2TOIOutput=class{constructor(){this.state=y.e_unknown,this.t=0}},function(t){t[t.e_points=0]="e_points",t[t.e_faceA=1]="e_faceA",t[t.e_faceB=2]="e_faceB"}(A||(A={}));const x=new a.b2Timer,S=new c.b2SimplexCache,v=new c.b2DistanceInput,f=new c.b2DistanceOutput,C=new class{constructor(){this.m_sweepA=new r.b2Sweep,this.m_sweepB=new r.b2Sweep,this.m_type=A.e_points,this.m_localPoint=new r.b2Vec2,this.m_axis=new r.b2Vec2}Initialize(t,e,s,i,o,n){this.m_proxyA=e,this.m_proxyB=i;const{count:a}=t;this.m_sweepA.Copy(s),this.m_sweepB.Copy(o);const c=this.m_sweepA.GetTransform(m,n),_=this.m_sweepB.GetTransform(l,n);if(1===a){this.m_type=A.e_points;const e=this.m_proxyA.GetVertex(t.indexA[0]),s=this.m_proxyB.GetVertex(t.indexB[0]),i=r.b2Transform.MultiplyVec2(c,e,h),o=r.b2Transform.MultiplyVec2(_,s,b);r.b2Vec2.Subtract(o,i,this.m_axis);return this.m_axis.Normalize()}if(t.indexA[0]===t.indexA[1]){this.m_type=A.e_faceB;const e=this.m_proxyB.GetVertex(t.indexB[0]),s=this.m_proxyB.GetVertex(t.indexB[1]);r.b2Vec2.CrossVec2One(r.b2Vec2.Subtract(s,e,r.b2Vec2.s_t0),this.m_axis).Normalize();const i=r.b2Rot.MultiplyVec2(_.q,this.m_axis,u);r.b2Vec2.Mid(e,s,this.m_localPoint);const o=r.b2Transform.MultiplyVec2(_,this.m_localPoint,b),n=this.m_proxyA.GetVertex(t.indexA[0]),a=r.b2Transform.MultiplyVec2(c,n,h);let m=r.b2Vec2.Dot(r.b2Vec2.Subtract(a,o,r.b2Vec2.s_t0),i);return m<0&&(this.m_axis.Negate(),m=-m),m}this.m_type=A.e_faceA;const d=this.m_proxyA.GetVertex(t.indexA[0]),p=this.m_proxyA.GetVertex(t.indexA[1]);r.b2Vec2.CrossVec2One(r.b2Vec2.Subtract(p,d,r.b2Vec2.s_t0),this.m_axis).Normalize();const y=r.b2Rot.MultiplyVec2(c.q,this.m_axis,u);r.b2Vec2.Mid(d,p,this.m_localPoint);const x=r.b2Transform.MultiplyVec2(c,this.m_localPoint,h),V=this.m_proxyB.GetVertex(t.indexB[0]),S=r.b2Transform.MultiplyVec2(_,V,b);let v=r.b2Vec2.Dot(r.b2Vec2.Subtract(S,x,r.b2Vec2.s_t0),y);return v<0&&(this.m_axis.Negate(),v=-v),v}FindMinSeparation(t,e,s){const i=this.m_sweepA.GetTransform(m,s),o=this.m_sweepB.GetTransform(l,s);switch(this.m_type){case A.e_points:{const s=r.b2Rot.TransposeMultiplyVec2(i.q,this.m_axis,d),n=r.b2Rot.TransposeMultiplyVec2(o.q,r.b2Vec2.Negate(this.m_axis,r.b2Vec2.s_t0),p);t[0]=this.m_proxyA.GetSupport(s),e[0]=this.m_proxyB.GetSupport(n);const a=this.m_proxyA.GetVertex(t[0]),c=this.m_proxyB.GetVertex(e[0]),m=r.b2Transform.MultiplyVec2(i,a,h),l=r.b2Transform.MultiplyVec2(o,c,b);return r.b2Vec2.Dot(r.b2Vec2.Subtract(l,m,r.b2Vec2.s_t0),this.m_axis)}case A.e_faceA:{const s=r.b2Rot.MultiplyVec2(i.q,this.m_axis,u),n=r.b2Transform.MultiplyVec2(i,this.m_localPoint,h),a=r.b2Rot.TransposeMultiplyVec2(o.q,r.b2Vec2.Negate(s,r.b2Vec2.s_t0),p);t[0]=-1,e[0]=this.m_proxyB.GetSupport(a);const c=this.m_proxyB.GetVertex(e[0]),m=r.b2Transform.MultiplyVec2(o,c,b);return r.b2Vec2.Dot(r.b2Vec2.Subtract(m,n,r.b2Vec2.s_t0),s)}case A.e_faceB:{const s=r.b2Rot.MultiplyVec2(o.q,this.m_axis,u),n=r.b2Transform.MultiplyVec2(o,this.m_localPoint,b),a=r.b2Rot.TransposeMultiplyVec2(i.q,r.b2Vec2.Negate(s,r.b2Vec2.s_t0),d);e[0]=-1,t[0]=this.m_proxyA.GetSupport(a);const c=this.m_proxyA.GetVertex(t[0]),m=r.b2Transform.MultiplyVec2(i,c,h);return r.b2Vec2.Dot(r.b2Vec2.Subtract(m,n,r.b2Vec2.s_t0),s)}default:return t[0]=-1,e[0]=-1,0}}Evaluate(t,s,i){const o=this.m_sweepA.GetTransform(m,i),n=this.m_sweepB.GetTransform(l,i);switch(this.m_type){case A.e_points:{const e=this.m_proxyA.GetVertex(t),i=this.m_proxyB.GetVertex(s),a=r.b2Transform.MultiplyVec2(o,e,h),c=r.b2Transform.MultiplyVec2(n,i,b);return r.b2Vec2.Dot(r.b2Vec2.Subtract(c,a,r.b2Vec2.s_t0),this.m_axis)}case A.e_faceA:{const t=r.b2Rot.MultiplyVec2(o.q,this.m_axis,u),e=r.b2Transform.MultiplyVec2(o,this.m_localPoint,h),i=this.m_proxyB.GetVertex(s),a=r.b2Transform.MultiplyVec2(n,i,b);return r.b2Vec2.Dot(r.b2Vec2.Subtract(a,e,r.b2Vec2.s_t0),t)}case A.e_faceB:{const e=r.b2Rot.MultiplyVec2(n.q,this.m_axis,u),s=r.b2Transform.MultiplyVec2(n,this.m_localPoint,b),i=this.m_proxyA.GetVertex(t),a=r.b2Transform.MultiplyVec2(o,i,h);return r.b2Vec2.Dot(r.b2Vec2.Subtract(a,s,r.b2Vec2.s_t0),e)}default:return(0,e.b2Assert)(!1),0}}},B=[0],w=[0],g=new r.b2Sweep,M=new r.b2Sweep;t.b2TimeOfImpact=function(s,i){const o=x.Reset();++t.b2Toi.calls,s.state=y.e_unknown,s.t=i.tMax;const{proxyA:r,proxyB:a,tMax:h}=i,_=Math.max(n.b2_maxPolygonVertices,r.m_count,a.m_count),b=g.Copy(i.sweepA),u=M.Copy(i.sweepB);b.Normalize(),u.Normalize();const d=r.m_radius+a.m_radius,p=Math.max(e.b2_linearSlop,d-3*e.b2_linearSlop),A=.25*e.b2_linearSlop;let V=0,I=0;const T=S;T.count=0;const D=v;for(D.proxyA.Copy(i.proxyA),D.proxyB.Copy(i.proxyB),D.useRadii=!1;;){const e=b.GetTransform(m,V),i=u.GetTransform(l,V);D.transformA.Copy(e),D.transformB.Copy(i);const o=f;if((0,c.b2Distance)(o,T,D),o.distance<=0){s.state=y.e_overlapped,s.t=0;break}if(o.distance<p+A){s.state=y.e_touching,s.t=V;break}const n=C;n.Initialize(T,r,b,a,u,V);let d=!1,x=h,S=0;for(;;){const e=B,i=w;let o=n.FindMinSeparation(e,i,x);if(o>p+A){s.state=y.e_separated,s.t=h,d=!0;break}if(o>p-A){V=x;break}let r=n.Evaluate(e[0],i[0],V);if(r<p-A){s.state=y.e_failed,s.t=V,d=!0;break}if(r<=p+A){s.state=y.e_touching,s.t=V,d=!0;break}let a=0,c=V,m=x;for(;;){let s;s=1&a?c+(p-r)*(m-c)/(o-r):.5*(c+m),++a,++t.b2Toi.rootIters;const l=n.Evaluate(e[0],i[0],s);if(Math.abs(l-p)<A){x=s;break}if(l>p?(c=s,r=l):(m=s,o=l),50===a)break}if(t.b2Toi.maxRootIters=Math.max(t.b2Toi.maxRootIters,a),++S,S===_)break}if(++I,++t.b2Toi.iters,d)break;if(20===I){s.state=y.e_failed,s.t=V;break}}t.b2Toi.maxIters=Math.max(t.b2Toi.maxIters,I);const G=o.GetMilliseconds();t.b2Toi.maxTime=Math.max(t.b2Toi.maxTime,G),t.b2Toi.time+=G}}(G);var P={};Object.defineProperty(P,"__esModule",{value:!0}),P.b2CollidePolygonAndCircle=P.b2CollideCircles=void 0;const R=s,L=o,F=h,J=new L.b2Vec2,k=new L.b2Vec2;P.b2CollideCircles=function(t,e,s,i,o){t.pointCount=0;const n=L.b2Transform.MultiplyVec2(s,e.m_p,J),r=L.b2Transform.MultiplyVec2(o,i.m_p,k),a=L.b2Vec2.DistanceSquared(n,r),c=e.m_radius+i.m_radius;a>c*c||(t.type=F.b2ManifoldType.e_circles,t.localPoint.Copy(e.m_p),t.localNormal.SetZero(),t.pointCount=1,t.points[0].localPoint.Copy(i.m_p),t.points[0].id.key=0)};const q=new L.b2Vec2,O=new L.b2Vec2,z=new L.b2Vec2;P.b2CollidePolygonAndCircle=function(t,e,s,i,o){t.pointCount=0;const n=L.b2Transform.MultiplyVec2(o,i.m_p,q),r=L.b2Transform.TransposeMultiplyVec2(s,n,O);let a=0,c=-R.b2_maxFloat;const m=e.m_radius+i.m_radius,l=e.m_count,h=e.m_vertices,_=e.m_normals;for(let t=0;t<l;++t){const e=L.b2Vec2.Dot(_[t],L.b2Vec2.Subtract(r,h[t],L.b2Vec2.s_t0));if(e>m)return;e>c&&(c=e,a=t)}const b=a,u=b+1<l?b+1:0,d=h[b],p=h[u];if(c<R.b2_epsilon)return t.pointCount=1,t.type=F.b2ManifoldType.e_faceA,t.localNormal.Copy(_[a]),L.b2Vec2.Mid(d,p,t.localPoint),t.points[0].localPoint.Copy(i.m_p),void(t.points[0].id.key=0);const y=L.b2Vec2.Dot(L.b2Vec2.Subtract(r,d,L.b2Vec2.s_t0),L.b2Vec2.Subtract(p,d,L.b2Vec2.s_t1)),A=L.b2Vec2.Dot(L.b2Vec2.Subtract(r,p,L.b2Vec2.s_t0),L.b2Vec2.Subtract(d,p,L.b2Vec2.s_t1));if(y<=0){if(L.b2Vec2.DistanceSquared(r,d)>m*m)return;t.pointCount=1,t.type=F.b2ManifoldType.e_faceA,L.b2Vec2.Subtract(r,d,t.localNormal).Normalize(),t.localPoint.Copy(d),t.points[0].localPoint.Copy(i.m_p),t.points[0].id.key=0}else if(A<=0){if(L.b2Vec2.DistanceSquared(r,p)>m*m)return;t.pointCount=1,t.type=F.b2ManifoldType.e_faceA,L.b2Vec2.Subtract(r,p,t.localNormal).Normalize(),t.localPoint.Copy(p),t.points[0].localPoint.Copy(i.m_p),t.points[0].id.key=0}else{const e=L.b2Vec2.Mid(d,p,z);if(L.b2Vec2.Dot(L.b2Vec2.Subtract(r,e,L.b2Vec2.s_t1),_[b])>m)return;t.pointCount=1,t.type=F.b2ManifoldType.e_faceA,t.localNormal.Copy(_[b]),t.localPoint.Copy(e),t.points[0].localPoint.Copy(i.m_p),t.points[0].id.key=0}};var j={};Object.defineProperty(j,"__esModule",{value:!0}),j.b2CollidePolygons=void 0;const N=s,E=o,Z=h,W=new E.b2Transform,X=new E.b2Vec2,U=new E.b2Vec2;function Q(t,e,s,i,o){const n=e.m_count,r=i.m_count,a=e.m_normals,c=e.m_vertices,m=i.m_vertices,l=E.b2Transform.TransposeMultiply(o,s,W);let h=0,_=-N.b2_maxFloat;for(let t=0;t<n;++t){const e=E.b2Rot.MultiplyVec2(l.q,a[t],X),s=E.b2Transform.MultiplyVec2(l,c[t],U);let i=N.b2_maxFloat;for(let t=0;t<r;++t){const o=E.b2Vec2.Dot(e,E.b2Vec2.Subtract(m[t],s,E.b2Vec2.s_t0));o<i&&(i=o)}i>_&&(_=i,h=t)}return t[0]=h,_}const K=new E.b2Vec2;const H=[new Z.b2ClipVertex,new Z.b2ClipVertex],Y=[new Z.b2ClipVertex,new Z.b2ClipVertex],$=[new Z.b2ClipVertex,new Z.b2ClipVertex],tt=[0],et=[0],st=new E.b2Vec2,it=new E.b2Vec2,ot=new E.b2Vec2,nt=new E.b2Vec2,rt=new E.b2Vec2,at=new E.b2Vec2,ct=new E.b2Vec2,mt=new E.b2Vec2;j.b2CollidePolygons=function(t,e,s,i,o){t.pointCount=0;const n=e.m_radius+i.m_radius,r=tt,a=Q(r,e,s,i,o);if(a>n)return;const c=et,m=Q(c,i,o,e,s);if(m>n)return;let l,h,_,b,u,d;m>a+.1*N.b2_linearSlop?(l=i,h=e,_=o,b=s,u=c[0],t.type=Z.b2ManifoldType.e_faceB,d=1):(l=e,h=i,_=s,b=o,u=r[0],t.type=Z.b2ManifoldType.e_faceA,d=0);const p=H;!function(t,e,s,i,o,n){const r=e.m_normals,a=o.m_count,c=o.m_vertices,m=o.m_normals,l=E.b2Rot.TransposeMultiplyVec2(n.q,E.b2Rot.MultiplyVec2(s.q,r[i],E.b2Vec2.s_t0),K);let h=0,_=N.b2_maxFloat;for(let t=0;t<a;++t){const e=E.b2Vec2.Dot(l,m[t]);e<_&&(_=e,h=t)}const b=h,u=b+1<a?b+1:0,d=t[0];E.b2Transform.MultiplyVec2(n,c[b],d.v);const p=d.id.cf;p.indexA=i,p.indexB=b,p.typeA=Z.b2ContactFeatureType.e_face,p.typeB=Z.b2ContactFeatureType.e_vertex;const y=t[1];E.b2Transform.MultiplyVec2(n,c[u],y.v);const A=y.id.cf;A.indexA=i,A.indexB=u,A.typeA=Z.b2ContactFeatureType.e_face,A.typeB=Z.b2ContactFeatureType.e_vertex}(p,l,_,u,h,b);const y=l.m_count,A=l.m_vertices,x=u,V=u+1<y?u+1:0;let S=A[x],v=A[V];const f=E.b2Vec2.Subtract(v,S,st);f.Normalize();const C=E.b2Vec2.CrossVec2One(f,it),B=E.b2Vec2.Mid(S,v,ot),w=E.b2Rot.MultiplyVec2(_.q,f,rt),g=E.b2Vec2.CrossVec2One(w,nt);S=E.b2Transform.MultiplyVec2(_,S,ct),v=E.b2Transform.MultiplyVec2(_,v,mt);const M=E.b2Vec2.Dot(g,S),I=-E.b2Vec2.Dot(w,S)+n,T=E.b2Vec2.Dot(w,v)+n,D=Y,G=$,P=E.b2Vec2.Negate(w,at);let R=(0,Z.b2ClipSegmentToLine)(D,p,P,I,x);if(R<2)return;if(R=(0,Z.b2ClipSegmentToLine)(G,D,w,T,V),R<2)return;t.localNormal.Copy(C),t.localPoint.Copy(B);let L=0;for(let e=0;e<N.b2_maxManifoldPoints;++e){const s=G[e];if(E.b2Vec2.Dot(g,s.v)-M<=n){const e=t.points[L];if(E.b2Transform.TransposeMultiplyVec2(b,s.v,e.localPoint),e.id.Copy(s.id),d){const{cf:t}=e.id;t.indexA=t.indexB,t.indexB=t.indexA,t.typeA=t.typeB,t.typeB=t.typeA}++L}}t.pointCount=L};var lt={};Object.defineProperty(lt,"__esModule",{value:!0}),lt.b2CollideEdgeAndPolygon=lt.b2CollideEdgeAndCircle=void 0;const ht=s,_t=o,bt=h,ut=i,dt=new _t.b2Vec2,pt=new _t.b2Vec2,yt=new _t.b2Vec2,At=new _t.b2Vec2,xt=new _t.b2Vec2,Vt=new _t.b2Vec2,St=new _t.b2Vec2,vt=new bt.b2ContactID;var ft;lt.b2CollideEdgeAndCircle=function(t,e,s,i,o){t.pointCount=0;const n=_t.b2Transform.TransposeMultiplyVec2(s,_t.b2Transform.MultiplyVec2(o,i.m_p,_t.b2Vec2.s_t0),dt),r=e.m_vertex1,a=e.m_vertex2,c=_t.b2Vec2.Subtract(a,r,pt),m=St.Set(c.y,-c.x),l=_t.b2Vec2.Dot(m,_t.b2Vec2.Subtract(n,r,_t.b2Vec2.s_t0));if(e.m_oneSided&&l<0)return;const h=_t.b2Vec2.Dot(c,_t.b2Vec2.Subtract(a,n,_t.b2Vec2.s_t0)),_=_t.b2Vec2.Dot(c,_t.b2Vec2.Subtract(n,r,_t.b2Vec2.s_t0)),b=e.m_radius+i.m_radius,u=vt;if(u.cf.indexB=0,u.cf.typeB=bt.b2ContactFeatureType.e_vertex,_<=0){const s=r,o=_t.b2Vec2.Subtract(n,s,yt);if(_t.b2Vec2.Dot(o,o)>b*b)return;if(e.m_oneSided){const t=e.m_vertex0,s=r,i=_t.b2Vec2.Subtract(s,t,At);if(_t.b2Vec2.Dot(i,_t.b2Vec2.Subtract(s,n,_t.b2Vec2.s_t0))>0)return}return u.cf.indexA=0,u.cf.typeA=bt.b2ContactFeatureType.e_vertex,t.pointCount=1,t.type=bt.b2ManifoldType.e_circles,t.localNormal.SetZero(),t.localPoint.Copy(s),t.points[0].id.Copy(u),void t.points[0].localPoint.Copy(i.m_p)}if(h<=0){const s=a,o=_t.b2Vec2.Subtract(n,s,yt);if(_t.b2Vec2.Dot(o,o)>b*b)return;if(e.m_oneSided){const t=e.m_vertex3,s=a,i=_t.b2Vec2.Subtract(t,s,xt);if(_t.b2Vec2.Dot(i,_t.b2Vec2.Subtract(n,s,_t.b2Vec2.s_t0))>0)return}return u.cf.indexA=1,u.cf.typeA=bt.b2ContactFeatureType.e_vertex,t.pointCount=1,t.type=bt.b2ManifoldType.e_circles,t.localNormal.SetZero(),t.localPoint.Copy(s),t.points[0].id.Copy(u),void t.points[0].localPoint.Copy(i.m_p)}const d=_t.b2Vec2.Dot(c,c),p=Vt;p.x=1/d*(h*r.x+_*a.x),p.y=1/d*(h*r.y+_*a.y);const y=_t.b2Vec2.Subtract(n,p,yt);_t.b2Vec2.Dot(y,y)>b*b||(l<0&&m.Set(-m.x,-m.y),m.Normalize(),u.cf.indexA=0,u.cf.typeA=bt.b2ContactFeatureType.e_face,t.pointCount=1,t.type=bt.b2ManifoldType.e_faceA,t.localNormal.Copy(m),t.localPoint.Copy(r),t.points[0].id.Copy(u),t.points[0].localPoint.Copy(i.m_p))},function(t){t[t.e_unknown=0]="e_unknown",t[t.e_edgeA=1]="e_edgeA",t[t.e_edgeB=2]="e_edgeB"}(ft||(ft={}));class Ct{constructor(){this.normal=new _t.b2Vec2,this.type=ft.e_unknown,this.index=0,this.separation=0}}const Bt=new Ct,wt=[new _t.b2Vec2,new _t.b2Vec2];const gt=new Ct,Mt=new _t.b2Vec2;const It=new _t.b2Transform,Tt=new _t.b2Vec2,Dt=new _t.b2Vec2,Gt=new _t.b2Vec2,Pt=new _t.b2Vec2,Rt=new _t.b2Vec2,Lt=new _t.b2Vec2,Ft=new _t.b2Vec2,Jt=new class{constructor(){this.vertices=(0,ht.b2MakeArray)(ut.b2_maxPolygonVertices,_t.b2Vec2),this.normals=(0,ht.b2MakeArray)(ut.b2_maxPolygonVertices,_t.b2Vec2),this.count=0}},kt=new class{constructor(){this.i1=0,this.i2=0,this.v1=new _t.b2Vec2,this.v2=new _t.b2Vec2,this.normal=new _t.b2Vec2,this.sideNormal1=new _t.b2Vec2,this.sideOffset1=0,this.sideNormal2=new _t.b2Vec2,this.sideOffset2=0}},qt=[new bt.b2ClipVertex,new bt.b2ClipVertex],Ot=[new bt.b2ClipVertex,new bt.b2ClipVertex],zt=[new bt.b2ClipVertex,new bt.b2ClipVertex];lt.b2CollideEdgeAndPolygon=function(t,e,s,i,o){t.pointCount=0;const n=_t.b2Transform.TransposeMultiply(s,o,It),r=_t.b2Transform.MultiplyVec2(n,i.m_centroid,Tt),a=e.m_vertex1,c=e.m_vertex2,m=_t.b2Vec2.Subtract(c,a,Dt);m.Normalize();const l=Gt.Set(m.y,-m.x),h=_t.b2Vec2.Dot(l,_t.b2Vec2.Subtract(r,a,_t.b2Vec2.s_t0)),_=e.m_oneSided;if(_&&h<0)return;const b=Jt;b.count=i.m_count;for(let t=0;t<i.m_count;++t)_t.b2Transform.MultiplyVec2(n,i.m_vertices[t],b.vertices[t]),_t.b2Rot.MultiplyVec2(n.q,i.m_normals[t],b.normals[t]);const u=i.m_radius+e.m_radius,d=function(t,e,s){const i=Bt;i.type=ft.e_edgeA,i.index=-1,i.separation=-ht.b2_maxFloat,i.normal.SetZero();const o=wt;o[0].Copy(s),_t.b2Vec2.Negate(s,o[1]);for(let s=0;s<2;++s){let n=ht.b2_maxFloat;for(let i=0;i<t.count;++i){const r=_t.b2Vec2.Dot(o[s],_t.b2Vec2.Subtract(t.vertices[i],e,_t.b2Vec2.s_t0));r<n&&(n=r)}n>i.separation&&(i.index=s,i.separation=n,i.normal.Copy(o[s]))}return i}(b,a,l);if(d.separation>u)return;const p=function(t,e,s){const i=gt;i.type=ft.e_unknown,i.index=-1,i.separation=-ht.b2_maxFloat,i.normal.SetZero();for(let o=0;o<t.count;++o){const n=_t.b2Vec2.Negate(t.normals[o],Mt),r=_t.b2Vec2.Dot(n,_t.b2Vec2.Subtract(t.vertices[o],e,_t.b2Vec2.s_t0)),a=_t.b2Vec2.Dot(n,_t.b2Vec2.Subtract(t.vertices[o],s,_t.b2Vec2.s_t0)),c=Math.min(r,a);c>i.separation&&(i.type=ft.e_edgeB,i.index=o,i.separation=c,i.normal.Copy(n))}return i}(b,a,c);if(p.separation>u)return;let y;if(y=p.separation-u>.98*(d.separation-u)+.001?p:d,_){const t=_t.b2Vec2.Subtract(a,e.m_vertex0,Pt);t.Normalize();const s=Rt.Set(t.y,-t.x),i=_t.b2Vec2.Cross(t,m)>=0,o=_t.b2Vec2.Subtract(e.m_vertex3,c,Lt);o.Normalize();const n=Ft.Set(o.y,-o.x),r=_t.b2Vec2.Cross(m,o)>=0,l=.1;if(_t.b2Vec2.Dot(y.normal,m)<=0)if(i){if(_t.b2Vec2.Cross(y.normal,s)>l)return}else y=d;else if(r){if(_t.b2Vec2.Cross(n,y.normal)>l)return}else y=d}const A=qt,x=kt;if(y.type===ft.e_edgeA){t.type=bt.b2ManifoldType.e_faceA;let e=0,s=_t.b2Vec2.Dot(y.normal,b.normals[0]);for(let t=1;t<b.count;++t){const i=_t.b2Vec2.Dot(y.normal,b.normals[t]);i<s&&(s=i,e=t)}const i=e,o=i+1<b.count?i+1:0;A[0].v.Copy(b.vertices[i]),A[0].id.cf.indexA=0,A[0].id.cf.indexB=i,A[0].id.cf.typeA=bt.b2ContactFeatureType.e_face,A[0].id.cf.typeB=bt.b2ContactFeatureType.e_vertex,A[1].v.Copy(b.vertices[o]),A[1].id.cf.indexA=0,A[1].id.cf.indexB=o,A[1].id.cf.typeA=bt.b2ContactFeatureType.e_face,A[1].id.cf.typeB=bt.b2ContactFeatureType.e_vertex,x.i1=0,x.i2=1,x.v1.Copy(a),x.v2.Copy(c),x.normal.Copy(y.normal),_t.b2Vec2.Negate(m,x.sideNormal1),x.sideNormal2.Copy(m)}else t.type=bt.b2ManifoldType.e_faceB,A[0].v.Copy(c),A[0].id.cf.indexA=1,A[0].id.cf.indexB=y.index,A[0].id.cf.typeA=bt.b2ContactFeatureType.e_vertex,A[0].id.cf.typeB=bt.b2ContactFeatureType.e_face,A[1].v.Copy(a),A[1].id.cf.indexA=0,A[1].id.cf.indexB=y.index,A[1].id.cf.typeA=bt.b2ContactFeatureType.e_vertex,A[1].id.cf.typeB=bt.b2ContactFeatureType.e_face,x.i1=y.index,x.i2=x.i1+1<b.count?x.i1+1:0,x.v1.Copy(b.vertices[x.i1]),x.v2.Copy(b.vertices[x.i2]),x.normal.Copy(b.normals[x.i1]),x.sideNormal1.Set(x.normal.y,-x.normal.x),_t.b2Vec2.Negate(x.sideNormal1,x.sideNormal2);x.sideOffset1=_t.b2Vec2.Dot(x.sideNormal1,x.v1),x.sideOffset2=_t.b2Vec2.Dot(x.sideNormal2,x.v2);const V=Ot,S=zt;let v;if(v=(0,bt.b2ClipSegmentToLine)(V,A,x.sideNormal1,x.sideOffset1,x.i1),v<ht.b2_maxManifoldPoints)return;if(v=(0,bt.b2ClipSegmentToLine)(S,V,x.sideNormal2,x.sideOffset2,x.i2),v<ht.b2_maxManifoldPoints)return;y.type===ft.e_edgeA?(t.localNormal.Copy(x.normal),t.localPoint.Copy(x.v1)):(t.localNormal.Copy(i.m_normals[x.i1]),t.localPoint.Copy(i.m_vertices[x.i1]));let f=0;for(let e=0;e<ht.b2_maxManifoldPoints;++e){if(_t.b2Vec2.Dot(x.normal,_t.b2Vec2.Subtract(S[e].v,x.v1,_t.b2Vec2.s_t0))<=u){const s=t.points[f];y.type===ft.e_edgeA?(_t.b2Transform.TransposeMultiplyVec2(n,S[e].v,s.localPoint),s.id.Copy(S[e].id)):(s.localPoint.Copy(S[e].v),s.id.cf.typeA=S[e].id.cf.typeB,s.id.cf.typeB=S[e].id.cf.typeA,s.id.cf.indexA=S[e].id.cf.indexB,s.id.cf.indexB=S[e].id.cf.indexA),++f}}t.pointCount=f};var jt={};Object.defineProperty(jt,"__esModule",{value:!0}),jt.b2CircleShape=void 0;const Nt=s,Et=o,Zt=m;class Wt extends Zt.b2Shape{constructor(t=0){super(Zt.b2ShapeType.e_circle,t),this.m_p=new Et.b2Vec2}Set(t,e=this.m_radius){return this.m_p.Copy(t),this.m_radius=e,this}Clone(){return(new Wt).Copy(this)}Copy(t){return super.Copy(t),this.m_p.Copy(t.m_p),this}GetChildCount(){return 1}TestPoint(t,e){const s=Et.b2Transform.MultiplyVec2(t,this.m_p,Wt.TestPoint_s_center),i=Et.b2Vec2.Subtract(e,s,Wt.TestPoint_s_d);return Et.b2Vec2.Dot(i,i)<=this.m_radius**2}RayCast(t,e,s,i){const o=Et.b2Transform.MultiplyVec2(s,this.m_p,Wt.RayCast_s_position),n=Et.b2Vec2.Subtract(e.p1,o,Wt.RayCast_s_s),r=Et.b2Vec2.Dot(n,n)-this.m_radius**2,a=Et.b2Vec2.Subtract(e.p2,e.p1,Wt.RayCast_s_r),c=Et.b2Vec2.Dot(n,a),m=Et.b2Vec2.Dot(a,a),l=c*c-m*r;if(l<0||m<Nt.b2_epsilon)return!1;let h=-(c+Math.sqrt(l));return h>=0&&h<=e.maxFraction*m&&(h/=m,t.fraction=h,Et.b2Vec2.AddScaled(n,h,a,t.normal).Normalize(),!0)}ComputeAABB(t,e,s){const i=Et.b2Transform.MultiplyVec2(e,this.m_p,Wt.ComputeAABB_s_p);t.lowerBound.Set(i.x-this.m_radius,i.y-this.m_radius),t.upperBound.Set(i.x+this.m_radius,i.y+this.m_radius)}ComputeMass(t,e){const s=this.m_radius**2;t.mass=e*Math.PI*s,t.center.Copy(this.m_p),t.I=t.mass*(.5*s+Et.b2Vec2.Dot(this.m_p,this.m_p))}SetupDistanceProxy(t,e){t.m_vertices=t.m_buffer,t.m_vertices[0].Copy(this.m_p),t.m_count=1,t.m_radius=this.m_radius}Draw(t,e){const s=this.m_p,i=this.m_radius,o=Et.b2Vec2.UNITX;t.DrawSolidCircle(s,i,o,e)}}jt.b2CircleShape=Wt,Wt.TestPoint_s_center=new Et.b2Vec2,Wt.TestPoint_s_d=new Et.b2Vec2,Wt.RayCast_s_position=new Et.b2Vec2,Wt.RayCast_s_s=new Et.b2Vec2,Wt.RayCast_s_r=new Et.b2Vec2,Wt.ComputeAABB_s_p=new Et.b2Vec2;var Xt={};Object.defineProperty(Xt,"__esModule",{value:!0}),Xt.b2PolygonShape=void 0;const Ut=s,Qt=o,Kt=i,Ht=m,Yt={ComputeCentroid:{s:new Qt.b2Vec2,p1:new Qt.b2Vec2,p2:new Qt.b2Vec2,p3:new Qt.b2Vec2,e1:new Qt.b2Vec2,e2:new Qt.b2Vec2},TestPoint:{pLocal:new Qt.b2Vec2},ComputeAABB:{v:new Qt.b2Vec2},ComputeMass:{center:new Qt.b2Vec2,s:new Qt.b2Vec2,e1:new Qt.b2Vec2,e2:new Qt.b2Vec2},Validate:{e:new Qt.b2Vec2,v:new Qt.b2Vec2},Set:{r:new Qt.b2Vec2,v:new Qt.b2Vec2},RayCast:{p1:new Qt.b2Vec2,p2:new Qt.b2Vec2,d:new Qt.b2Vec2},SetAsBox:{xf:new Qt.b2Transform}},$t=(.5*Ut.b2_linearSlop)**2;class te extends Ht.b2Shape{constructor(){super(Ht.b2ShapeType.e_polygon,Ut.b2_polygonRadius),this.m_centroid=new Qt.b2Vec2,this.m_vertices=[],this.m_normals=[],this.m_count=0}Clone(){return(new te).Copy(this)}Copy(t){super.Copy(t),this.m_centroid.Copy(t.m_centroid),this.m_count=t.m_count,this.m_vertices=(0,Ut.b2MakeArray)(this.m_count,Qt.b2Vec2),this.m_normals=(0,Ut.b2MakeArray)(this.m_count,Qt.b2Vec2);for(let e=0;e<this.m_count;++e)this.m_vertices[e].Copy(t.m_vertices[e]),this.m_normals[e].Copy(t.m_normals[e]);return this}GetChildCount(){return 1}Set(t,e=t.length){if(e<3)return this.SetAsBox(1,1);let s=Math.min(e,Kt.b2_maxPolygonVertices);const i=[];for(let e=0;e<s;++e){const s=t[e];i.every((t=>Qt.b2Vec2.DistanceSquared(s,t)>=$t))&&i.push(s)}if(s=i.length,s<3)return this.SetAsBox(1,1);let o=0,n=i[0].x;for(let t=1;t<s;++t){const{x:e}=i[t];(e>n||e===n&&i[t].y<i[o].y)&&(o=t,n=e)}const r=[];let a=0,c=o;for(;;){r[a]=c;let t=0;for(let e=1;e<s;++e){if(t===c){t=e;continue}const s=Qt.b2Vec2.Subtract(i[t],i[r[a]],Yt.Set.r),o=Qt.b2Vec2.Subtract(i[e],i[r[a]],Yt.Set.v),n=Qt.b2Vec2.Cross(s,o);n<0&&(t=e),0===n&&o.LengthSquared()>s.LengthSquared()&&(t=e)}if(++a,c=t,t===o)break}(0,Ut.b2Assert)(a>=3,"Polygon is degenerate"),this.m_count=a,this.m_vertices=(0,Ut.b2MakeArray)(this.m_count,Qt.b2Vec2),this.m_normals=(0,Ut.b2MakeArray)(this.m_count,Qt.b2Vec2);for(let t=0;t<a;++t)this.m_vertices[t].Copy(i[r[t]]);for(let t=0;t<a;++t){const e=t,s=t+1<a?t+1:0,i=Qt.b2Vec2.Subtract(this.m_vertices[s],this.m_vertices[e],Qt.b2Vec2.s_t0);Qt.b2Vec2.CrossVec2One(i,this.m_normals[t]).Normalize()}return function(t,e,s){const i=s;i.SetZero();let o=0;const{s:n,p1:r,p2:a,p3:c,e1:m,e2:l}=Yt.ComputeCentroid;n.Copy(t[0]);const h=1/3;for(let s=0;s<e;++s){Qt.b2Vec2.Subtract(t[0],n,r),Qt.b2Vec2.Subtract(t[s],n,a),Qt.b2Vec2.Subtract(t[s+1<e?s+1:0],n,c),Qt.b2Vec2.Subtract(a,r,m),Qt.b2Vec2.Subtract(c,r,l);const _=.5*Qt.b2Vec2.Cross(m,l);o+=_,i.x+=_*h*(r.x+a.x+c.x),i.y+=_*h*(r.y+a.y+c.y)}const _=1/o;i.x=_*i.x+n.x,i.y=_*i.y+n.y}(this.m_vertices,a,this.m_centroid),this}SetAsBox(t,e,s,i=0){if(this.m_count=4,this.m_vertices=(0,Ut.b2MakeArray)(this.m_count,Qt.b2Vec2),this.m_normals=(0,Ut.b2MakeArray)(this.m_count,Qt.b2Vec2),this.m_vertices[0].Set(-t,-e),this.m_vertices[1].Set(t,-e),this.m_vertices[2].Set(t,e),this.m_vertices[3].Set(-t,e),this.m_normals[0].Set(0,-1),this.m_normals[1].Set(1,0),this.m_normals[2].Set(0,1),this.m_normals[3].Set(-1,0),s){this.m_centroid.Copy(s);const{xf:t}=Yt.SetAsBox;t.SetPosition(s),t.SetRotationAngle(i);for(let e=0;e<this.m_count;++e)Qt.b2Transform.MultiplyVec2(t,this.m_vertices[e],this.m_vertices[e]),Qt.b2Rot.MultiplyVec2(t.q,this.m_normals[e],this.m_normals[e])}else this.m_centroid.SetZero();return this}TestPoint(t,e){const s=Qt.b2Transform.TransposeMultiplyVec2(t,e,Yt.TestPoint.pLocal);for(let t=0;t<this.m_count;++t){if(Qt.b2Vec2.Dot(this.m_normals[t],Qt.b2Vec2.Subtract(s,this.m_vertices[t],Qt.b2Vec2.s_t0))>0)return!1}return!0}RayCast(t,e,s,i){const o=Qt.b2Transform.TransposeMultiplyVec2(s,e.p1,Yt.RayCast.p1),n=Qt.b2Transform.TransposeMultiplyVec2(s,e.p2,Yt.RayCast.p2),r=Qt.b2Vec2.Subtract(n,o,Yt.RayCast.d);let a=0,c=e.maxFraction,m=-1;for(let t=0;t<this.m_count;++t){const e=Qt.b2Vec2.Dot(this.m_normals[t],Qt.b2Vec2.Subtract(this.m_vertices[t],o,Qt.b2Vec2.s_t0)),s=Qt.b2Vec2.Dot(this.m_normals[t],r);if(0===s){if(e<0)return!1}else s<0&&e<a*s?(a=e/s,m=t):s>0&&e<c*s&&(c=e/s);if(c<a)return!1}return m>=0&&(t.fraction=a,Qt.b2Rot.MultiplyVec2(s.q,this.m_normals[m],t.normal),!0)}ComputeAABB(t,e,s){const i=Qt.b2Transform.MultiplyVec2(e,this.m_vertices[0],t.lowerBound),o=t.upperBound.Copy(i);for(let t=1;t<this.m_count;++t){const s=Qt.b2Transform.MultiplyVec2(e,this.m_vertices[t],Yt.ComputeAABB.v);Qt.b2Vec2.Min(i,s,i),Qt.b2Vec2.Max(o,s,o)}const n=this.m_radius;i.SubtractXY(n,n),o.AddXY(n,n)}ComputeMass(t,e){const s=Yt.ComputeMass.center.SetZero();let i=0,o=0;const n=Yt.ComputeMass.s.Copy(this.m_vertices[0]),r=1/3;for(let t=0;t<this.m_count;++t){const e=Qt.b2Vec2.Subtract(this.m_vertices[t],n,Yt.ComputeMass.e1),a=Qt.b2Vec2.Subtract(this.m_vertices[t+1<this.m_count?t+1:0],n,Yt.ComputeMass.e2),c=Qt.b2Vec2.Cross(e,a),m=.5*c;i+=m,s.AddScaled(m*r,Qt.b2Vec2.Add(e,a,Qt.b2Vec2.s_t0));const l=e.x,h=e.y,_=a.x,b=a.y;o+=.25*r*c*(l*l+_*l+_*_+(h*h+b*h+b*b))}t.mass=e*i,s.Scale(1/i),Qt.b2Vec2.Add(s,n,t.center),t.I=e*o,t.I+=t.mass*(Qt.b2Vec2.Dot(t.center,t.center)-Qt.b2Vec2.Dot(s,s))}Validate(){const{e:t,v:e}=Yt.Validate;for(let s=0;s<this.m_count;++s){const i=s,o=s<this.m_count-1?i+1:0,n=this.m_vertices[i];Qt.b2Vec2.Subtract(this.m_vertices[o],n,t);for(let s=0;s<this.m_count;++s){if(s===i||s===o)continue;Qt.b2Vec2.Subtract(this.m_vertices[s],n,e);if(Qt.b2Vec2.Cross(t,e)<0)return!1}}return!0}SetupDistanceProxy(t,e){t.m_vertices=this.m_vertices,t.m_count=this.m_count,t.m_radius=this.m_radius}Draw(t,e){const s=this.m_count,i=this.m_vertices;t.DrawSolidPolygon(i,s,e)}}Xt.b2PolygonShape=te;var ee={};Object.defineProperty(ee,"__esModule",{value:!0}),ee.b2EdgeShape=void 0;const se=s,ie=o,oe=m;class ne extends oe.b2Shape{constructor(){super(oe.b2ShapeType.e_edge,se.b2_polygonRadius),this.m_vertex1=new ie.b2Vec2,this.m_vertex2=new ie.b2Vec2,this.m_vertex0=new ie.b2Vec2,this.m_vertex3=new ie.b2Vec2,this.m_oneSided=!1}SetOneSided(t,e,s,i){return this.m_vertex0.Copy(t),this.m_vertex1.Copy(e),this.m_vertex2.Copy(s),this.m_vertex3.Copy(i),this.m_oneSided=!0,this}SetTwoSided(t,e){return this.m_vertex1.Copy(t),this.m_vertex2.Copy(e),this.m_oneSided=!1,this}Clone(){return(new ne).Copy(this)}Copy(t){return super.Copy(t),this.m_vertex1.Copy(t.m_vertex1),this.m_vertex2.Copy(t.m_vertex2),this.m_vertex0.Copy(t.m_vertex0),this.m_vertex3.Copy(t.m_vertex3),this.m_oneSided=t.m_oneSided,this}GetChildCount(){return 1}TestPoint(t,e){return!1}RayCast(t,e,s,i){const o=ie.b2Transform.TransposeMultiplyVec2(s,e.p1,ne.RayCast_s_p1),n=ie.b2Transform.TransposeMultiplyVec2(s,e.p2,ne.RayCast_s_p2),r=ie.b2Vec2.Subtract(n,o,ne.RayCast_s_d),a=this.m_vertex1,c=this.m_vertex2,m=ie.b2Vec2.Subtract(c,a,ne.RayCast_s_e),{normal:l}=t;l.Set(m.y,-m.x).Normalize();const h=ie.b2Vec2.Dot(l,ie.b2Vec2.Subtract(a,o,ie.b2Vec2.s_t0));if(this.m_oneSided&&h>0)return!1;const _=ie.b2Vec2.Dot(l,r);if(0===_)return!1;const b=h/_;if(b<0||e.maxFraction<b)return!1;const u=ie.b2Vec2.AddScaled(o,b,r,ne.RayCast_s_q),d=ie.b2Vec2.Subtract(c,a,ne.RayCast_s_r),p=ie.b2Vec2.Dot(d,d);if(0===p)return!1;const y=ie.b2Vec2.Dot(ie.b2Vec2.Subtract(u,a,ie.b2Vec2.s_t0),d)/p;return!(y<0||y>1)&&(t.fraction=b,ie.b2Rot.MultiplyVec2(s.q,t.normal,t.normal),h>0&&t.normal.Negate(),!0)}ComputeAABB(t,e,s){const i=ie.b2Transform.MultiplyVec2(e,this.m_vertex1,ne.ComputeAABB_s_v1),o=ie.b2Transform.MultiplyVec2(e,this.m_vertex2,ne.ComputeAABB_s_v2);ie.b2Vec2.Min(i,o,t.lowerBound),ie.b2Vec2.Max(i,o,t.upperBound);const n=this.m_radius;t.lowerBound.SubtractXY(n,n),t.upperBound.AddXY(n,n)}ComputeMass(t,e){t.mass=0,ie.b2Vec2.Mid(this.m_vertex1,this.m_vertex2,t.center),t.I=0}SetupDistanceProxy(t,e){t.m_vertices=t.m_buffer,t.m_vertices[0].Copy(this.m_vertex1),t.m_vertices[1].Copy(this.m_vertex2),t.m_count=2,t.m_radius=this.m_radius}Draw(t,e){const s=this.m_vertex1,i=this.m_vertex2;t.DrawSegment(s,i,e),!1===this.m_oneSided&&(t.DrawPoint(s,4,e),t.DrawPoint(i,4,e))}}ee.b2EdgeShape=ne,ne.RayCast_s_p1=new ie.b2Vec2,ne.RayCast_s_p2=new ie.b2Vec2,ne.RayCast_s_d=new ie.b2Vec2,ne.RayCast_s_e=new ie.b2Vec2,ne.RayCast_s_q=new ie.b2Vec2,ne.RayCast_s_r=new ie.b2Vec2,ne.ComputeAABB_s_v1=new ie.b2Vec2,ne.ComputeAABB_s_v2=new ie.b2Vec2;var re={};Object.defineProperty(re,"__esModule",{value:!0}),re.b2ChainShape=void 0;const ae=s,ce=o,me=m,le=ee;class he extends me.b2Shape{constructor(){super(me.b2ShapeType.e_chain,ae.b2_polygonRadius),this.m_vertices=[],this.m_prevVertex=new ce.b2Vec2,this.m_nextVertex=new ce.b2Vec2}CreateLoop(t,e=t.length){if(e<3)return this;this.m_vertices.length=e+1;for(let s=0;s<e;++s){const{x:e,y:i}=t[s];this.m_vertices[s]=new ce.b2Vec2(e,i)}return this.m_vertices[e]=this.m_vertices[0].Clone(),this.m_prevVertex.Copy(this.m_vertices[this.m_vertices.length-2]),this.m_nextVertex.Copy(this.m_vertices[1]),this}CreateChain(t,e,s,i){this.m_vertices.length=e;for(let s=0;s<e;++s){const{x:e,y:i}=t[s];this.m_vertices[s]=new ce.b2Vec2(e,i)}return this.m_prevVertex.Copy(s),this.m_nextVertex.Copy(i),this}Clone(){return(new he).Copy(this)}Copy(t){return super.Copy(t),this.CreateChain(t.m_vertices,t.m_vertices.length,t.m_prevVertex,t.m_nextVertex)}GetChildCount(){return this.m_vertices.length-1}GetChildEdge(t,e){t.m_radius=this.m_radius,t.m_vertex1.Copy(this.m_vertices[e]),t.m_vertex2.Copy(this.m_vertices[e+1]),t.m_oneSided=!0,e>0?t.m_vertex0.Copy(this.m_vertices[e-1]):t.m_vertex0.Copy(this.m_prevVertex),e<this.m_vertices.length-2?t.m_vertex3.Copy(this.m_vertices[e+2]):t.m_vertex3.Copy(this.m_nextVertex)}TestPoint(t,e){return!1}RayCast(t,e,s,i){const o=he.RayCast_s_edgeShape,n=i;let r=i+1;return r===this.m_vertices.length&&(r=0),o.m_vertex1.Copy(this.m_vertices[n]),o.m_vertex2.Copy(this.m_vertices[r]),o.RayCast(t,e,s,0)}ComputeAABB(t,e,s){const i=s;let o=s+1;o===this.m_vertices.length&&(o=0);const n=ce.b2Transform.MultiplyVec2(e,this.m_vertices[i],he.ComputeAABB_s_v1),r=ce.b2Transform.MultiplyVec2(e,this.m_vertices[o],he.ComputeAABB_s_v2),a=ce.b2Vec2.Min(n,r,he.ComputeAABB_s_lower),c=ce.b2Vec2.Max(n,r,he.ComputeAABB_s_upper);t.lowerBound.x=a.x-this.m_radius,t.lowerBound.y=a.y-this.m_radius,t.upperBound.x=c.x+this.m_radius,t.upperBound.y=c.y+this.m_radius}ComputeMass(t,e){t.mass=0,t.center.SetZero(),t.I=0}SetupDistanceProxy(t,e){t.m_vertices=t.m_buffer,t.m_vertices[0].Copy(this.m_vertices[e]),e+1<this.m_vertices.length?t.m_vertices[1].Copy(this.m_vertices[e+1]):t.m_vertices[1].Copy(this.m_vertices[0]),t.m_count=2,t.m_radius=this.m_radius}Draw(t,e){const s=this.m_vertices;let i=s[0];for(let o=1;o<s.length;++o){const n=s[o];t.DrawSegment(i,n,e),i=n}}}re.b2ChainShape=he,he.RayCast_s_edgeShape=new le.b2EdgeShape,he.ComputeAABB_s_v1=new ce.b2Vec2,he.ComputeAABB_s_v2=new ce.b2Vec2,he.ComputeAABB_s_lower=new ce.b2Vec2,he.ComputeAABB_s_upper=new ce.b2Vec2;var _e={},be={};!function(t){Object.defineProperty(t,"__esModule",{value:!0}),t.b2Joint=t.b2AngularStiffness=t.b2LinearStiffness=t.b2JointDef=t.b2JointEdge=t.b2JointType=void 0;const e=n,s=o,i={pA:new s.b2Vec2,pB:new s.b2Vec2};var r;!function(t){t[t.e_unknownJoint=0]="e_unknownJoint",t[t.e_revoluteJoint=1]="e_revoluteJoint",t[t.e_prismaticJoint=2]="e_prismaticJoint",t[t.e_distanceJoint=3]="e_distanceJoint",t[t.e_pulleyJoint=4]="e_pulleyJoint",t[t.e_mouseJoint=5]="e_mouseJoint",t[t.e_gearJoint=6]="e_gearJoint",t[t.e_wheelJoint=7]="e_wheelJoint",t[t.e_weldJoint=8]="e_weldJoint",t[t.e_frictionJoint=9]="e_frictionJoint",t[t.e_motorJoint=10]="e_motorJoint",t[t.e_areaJoint=11]="e_areaJoint"}(r=t.b2JointType||(t.b2JointType={}));class a{constructor(t,e){this.prev=null,this.next=null,this.joint=t,this.other=e}}t.b2JointEdge=a;t.b2JointDef=class{constructor(t){this.userData=null,this.collideConnected=!1,this.type=t}},t.b2LinearStiffness=function(t,e,s,i,o){const n=i.GetMass(),r=o.GetMass();let a;a=n>0&&r>0?n*r/(n+r):n>0?n:r;const c=2*Math.PI*e;t.stiffness=a*c*c,t.damping=2*a*s*c},t.b2AngularStiffness=function(t,e,s,i,o){const n=i.GetInertia(),r=o.GetInertia();let a;a=n>0&&r>0?n*r/(n+r):n>0?n:r;const c=2*Math.PI*e;t.stiffness=a*c*c,t.damping=2*a*s*c};t.b2Joint=class{constructor(t){var e;this.m_type=r.e_unknownJoint,this.m_prev=null,this.m_next=null,this.m_islandFlag=!1,this.m_collideConnected=!1,this.m_userData=null,this.m_type=t.type,this.m_edgeA=new a(this,t.bodyB),this.m_edgeB=new a(this,t.bodyA),this.m_bodyA=t.bodyA,this.m_bodyB=t.bodyB,this.m_collideConnected=null!==(e=t.collideConnected)&&void 0!==e&&e,this.m_userData=t.userData}GetType(){return this.m_type}GetBodyA(){return this.m_bodyA}GetBodyB(){return this.m_bodyB}GetNext(){return this.m_next}GetUserData(){return this.m_userData}SetUserData(t){this.m_userData=t}IsEnabled(){return this.m_bodyA.IsEnabled()&&this.m_bodyB.IsEnabled()}GetCollideConnected(){return this.m_collideConnected}ShiftOrigin(t){}Draw(t){const s=this.m_bodyA.GetTransform().p,o=this.m_bodyB.GetTransform().p,n=this.GetAnchorA(i.pA),r=this.GetAnchorB(i.pB);t.DrawSegment(s,n,e.debugColors.joint6),t.DrawSegment(n,r,e.debugColors.joint6),t.DrawSegment(o,r,e.debugColors.joint6)}}}(be);var ue={},de={};Object.defineProperty(de,"__esModule",{value:!0}),de.b2DistanceJoint=de.b2DistanceJointDef=void 0;const pe=s,ye=o,Ae=be,xe=n,Ve={worldPointA:new ye.b2Vec2,worldPointB:new ye.b2Vec2,vpA:new ye.b2Vec2,vpB:new ye.b2Vec2,vpBA:new ye.b2Vec2,P:new ye.b2Vec2,qA:new ye.b2Rot,qB:new ye.b2Rot,lalcA:new ye.b2Vec2,lalcB:new ye.b2Vec2,Draw:{pA:new ye.b2Vec2,pB:new ye.b2Vec2,axis:new ye.b2Vec2,pRest:new ye.b2Vec2,p1:new ye.b2Vec2,p2:new ye.b2Vec2}};de.b2DistanceJointDef=class extends Ae.b2JointDef{constructor(){super(Ae.b2JointType.e_distanceJoint),this.localAnchorA=new ye.b2Vec2,this.localAnchorB=new ye.b2Vec2,this.length=1,this.minLength=0,this.maxLength=pe.b2_maxFloat,this.stiffness=0,this.damping=0}Initialize(t,e,s,i){this.bodyA=t,this.bodyB=e,this.bodyA.GetLocalPoint(s,this.localAnchorA),this.bodyB.GetLocalPoint(i,this.localAnchorB),this.length=Math.max(ye.b2Vec2.Distance(s,i),pe.b2_linearSlop),this.minLength=this.length,this.maxLength=this.length}};de.b2DistanceJoint=class extends Ae.b2Joint{constructor(t){var e,s;super(t),this.m_bias=0,this.m_localAnchorA=new ye.b2Vec2,this.m_localAnchorB=new ye.b2Vec2,this.m_gamma=0,this.m_impulse=0,this.m_lowerImpulse=0,this.m_upperImpulse=0,this.m_indexA=0,this.m_indexB=0,this.m_u=new ye.b2Vec2,this.m_rA=new ye.b2Vec2,this.m_rB=new ye.b2Vec2,this.m_localCenterA=new ye.b2Vec2,this.m_localCenterB=new ye.b2Vec2,this.m_currentLength=0,this.m_invMassA=0,this.m_invMassB=0,this.m_invIA=0,this.m_invIB=0,this.m_softMass=0,this.m_mass=0,this.m_localAnchorA.Copy(t.localAnchorA),this.m_localAnchorB.Copy(t.localAnchorB),this.m_length=Math.max(t.length,pe.b2_linearSlop),this.m_minLength=Math.max(t.minLength,pe.b2_linearSlop),this.m_maxLength=Math.max(t.maxLength,this.m_minLength),this.m_stiffness=null!==(e=t.stiffness)&&void 0!==e?e:0,this.m_damping=null!==(s=t.damping)&&void 0!==s?s:0}GetAnchorA(t){return this.m_bodyA.GetWorldPoint(this.m_localAnchorA,t)}GetAnchorB(t){return this.m_bodyB.GetWorldPoint(this.m_localAnchorB,t)}GetReactionForce(t,e){const s=t*(this.m_impulse+this.m_lowerImpulse-this.m_upperImpulse);return e.x=s*this.m_u.x,e.y=s*this.m_u.y,e}GetReactionTorque(t){return 0}GetLocalAnchorA(){return this.m_localAnchorA}GetLocalAnchorB(){return this.m_localAnchorB}SetLength(t){return this.m_impulse=0,this.m_length=Math.max(pe.b2_linearSlop,t),this.m_length}GetLength(){return this.m_length}SetMinLength(t){return this.m_lowerImpulse=0,this.m_minLength=(0,ye.b2Clamp)(t,pe.b2_linearSlop,this.m_maxLength),this.m_minLength}GetMinLength(){return this.m_minLength}SetMaxLength(t){return this.m_upperImpulse=0,this.m_maxLength=Math.max(t,this.m_minLength),this.m_maxLength}GetMaxLength(){return this.m_maxLength}GetCurrentLength(){const t=this.m_bodyA.GetWorldPoint(this.m_localAnchorA,Ve.worldPointA),e=this.m_bodyB.GetWorldPoint(this.m_localAnchorB,Ve.worldPointB);return ye.b2Vec2.Distance(e,t)}SetStiffness(t){this.m_stiffness=t}GetStiffness(){return this.m_stiffness}SetDamping(t){this.m_damping=t}GetDamping(){return this.m_damping}InitVelocityConstraints(t){this.m_indexA=this.m_bodyA.m_islandIndex,this.m_indexB=this.m_bodyB.m_islandIndex,this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter),this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter),this.m_invMassA=this.m_bodyA.m_invMass,this.m_invMassB=this.m_bodyB.m_invMass,this.m_invIA=this.m_bodyA.m_invI,this.m_invIB=this.m_bodyB.m_invI;const e=t.positions[this.m_indexA].c,s=t.positions[this.m_indexA].a,i=t.velocities[this.m_indexA].v;let o=t.velocities[this.m_indexA].w;const n=t.positions[this.m_indexB].c,r=t.positions[this.m_indexB].a,a=t.velocities[this.m_indexB].v;let c=t.velocities[this.m_indexB].w;const{qA:m,qB:l,lalcA:h,lalcB:_}=Ve;m.Set(s),l.Set(r),ye.b2Rot.MultiplyVec2(m,ye.b2Vec2.Subtract(this.m_localAnchorA,this.m_localCenterA,h),this.m_rA),ye.b2Rot.MultiplyVec2(l,ye.b2Vec2.Subtract(this.m_localAnchorB,this.m_localCenterB,_),this.m_rB),this.m_u.x=n.x+this.m_rB.x-e.x-this.m_rA.x,this.m_u.y=n.y+this.m_rB.y-e.y-this.m_rA.y,this.m_currentLength=this.m_u.Length(),this.m_currentLength>pe.b2_linearSlop?this.m_u.Scale(1/this.m_currentLength):(this.m_u.SetZero(),this.m_mass=0,this.m_impulse=0,this.m_lowerImpulse=0,this.m_upperImpulse=0);const b=ye.b2Vec2.Cross(this.m_rA,this.m_u),u=ye.b2Vec2.Cross(this.m_rB,this.m_u);let d=this.m_invMassA+this.m_invIA*b*b+this.m_invMassB+this.m_invIB*u*u;if(this.m_mass=0!==d?1/d:0,this.m_stiffness>0&&this.m_minLength<this.m_maxLength){const e=this.m_currentLength-this.m_length,s=this.m_damping,i=this.m_stiffness,o=t.step.dt;this.m_gamma=o*(s+o*i),this.m_gamma=0!==this.m_gamma?1/this.m_gamma:0,this.m_bias=e*o*i*this.m_gamma,d+=this.m_gamma,this.m_softMass=0!==d?1/d:0}else this.m_gamma=0,this.m_bias=0,this.m_softMass=this.m_mass;if(t.step.warmStarting){this.m_impulse*=t.step.dtRatio,this.m_lowerImpulse*=t.step.dtRatio,this.m_upperImpulse*=t.step.dtRatio;const{P:e}=Ve;ye.b2Vec2.Scale(this.m_impulse+this.m_lowerImpulse-this.m_upperImpulse,this.m_u,e),i.SubtractScaled(this.m_invMassA,e),o-=this.m_invIA*ye.b2Vec2.Cross(this.m_rA,e),a.AddScaled(this.m_invMassB,e),c+=this.m_invIB*ye.b2Vec2.Cross(this.m_rB,e)}else this.m_impulse=0;t.velocities[this.m_indexA].w=o,t.velocities[this.m_indexB].w=c}SolveVelocityConstraints(t){const e=t.velocities[this.m_indexA].v;let s=t.velocities[this.m_indexA].w;const i=t.velocities[this.m_indexB].v;let o=t.velocities[this.m_indexB].w;if(this.m_minLength<this.m_maxLength){if(this.m_stiffness>0){const t=ye.b2Vec2.AddCrossScalarVec2(e,s,this.m_rA,Ve.vpA),n=ye.b2Vec2.AddCrossScalarVec2(i,o,this.m_rB,Ve.vpB),r=ye.b2Vec2.Dot(this.m_u,ye.b2Vec2.Subtract(n,t,Ve.vpBA)),a=-this.m_softMass*(r+this.m_bias+this.m_gamma*this.m_impulse);this.m_impulse+=a;const c=ye.b2Vec2.Scale(a,this.m_u,Ve.P);e.SubtractScaled(this.m_invMassA,c),s-=this.m_invIA*ye.b2Vec2.Cross(this.m_rA,c),i.AddScaled(this.m_invMassB,c),o+=this.m_invIB*ye.b2Vec2.Cross(this.m_rB,c)}{const n=this.m_currentLength-this.m_minLength,r=Math.max(0,n)*t.step.inv_dt,a=ye.b2Vec2.AddCrossScalarVec2(e,s,this.m_rA,Ve.vpA),c=ye.b2Vec2.AddCrossScalarVec2(i,o,this.m_rB,Ve.vpB),m=ye.b2Vec2.Dot(this.m_u,ye.b2Vec2.Subtract(c,a,Ve.vpBA));let l=-this.m_mass*(m+r);const h=this.m_lowerImpulse;this.m_lowerImpulse=Math.max(0,this.m_lowerImpulse+l),l=this.m_lowerImpulse-h;const _=ye.b2Vec2.Scale(l,this.m_u,Ve.P);e.SubtractScaled(this.m_invMassA,_),s-=this.m_invIA*ye.b2Vec2.Cross(this.m_rA,_),i.AddScaled(this.m_invMassB,_),o+=this.m_invIB*ye.b2Vec2.Cross(this.m_rB,_)}{const n=this.m_maxLength-this.m_currentLength,r=Math.max(0,n)*t.step.inv_dt,a=ye.b2Vec2.AddCrossScalarVec2(e,s,this.m_rA,Ve.vpA),c=ye.b2Vec2.AddCrossScalarVec2(i,o,this.m_rB,Ve.vpB),m=ye.b2Vec2.Dot(this.m_u,ye.b2Vec2.Subtract(a,c,Ve.vpBA));let l=-this.m_mass*(m+r);const h=this.m_upperImpulse;this.m_upperImpulse=Math.max(0,this.m_upperImpulse+l),l=this.m_upperImpulse-h;const _=ye.b2Vec2.Scale(-l,this.m_u,Ve.P);e.SubtractScaled(this.m_invMassA,_),s-=this.m_invIA*ye.b2Vec2.Cross(this.m_rA,_),i.AddScaled(this.m_invMassB,_),o+=this.m_invIB*ye.b2Vec2.Cross(this.m_rB,_)}}else{const t=ye.b2Vec2.AddCrossScalarVec2(e,s,this.m_rA,Ve.vpA),n=ye.b2Vec2.AddCrossScalarVec2(i,o,this.m_rB,Ve.vpB),r=ye.b2Vec2.Dot(this.m_u,ye.b2Vec2.Subtract(n,t,Ve.vpBA)),a=-this.m_mass*r;this.m_impulse+=a;const c=ye.b2Vec2.Scale(a,this.m_u,Ve.P);e.SubtractScaled(this.m_invMassA,c),s-=this.m_invIA*ye.b2Vec2.Cross(this.m_rA,c),i.AddScaled(this.m_invMassB,c),o+=this.m_invIB*ye.b2Vec2.Cross(this.m_rB,c)}t.velocities[this.m_indexA].w=s,t.velocities[this.m_indexB].w=o}SolvePositionConstraints(t){const e=t.positions[this.m_indexA].c;let s=t.positions[this.m_indexA].a;const i=t.positions[this.m_indexB].c;let o=t.positions[this.m_indexB].a;const{qA:n,qB:r,lalcA:a,lalcB:c,P:m}=Ve;n.Set(s),r.Set(o);const l=ye.b2Rot.MultiplyVec2(n,ye.b2Vec2.Subtract(this.m_localAnchorA,this.m_localCenterA,a),this.m_rA),h=ye.b2Rot.MultiplyVec2(r,ye.b2Vec2.Subtract(this.m_localAnchorB,this.m_localCenterB,c),this.m_rB);this.m_u.x=i.x+h.x-e.x-l.x,this.m_u.y=i.y+h.y-e.y-l.y;const _=this.m_u.Normalize();let b;if(this.m_minLength===this.m_maxLength)b=_-this.m_minLength;else if(_<this.m_minLength)b=_-this.m_minLength;else{if(!(this.m_maxLength<_))return!0;b=_-this.m_maxLength}const u=-this.m_mass*b;return ye.b2Vec2.Scale(u,this.m_u,m),e.SubtractScaled(this.m_invMassA,m),s-=this.m_invIA*ye.b2Vec2.Cross(l,m),i.AddScaled(this.m_invMassB,m),o+=this.m_invIB*ye.b2Vec2.Cross(h,m),t.positions[this.m_indexA].a=s,t.positions[this.m_indexB].a=o,Math.abs(b)<pe.b2_linearSlop}Draw(t){const{pA:e,pB:s,axis:i,pRest:o}=Ve.Draw,n=this.m_bodyA.GetTransform(),r=this.m_bodyB.GetTransform();if(ye.b2Transform.MultiplyVec2(n,this.m_localAnchorA,e),ye.b2Transform.MultiplyVec2(r,this.m_localAnchorB,s),ye.b2Vec2.Subtract(s,e,i),i.Normalize(),t.DrawSegment(e,s,xe.debugColors.joint5),ye.b2Vec2.AddScaled(e,this.m_length,i,o),t.DrawPoint(o,8,xe.debugColors.joint1),this.m_minLength!==this.m_maxLength){if(this.m_minLength>pe.b2_linearSlop){const s=ye.b2Vec2.AddScaled(e,this.m_minLength,i,Ve.Draw.p1);t.DrawPoint(s,4,xe.debugColors.joint2)}if(this.m_maxLength<pe.b2_maxFloat){const s=ye.b2Vec2.AddScaled(e,this.m_maxLength,i,Ve.Draw.p1);t.DrawPoint(s,4,xe.debugColors.joint3)}}}},Object.defineProperty(ue,"__esModule",{value:!0}),ue.b2AreaJoint=ue.b2AreaJointDef=void 0;const Se=s,ve=o,fe=be,Ce=de;ue.b2AreaJointDef=class extends fe.b2JointDef{constructor(){super(fe.b2JointType.e_areaJoint),this.bodies=[],this.stiffness=0,this.damping=0}AddBody(t){this.bodies.push(t),1===this.bodies.length?this.bodyA=t:2===this.bodies.length&&(this.bodyB=t)}};ue.b2AreaJoint=class extends fe.b2Joint{constructor(t){var e,s;super(t),this.m_stiffness=0,this.m_damping=0,this.m_impulse=0,this.m_targetArea=0,this.m_joints=[],this.m_delta=new ve.b2Vec2,this.m_bodies=t.bodies,this.m_stiffness=null!==(e=t.stiffness)&&void 0!==e?e:0,this.m_damping=null!==(s=t.damping)&&void 0!==s?s:0,this.m_targetLengths=(0,Se.b2MakeNumberArray)(t.bodies.length),this.m_normals=(0,Se.b2MakeArray)(t.bodies.length,ve.b2Vec2),this.m_deltas=(0,Se.b2MakeArray)(t.bodies.length,ve.b2Vec2);const i=new Ce.b2DistanceJointDef;i.stiffness=this.m_stiffness,i.damping=this.m_damping,this.m_targetArea=0;for(let t=0;t<this.m_bodies.length;++t){const e=this.m_bodies[t],s=this.m_bodies[(t+1)%this.m_bodies.length],o=e.GetWorldCenter(),n=s.GetWorldCenter();this.m_targetLengths[t]=ve.b2Vec2.Distance(o,n),this.m_targetArea+=ve.b2Vec2.Cross(o,n),i.Initialize(e,s,o,n),this.m_joints[t]=e.GetWorld().CreateJoint(i)}this.m_targetArea*=.5}GetAnchorA(t){return t}GetAnchorB(t){return t}GetReactionForce(t,e){return e}GetReactionTorque(t){return 0}SetStiffness(t){this.m_stiffness=t;for(const e of this.m_joints)e.SetStiffness(t)}GetStiffness(){return this.m_stiffness}SetDamping(t){this.m_damping=t;for(const e of this.m_joints)e.SetDamping(t)}GetDamping(){return this.m_damping}InitVelocityConstraints(t){for(let e=0;e<this.m_bodies.length;++e){const s=this.m_bodies[(e+this.m_bodies.length-1)%this.m_bodies.length],i=this.m_bodies[(e+1)%this.m_bodies.length],o=t.positions[s.m_islandIndex].c,n=t.positions[i.m_islandIndex].c,r=this.m_deltas[e];ve.b2Vec2.Subtract(n,o,r)}if(t.step.warmStarting){this.m_impulse*=t.step.dtRatio;for(let e=0;e<this.m_bodies.length;++e){const s=this.m_bodies[e],i=t.velocities[s.m_islandIndex].v,o=this.m_deltas[e];i.x+=s.m_invMass*o.y*.5*this.m_impulse,i.y+=s.m_invMass*-o.x*.5*this.m_impulse}}else this.m_impulse=0}SolveVelocityConstraints(t){let e=0,s=0;for(let i=0;i<this.m_bodies.length;++i){const o=this.m_bodies[i],n=t.velocities[o.m_islandIndex].v,r=this.m_deltas[i];e+=r.LengthSquared()/o.GetMass(),s+=ve.b2Vec2.Cross(n,r)}const i=-2*s/e;this.m_impulse+=i;for(let e=0;e<this.m_bodies.length;++e){const s=this.m_bodies[e],o=t.velocities[s.m_islandIndex].v,n=this.m_deltas[e];o.x+=s.m_invMass*n.y*.5*i,o.y+=s.m_invMass*-n.x*.5*i}}SolvePositionConstraints(t){let e=0,s=0;for(let i=0;i<this.m_bodies.length;++i){const o=this.m_bodies[i],n=this.m_bodies[(i+1)%this.m_bodies.length],r=t.positions[o.m_islandIndex].c,a=t.positions[n.m_islandIndex].c,c=ve.b2Vec2.Subtract(a,r,this.m_delta);let m=c.Length();m<Se.b2_epsilon&&(m=1),this.m_normals[i].x=c.y/m,this.m_normals[i].y=-c.x/m,e+=m,s+=ve.b2Vec2.Cross(r,a)}s*=.5;const i=.5*(this.m_targetArea-s)/e;let o=!0;for(let e=0;e<this.m_bodies.length;++e){const s=this.m_bodies[e],n=t.positions[s.m_islandIndex].c,r=(e+1)%this.m_bodies.length,a=ve.b2Vec2.Add(this.m_normals[e],this.m_normals[r],this.m_delta);a.Scale(i);const c=a.LengthSquared();c>Se.b2_maxLinearCorrection**2&&a.Scale(Se.b2_maxLinearCorrection/Math.sqrt(c)),c>Se.b2_linearSlop**2&&(o=!1),n.Add(a)}return o}};var Be={};Object.defineProperty(Be,"__esModule",{value:!0}),Be.b2FrictionJoint=Be.b2FrictionJointDef=void 0;const we=o,ge=be,Me={qA:new we.b2Rot,qB:new we.b2Rot,lalcA:new we.b2Vec2,lalcB:new we.b2Vec2,Cdot:new we.b2Vec2,impulse:new we.b2Vec2,oldImpulse:new we.b2Vec2};Be.b2FrictionJointDef=class extends ge.b2JointDef{constructor(){super(ge.b2JointType.e_frictionJoint),this.localAnchorA=new we.b2Vec2,this.localAnchorB=new we.b2Vec2,this.maxForce=0,this.maxTorque=0}Initialize(t,e,s){this.bodyA=t,this.bodyB=e,this.bodyA.GetLocalPoint(s,this.localAnchorA),this.bodyB.GetLocalPoint(s,this.localAnchorB)}};Be.b2FrictionJoint=class extends ge.b2Joint{constructor(t){var e,s;super(t),this.m_localAnchorA=new we.b2Vec2,this.m_localAnchorB=new we.b2Vec2,this.m_linearImpulse=new we.b2Vec2,this.m_angularImpulse=0,this.m_maxForce=0,this.m_maxTorque=0,this.m_indexA=0,this.m_indexB=0,this.m_rA=new we.b2Vec2,this.m_rB=new we.b2Vec2,this.m_localCenterA=new we.b2Vec2,this.m_localCenterB=new we.b2Vec2,this.m_invMassA=0,this.m_invMassB=0,this.m_invIA=0,this.m_invIB=0,this.m_linearMass=new we.b2Mat22,this.m_angularMass=0,this.m_localAnchorA.Copy(t.localAnchorA),this.m_localAnchorB.Copy(t.localAnchorB),this.m_linearImpulse.SetZero(),this.m_maxForce=null!==(e=t.maxForce)&&void 0!==e?e:0,this.m_maxTorque=null!==(s=t.maxTorque)&&void 0!==s?s:0}InitVelocityConstraints(t){this.m_indexA=this.m_bodyA.m_islandIndex,this.m_indexB=this.m_bodyB.m_islandIndex,this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter),this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter),this.m_invMassA=this.m_bodyA.m_invMass,this.m_invMassB=this.m_bodyB.m_invMass,this.m_invIA=this.m_bodyA.m_invI,this.m_invIB=this.m_bodyB.m_invI;const e=t.positions[this.m_indexA].a,s=t.velocities[this.m_indexA].v;let i=t.velocities[this.m_indexA].w;const o=t.positions[this.m_indexB].a,n=t.velocities[this.m_indexB].v;let r=t.velocities[this.m_indexB].w;const{qA:a,qB:c,lalcA:m,lalcB:l}=Me;a.Set(e),c.Set(o),we.b2Rot.MultiplyVec2(a,we.b2Vec2.Subtract(this.m_localAnchorA,this.m_localCenterA,m),this.m_rA),we.b2Rot.MultiplyVec2(c,we.b2Vec2.Subtract(this.m_localAnchorB,this.m_localCenterB,l),this.m_rB);const h=this.m_invMassA,_=this.m_invMassB,b=this.m_invIA,u=this.m_invIB,d=this.m_linearMass;if(d.ex.x=h+_+b*this.m_rA.y*this.m_rA.y+u*this.m_rB.y*this.m_rB.y,d.ex.y=-b*this.m_rA.x*this.m_rA.y-u*this.m_rB.x*this.m_rB.y,d.ey.x=d.ex.y,d.ey.y=h+_+b*this.m_rA.x*this.m_rA.x+u*this.m_rB.x*this.m_rB.x,d.Inverse(),this.m_angularMass=b+u,this.m_angularMass>0&&(this.m_angularMass=1/this.m_angularMass),t.step.warmStarting){this.m_linearImpulse.Scale(t.step.dtRatio),this.m_angularImpulse*=t.step.dtRatio;const e=this.m_linearImpulse;s.SubtractScaled(h,e),i-=b*(we.b2Vec2.Cross(this.m_rA,e)+this.m_angularImpulse),n.AddScaled(_,e),r+=u*(we.b2Vec2.Cross(this.m_rB,e)+this.m_angularImpulse)}else this.m_linearImpulse.SetZero(),this.m_angularImpulse=0;t.velocities[this.m_indexA].w=i,t.velocities[this.m_indexB].w=r}SolveVelocityConstraints(t){const e=t.velocities[this.m_indexA].v;let s=t.velocities[this.m_indexA].w;const i=t.velocities[this.m_indexB].v;let o=t.velocities[this.m_indexB].w;const n=this.m_invMassA,r=this.m_invMassB,a=this.m_invIA,c=this.m_invIB,m=t.step.dt;{const t=o-s;let e=-this.m_angularMass*t;const i=this.m_angularImpulse,n=m*this.m_maxTorque;this.m_angularImpulse=(0,we.b2Clamp)(this.m_angularImpulse+e,-n,n),e=this.m_angularImpulse-i,s-=a*e,o+=c*e}{const{Cdot:t,impulse:l,oldImpulse:h}=Me;we.b2Vec2.Subtract(we.b2Vec2.AddCrossScalarVec2(i,o,this.m_rB,we.b2Vec2.s_t0),we.b2Vec2.AddCrossScalarVec2(e,s,this.m_rA,we.b2Vec2.s_t1),t),we.b2Mat22.MultiplyVec2(this.m_linearMass,t,l).Negate(),h.Copy(this.m_linearImpulse),this.m_linearImpulse.Add(l);const _=m*this.m_maxForce;this.m_linearImpulse.LengthSquared()>_*_&&(this.m_linearImpulse.Normalize(),this.m_linearImpulse.Scale(_)),we.b2Vec2.Subtract(this.m_linearImpulse,h,l),e.SubtractScaled(n,l),s-=a*we.b2Vec2.Cross(this.m_rA,l),i.AddScaled(r,l),o+=c*we.b2Vec2.Cross(this.m_rB,l)}t.velocities[this.m_indexA].w=s,t.velocities[this.m_indexB].w=o}SolvePositionConstraints(t){return!0}GetAnchorA(t){return this.m_bodyA.GetWorldPoint(this.m_localAnchorA,t)}GetAnchorB(t){return this.m_bodyB.GetWorldPoint(this.m_localAnchorB,t)}GetReactionForce(t,e){return e.x=t*this.m_linearImpulse.x,e.y=t*this.m_linearImpulse.y,e}GetReactionTorque(t){return t*this.m_angularImpulse}GetLocalAnchorA(){return this.m_localAnchorA}GetLocalAnchorB(){return this.m_localAnchorB}SetMaxForce(t){this.m_maxForce=t}GetMaxForce(){return this.m_maxForce}SetMaxTorque(t){this.m_maxTorque=t}GetMaxTorque(){return this.m_maxTorque}};var Ie={};Object.defineProperty(Ie,"__esModule",{value:!0}),Ie.b2GearJoint=Ie.b2GearJointDef=void 0;const Te=s,De=o,Ge=be,Pe={qA:new De.b2Rot,qB:new De.b2Rot,qC:new De.b2Rot,qD:new De.b2Rot,lalcA:new De.b2Vec2,lalcB:new De.b2Vec2,lalcC:new De.b2Vec2,lalcD:new De.b2Vec2,u:new De.b2Vec2,rA:new De.b2Vec2,rB:new De.b2Vec2,rC:new De.b2Vec2,rD:new De.b2Vec2,JvAC:new De.b2Vec2,JvBD:new De.b2Vec2};Ie.b2GearJointDef=class extends Ge.b2JointDef{constructor(){super(Ge.b2JointType.e_gearJoint),this.ratio=1}};Ie.b2GearJoint=class extends Ge.b2Joint{constructor(t){var e;let s,i;super(t),this.m_typeA=Ge.b2JointType.e_unknownJoint,this.m_typeB=Ge.b2JointType.e_unknownJoint,this.m_localAnchorA=new De.b2Vec2,this.m_localAnchorB=new De.b2Vec2,this.m_localAnchorC=new De.b2Vec2,this.m_localAnchorD=new De.b2Vec2,this.m_localAxisC=new De.b2Vec2,this.m_localAxisD=new De.b2Vec2,this.m_referenceAngleA=0,this.m_referenceAngleB=0,this.m_constant=0,this.m_ratio=0,this.m_impulse=0,this.m_indexA=0,this.m_indexB=0,this.m_indexC=0,this.m_indexD=0,this.m_lcA=new De.b2Vec2,this.m_lcB=new De.b2Vec2,this.m_lcC=new De.b2Vec2,this.m_lcD=new De.b2Vec2,this.m_mA=0,this.m_mB=0,this.m_mC=0,this.m_mD=0,this.m_iA=0,this.m_iB=0,this.m_iC=0,this.m_iD=0,this.m_JvAC=new De.b2Vec2,this.m_JvBD=new De.b2Vec2,this.m_JwA=0,this.m_JwB=0,this.m_JwC=0,this.m_JwD=0,this.m_mass=0,this.m_joint1=t.joint1,this.m_joint2=t.joint2,this.m_typeA=this.m_joint1.GetType(),this.m_typeB=this.m_joint2.GetType(),this.m_bodyC=this.m_joint1.GetBodyA(),this.m_bodyA=this.m_joint1.GetBodyB();const o=this.m_bodyA.m_xf,n=this.m_bodyA.m_sweep.a,r=this.m_bodyC.m_xf,a=this.m_bodyC.m_sweep.a;if(this.m_typeA===Ge.b2JointType.e_revoluteJoint){const e=t.joint1;this.m_localAnchorC.Copy(e.m_localAnchorA),this.m_localAnchorA.Copy(e.m_localAnchorB),this.m_referenceAngleA=e.m_referenceAngle,this.m_localAxisC.SetZero(),s=n-a-this.m_referenceAngleA}else{const e=t.joint1;this.m_localAnchorC.Copy(e.m_localAnchorA),this.m_localAnchorA.Copy(e.m_localAnchorB),this.m_referenceAngleA=e.m_referenceAngle,this.m_localAxisC.Copy(e.m_localXAxisA);const i=this.m_localAnchorC,n=De.b2Rot.TransposeMultiplyVec2(r.q,De.b2Rot.MultiplyVec2(o.q,this.m_localAnchorA,De.b2Vec2.s_t0).Add(o.p).Subtract(r.p),De.b2Vec2.s_t0);s=De.b2Vec2.Dot(n.Subtract(i),this.m_localAxisC)}this.m_bodyD=this.m_joint2.GetBodyA(),this.m_bodyB=this.m_joint2.GetBodyB();const c=this.m_bodyB.m_xf,m=this.m_bodyB.m_sweep.a,l=this.m_bodyD.m_xf,h=this.m_bodyD.m_sweep.a;if(this.m_typeB===Ge.b2JointType.e_revoluteJoint){const e=t.joint2;this.m_localAnchorD.Copy(e.m_localAnchorA),this.m_localAnchorB.Copy(e.m_localAnchorB),this.m_referenceAngleB=e.m_referenceAngle,this.m_localAxisD.SetZero(),i=m-h-this.m_referenceAngleB}else{const e=t.joint2;this.m_localAnchorD.Copy(e.m_localAnchorA),this.m_localAnchorB.Copy(e.m_localAnchorB),this.m_referenceAngleB=e.m_referenceAngle,this.m_localAxisD.Copy(e.m_localXAxisA);const s=this.m_localAnchorD,o=De.b2Rot.TransposeMultiplyVec2(l.q,De.b2Rot.MultiplyVec2(c.q,this.m_localAnchorB,De.b2Vec2.s_t0).Add(c.p).Subtract(l.p),De.b2Vec2.s_t0);i=De.b2Vec2.Dot(o.Subtract(s),this.m_localAxisD)}this.m_ratio=null!==(e=t.ratio)&&void 0!==e?e:1,this.m_constant=s+this.m_ratio*i,this.m_impulse=0}InitVelocityConstraints(t){this.m_indexA=this.m_bodyA.m_islandIndex,this.m_indexB=this.m_bodyB.m_islandIndex,this.m_indexC=this.m_bodyC.m_islandIndex,this.m_indexD=this.m_bodyD.m_islandIndex,this.m_lcA.Copy(this.m_bodyA.m_sweep.localCenter),this.m_lcB.Copy(this.m_bodyB.m_sweep.localCenter),this.m_lcC.Copy(this.m_bodyC.m_sweep.localCenter),this.m_lcD.Copy(this.m_bodyD.m_sweep.localCenter),this.m_mA=this.m_bodyA.m_invMass,this.m_mB=this.m_bodyB.m_invMass,this.m_mC=this.m_bodyC.m_invMass,this.m_mD=this.m_bodyD.m_invMass,this.m_iA=this.m_bodyA.m_invI,this.m_iB=this.m_bodyB.m_invI,this.m_iC=this.m_bodyC.m_invI,this.m_iD=this.m_bodyD.m_invI;const e=t.positions[this.m_indexA].a,s=t.velocities[this.m_indexA].v;let i=t.velocities[this.m_indexA].w;const o=t.positions[this.m_indexB].a,n=t.velocities[this.m_indexB].v;let r=t.velocities[this.m_indexB].w;const a=t.positions[this.m_indexC].a,c=t.velocities[this.m_indexC].v;let m=t.velocities[this.m_indexC].w;const l=t.positions[this.m_indexD].a,h=t.velocities[this.m_indexD].v;let _=t.velocities[this.m_indexD].w;const{qA:b,qB:u,qC:d,qD:p}=Pe;if(b.Set(e),u.Set(o),d.Set(a),p.Set(l),this.m_mass=0,this.m_typeA===Ge.b2JointType.e_revoluteJoint)this.m_JvAC.SetZero(),this.m_JwA=1,this.m_JwC=1,this.m_mass+=this.m_iA+this.m_iC;else{const{u:t,rC:e,rA:s,lalcA:i,lalcC:o}=Pe;De.b2Rot.MultiplyVec2(d,this.m_localAxisC,t),De.b2Rot.MultiplyVec2(d,De.b2Vec2.Subtract(this.m_localAnchorC,this.m_lcC,o),e),De.b2Rot.MultiplyVec2(b,De.b2Vec2.Subtract(this.m_localAnchorA,this.m_lcA,i),s),this.m_JvAC.Copy(t),this.m_JwC=De.b2Vec2.Cross(e,t),this.m_JwA=De.b2Vec2.Cross(s,t),this.m_mass+=this.m_mC+this.m_mA+this.m_iC*this.m_JwC*this.m_JwC+this.m_iA*this.m_JwA*this.m_JwA}if(this.m_typeB===Ge.b2JointType.e_revoluteJoint)this.m_JvBD.SetZero(),this.m_JwB=this.m_ratio,this.m_JwD=this.m_ratio,this.m_mass+=this.m_ratio*this.m_ratio*(this.m_iB+this.m_iD);else{const{u:t,rB:e,rD:s,lalcB:i,lalcD:o}=Pe;De.b2Rot.MultiplyVec2(p,this.m_localAxisD,t),De.b2Rot.MultiplyVec2(p,De.b2Vec2.Subtract(this.m_localAnchorD,this.m_lcD,o),s),De.b2Rot.MultiplyVec2(u,De.b2Vec2.Subtract(this.m_localAnchorB,this.m_lcB,i),e),De.b2Vec2.Scale(this.m_ratio,t,this.m_JvBD),this.m_JwD=this.m_ratio*De.b2Vec2.Cross(s,t),this.m_JwB=this.m_ratio*De.b2Vec2.Cross(e,t),this.m_mass+=this.m_ratio*this.m_ratio*(this.m_mD+this.m_mB)+this.m_iD*this.m_JwD*this.m_JwD+this.m_iB*this.m_JwB*this.m_JwB}this.m_mass=this.m_mass>0?1/this.m_mass:0,t.step.warmStarting?(s.AddScaled(this.m_mA*this.m_impulse,this.m_JvAC),i+=this.m_iA*this.m_impulse*this.m_JwA,n.AddScaled(this.m_mB*this.m_impulse,this.m_JvBD),r+=this.m_iB*this.m_impulse*this.m_JwB,c.SubtractScaled(this.m_mC*this.m_impulse,this.m_JvAC),m-=this.m_iC*this.m_impulse*this.m_JwC,h.SubtractScaled(this.m_mD*this.m_impulse,this.m_JvBD),_-=this.m_iD*this.m_impulse*this.m_JwD):this.m_impulse=0,t.velocities[this.m_indexA].w=i,t.velocities[this.m_indexB].w=r,t.velocities[this.m_indexC].w=m,t.velocities[this.m_indexD].w=_}SolveVelocityConstraints(t){const e=t.velocities[this.m_indexA].v;let s=t.velocities[this.m_indexA].w;const i=t.velocities[this.m_indexB].v;let o=t.velocities[this.m_indexB].w;const n=t.velocities[this.m_indexC].v;let r=t.velocities[this.m_indexC].w;const a=t.velocities[this.m_indexD].v;let c=t.velocities[this.m_indexD].w,m=De.b2Vec2.Dot(this.m_JvAC,De.b2Vec2.Subtract(e,n,De.b2Vec2.s_t0))+De.b2Vec2.Dot(this.m_JvBD,De.b2Vec2.Subtract(i,a,De.b2Vec2.s_t0));m+=this.m_JwA*s-this.m_JwC*r+(this.m_JwB*o-this.m_JwD*c);const l=-this.m_mass*m;this.m_impulse+=l,e.AddScaled(this.m_mA*l,this.m_JvAC),s+=this.m_iA*l*this.m_JwA,i.AddScaled(this.m_mB*l,this.m_JvBD),o+=this.m_iB*l*this.m_JwB,n.SubtractScaled(this.m_mC*l,this.m_JvAC),r-=this.m_iC*l*this.m_JwC,a.SubtractScaled(this.m_mD*l,this.m_JvBD),c-=this.m_iD*l*this.m_JwD,t.velocities[this.m_indexA].w=s,t.velocities[this.m_indexB].w=o,t.velocities[this.m_indexC].w=r,t.velocities[this.m_indexD].w=c}SolvePositionConstraints(t){const e=t.positions[this.m_indexA].c;let s=t.positions[this.m_indexA].a;const i=t.positions[this.m_indexB].c;let o=t.positions[this.m_indexB].a;const n=t.positions[this.m_indexC].c;let r=t.positions[this.m_indexC].a;const a=t.positions[this.m_indexD].c;let c=t.positions[this.m_indexD].a;const{qA:m,qB:l,qC:h,qD:_,JvAC:b,JvBD:u}=Pe;m.Set(s),l.Set(o),h.Set(r),_.Set(c);let d,p,y,A,x,V,S=0;if(this.m_typeA===Ge.b2JointType.e_revoluteJoint)b.SetZero(),y=1,x=1,S+=this.m_iA+this.m_iC,d=s-r-this.m_referenceAngleA;else{const{u:t,rC:s,rA:i,lalcC:o,lalcA:r}=Pe;De.b2Rot.MultiplyVec2(h,this.m_localAxisC,t),De.b2Rot.MultiplyVec2(h,De.b2Vec2.Subtract(this.m_localAnchorC,this.m_lcC,o),s),De.b2Rot.MultiplyVec2(m,De.b2Vec2.Subtract(this.m_localAnchorA,this.m_lcA,r),i),b.Copy(t),x=De.b2Vec2.Cross(s,t),y=De.b2Vec2.Cross(i,t),S+=this.m_mC+this.m_mA+this.m_iC*x*x+this.m_iA*y*y;const a=o,c=De.b2Rot.TransposeMultiplyVec2(h,De.b2Vec2.Add(i,e,De.b2Vec2.s_t0).Subtract(n),De.b2Vec2.s_t0);d=De.b2Vec2.Dot(De.b2Vec2.Subtract(c,a,De.b2Vec2.s_t0),this.m_localAxisC)}if(this.m_typeB===Ge.b2JointType.e_revoluteJoint)u.SetZero(),A=this.m_ratio,V=this.m_ratio,S+=this.m_ratio*this.m_ratio*(this.m_iB+this.m_iD),p=o-c-this.m_referenceAngleB;else{const{u:t,rD:e,rB:s,lalcD:o,lalcB:n}=Pe;De.b2Rot.MultiplyVec2(_,this.m_localAxisD,t),De.b2Rot.MultiplyVec2(_,De.b2Vec2.Subtract(this.m_localAnchorD,this.m_lcD,o),e),De.b2Rot.MultiplyVec2(l,De.b2Vec2.Subtract(this.m_localAnchorB,this.m_lcB,n),s),De.b2Vec2.Scale(this.m_ratio,t,u),V=this.m_ratio*De.b2Vec2.Cross(e,t),A=this.m_ratio*De.b2Vec2.Cross(s,t),S+=this.m_ratio*this.m_ratio*(this.m_mD+this.m_mB)+this.m_iD*V*V+this.m_iB*A*A;const r=o,c=De.b2Rot.TransposeMultiplyVec2(_,De.b2Vec2.Add(s,i,De.b2Vec2.s_t0).Subtract(a),De.b2Vec2.s_t0);p=De.b2Vec2.Dot(c.Subtract(r),this.m_localAxisD)}const v=d+this.m_ratio*p-this.m_constant;let f=0;return S>0&&(f=-v/S),e.AddScaled(this.m_mA*f,b),s+=this.m_iA*f*y,i.AddScaled(this.m_mB*f,u),o+=this.m_iB*f*A,n.SubtractScaled(this.m_mC*f,b),r-=this.m_iC*f*x,a.SubtractScaled(this.m_mD*f,u),c-=this.m_iD*f*V,t.positions[this.m_indexA].a=s,t.positions[this.m_indexB].a=o,t.positions[this.m_indexC].a=r,t.positions[this.m_indexD].a=c,0<Te.b2_linearSlop}GetAnchorA(t){return this.m_bodyA.GetWorldPoint(this.m_localAnchorA,t)}GetAnchorB(t){return this.m_bodyB.GetWorldPoint(this.m_localAnchorB,t)}GetReactionForce(t,e){return De.b2Vec2.Scale(t*this.m_impulse,this.m_JvAC,e)}GetReactionTorque(t){return t*this.m_impulse*this.m_JwA}GetJoint1(){return this.m_joint1}GetJoint2(){return this.m_joint2}GetRatio(){return this.m_ratio}SetRatio(t){this.m_ratio=t}};var Re={};Object.defineProperty(Re,"__esModule",{value:!0}),Re.b2MotorJoint=Re.b2MotorJointDef=void 0;const Le=o,Fe=be,Je={qA:new Le.b2Rot,qB:new Le.b2Rot,K:new Le.b2Mat22,Cdot:new Le.b2Vec2,impulse:new Le.b2Vec2,oldImpulse:new Le.b2Vec2};Re.b2MotorJointDef=class extends Fe.b2JointDef{constructor(){super(Fe.b2JointType.e_motorJoint),this.linearOffset=new Le.b2Vec2,this.angularOffset=0,this.maxForce=1,this.maxTorque=1,this.correctionFactor=.3}Initialize(t,e){this.bodyA=t,this.bodyB=e,this.bodyA.GetLocalPoint(e.GetPosition(),this.linearOffset);const s=t.GetAngle(),i=e.GetAngle();this.angularOffset=i-s}};Re.b2MotorJoint=class extends Fe.b2Joint{constructor(t){var e,s,i,o,n;super(t),this.m_linearOffset=new Le.b2Vec2,this.m_linearImpulse=new Le.b2Vec2,this.m_angularImpulse=0,this.m_indexA=0,this.m_indexB=0,this.m_rA=new Le.b2Vec2,this.m_rB=new Le.b2Vec2,this.m_localCenterA=new Le.b2Vec2,this.m_localCenterB=new Le.b2Vec2,this.m_linearError=new Le.b2Vec2,this.m_angularError=0,this.m_invMassA=0,this.m_invMassB=0,this.m_invIA=0,this.m_invIB=0,this.m_linearMass=new Le.b2Mat22,this.m_angularMass=0,this.m_linearOffset.Copy(null!==(e=t.linearOffset)&&void 0!==e?e:Le.b2Vec2.ZERO),this.m_angularOffset=null!==(s=t.angularOffset)&&void 0!==s?s:0,this.m_linearImpulse.SetZero(),this.m_maxForce=null!==(i=t.maxForce)&&void 0!==i?i:1,this.m_maxTorque=null!==(o=t.maxTorque)&&void 0!==o?o:1,this.m_correctionFactor=null!==(n=t.correctionFactor)&&void 0!==n?n:.3}GetAnchorA(t){const e=this.m_bodyA.GetPosition();return t.x=e.x,t.y=e.y,t}GetAnchorB(t){const e=this.m_bodyB.GetPosition();return t.x=e.x,t.y=e.y,t}GetReactionForce(t,e){return Le.b2Vec2.Scale(t,this.m_linearImpulse,e)}GetReactionTorque(t){return t*this.m_angularImpulse}SetLinearOffset(t){Le.b2Vec2.Equals(t,this.m_linearOffset)||(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_linearOffset.Copy(t))}GetLinearOffset(){return this.m_linearOffset}SetAngularOffset(t){t!==this.m_angularOffset&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_angularOffset=t)}GetAngularOffset(){return this.m_angularOffset}SetMaxForce(t){this.m_maxForce=t}GetMaxForce(){return this.m_maxForce}SetMaxTorque(t){this.m_maxTorque=t}GetMaxTorque(){return this.m_maxTorque}GetCorrectionFactor(){return this.m_correctionFactor}SetCorrectionFactor(t){this.m_correctionFactor=t}InitVelocityConstraints(t){this.m_indexA=this.m_bodyA.m_islandIndex,this.m_indexB=this.m_bodyB.m_islandIndex,this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter),this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter),this.m_invMassA=this.m_bodyA.m_invMass,this.m_invMassB=this.m_bodyB.m_invMass,this.m_invIA=this.m_bodyA.m_invI,this.m_invIB=this.m_bodyB.m_invI;const e=t.positions[this.m_indexA].c,s=t.positions[this.m_indexA].a,i=t.velocities[this.m_indexA].v;let o=t.velocities[this.m_indexA].w;const n=t.positions[this.m_indexB].c,r=t.positions[this.m_indexB].a,a=t.velocities[this.m_indexB].v;let c=t.velocities[this.m_indexB].w;const{qA:m,qB:l}=Je;m.Set(s),l.Set(r);const h=Le.b2Rot.MultiplyVec2(m,Le.b2Vec2.Subtract(this.m_linearOffset,this.m_localCenterA,Le.b2Vec2.s_t0),this.m_rA),_=Le.b2Rot.MultiplyVec2(l,Le.b2Vec2.Negate(this.m_localCenterB,Le.b2Vec2.s_t0),this.m_rB),b=this.m_invMassA,u=this.m_invMassB,d=this.m_invIA,p=this.m_invIB,y=this.m_linearMass;if(y.ex.x=b+u+d*h.y*h.y+p*_.y*_.y,y.ex.y=-d*h.x*h.y-p*_.x*_.y,y.ey.x=y.ex.y,y.ey.y=b+u+d*h.x*h.x+p*_.x*_.x,y.Inverse(),this.m_angularMass=d+p,this.m_angularMass>0&&(this.m_angularMass=1/this.m_angularMass),Le.b2Vec2.Subtract(Le.b2Vec2.Add(n,_,Le.b2Vec2.s_t0),Le.b2Vec2.Add(e,h,Le.b2Vec2.s_t1),this.m_linearError),this.m_angularError=r-s-this.m_angularOffset,t.step.warmStarting){this.m_linearImpulse.Scale(t.step.dtRatio),this.m_angularImpulse*=t.step.dtRatio;const e=this.m_linearImpulse;i.SubtractScaled(b,e),o-=d*(Le.b2Vec2.Cross(h,e)+this.m_angularImpulse),a.AddScaled(u,e),c+=p*(Le.b2Vec2.Cross(_,e)+this.m_angularImpulse)}else this.m_linearImpulse.SetZero(),this.m_angularImpulse=0;t.velocities[this.m_indexA].w=o,t.velocities[this.m_indexB].w=c}SolveVelocityConstraints(t){const e=t.velocities[this.m_indexA].v;let s=t.velocities[this.m_indexA].w;const i=t.velocities[this.m_indexB].v;let o=t.velocities[this.m_indexB].w;const n=this.m_invMassA,r=this.m_invMassB,a=this.m_invIA,c=this.m_invIB,m=t.step.dt,l=t.step.inv_dt;{const t=o-s+l*this.m_correctionFactor*this.m_angularError;let e=-this.m_angularMass*t;const i=this.m_angularImpulse,n=m*this.m_maxTorque;this.m_angularImpulse=(0,Le.b2Clamp)(this.m_angularImpulse+e,-n,n),e=this.m_angularImpulse-i,s-=a*e,o+=c*e}{const{impulse:t,oldImpulse:h,Cdot:_}=Je;Le.b2Vec2.AddScaled(Le.b2Vec2.Subtract(Le.b2Vec2.AddCrossScalarVec2(i,o,this.m_rB,Le.b2Vec2.s_t0),Le.b2Vec2.AddCrossScalarVec2(e,s,this.m_rA,Le.b2Vec2.s_t1),Le.b2Vec2.s_t2),l*this.m_correctionFactor,this.m_linearError,_),Le.b2Mat22.MultiplyVec2(this.m_linearMass,_,t).Negate(),h.Copy(this.m_linearImpulse),this.m_linearImpulse.Add(t);const b=m*this.m_maxForce;this.m_linearImpulse.LengthSquared()>b*b&&(this.m_linearImpulse.Normalize(),this.m_linearImpulse.Scale(b)),Le.b2Vec2.Subtract(this.m_linearImpulse,h,t),e.SubtractScaled(n,t),s-=a*Le.b2Vec2.Cross(this.m_rA,t),i.AddScaled(r,t),o+=c*Le.b2Vec2.Cross(this.m_rB,t)}t.velocities[this.m_indexA].w=s,t.velocities[this.m_indexB].w=o}SolvePositionConstraints(t){return!0}};var ke={};Object.defineProperty(ke,"__esModule",{value:!0}),ke.b2MouseJoint=ke.b2MouseJointDef=void 0;const qe=n,Oe=o,ze=be,je={qB:new Oe.b2Rot,lalcB:new Oe.b2Vec2,Cdot:new Oe.b2Vec2,impulse:new Oe.b2Vec2,oldImpulse:new Oe.b2Vec2,pA:new Oe.b2Vec2,pB:new Oe.b2Vec2};ke.b2MouseJointDef=class extends ze.b2JointDef{constructor(){super(ze.b2JointType.e_mouseJoint),this.target=new Oe.b2Vec2,this.maxForce=0,this.stiffness=0,this.damping=0}};ke.b2MouseJoint=class extends ze.b2Joint{constructor(t){var e,s,i,o;super(t),this.m_localAnchorB=new Oe.b2Vec2,this.m_targetA=new Oe.b2Vec2,this.m_stiffness=0,this.m_damping=0,this.m_beta=0,this.m_impulse=new Oe.b2Vec2,this.m_maxForce=0,this.m_gamma=0,this.m_indexB=0,this.m_rB=new Oe.b2Vec2,this.m_localCenterB=new Oe.b2Vec2,this.m_invMassB=0,this.m_invIB=0,this.m_mass=new Oe.b2Mat22,this.m_C=new Oe.b2Vec2,this.m_targetA.Copy(null!==(e=t.target)&&void 0!==e?e:Oe.b2Vec2.ZERO),Oe.b2Transform.TransposeMultiplyVec2(this.m_bodyB.GetTransform(),this.m_targetA,this.m_localAnchorB),this.m_maxForce=null!==(s=t.maxForce)&&void 0!==s?s:0,this.m_stiffness=null!==(i=t.stiffness)&&void 0!==i?i:0,this.m_damping=null!==(o=t.damping)&&void 0!==o?o:0,this.m_beta=0,this.m_gamma=0}SetTarget(t){Oe.b2Vec2.Equals(t,this.m_targetA)||(this.m_bodyB.SetAwake(!0),this.m_targetA.Copy(t))}GetTarget(){return this.m_targetA}SetMaxForce(t){this.m_maxForce=t}GetMaxForce(){return this.m_maxForce}SetStiffness(t){this.m_stiffness=t}GetStiffness(){return this.m_stiffness}SetDamping(t){this.m_damping=t}GetDamping(){return this.m_damping}InitVelocityConstraints(t){this.m_indexB=this.m_bodyB.m_islandIndex,this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter),this.m_invMassB=this.m_bodyB.m_invMass,this.m_invIB=this.m_bodyB.m_invI;const e=t.positions[this.m_indexB].c,s=t.positions[this.m_indexB].a,i=t.velocities[this.m_indexB].v;let o=t.velocities[this.m_indexB].w;const{qB:n,lalcB:r}=je;n.Set(s);const a=this.m_damping,c=this.m_stiffness,m=t.step.dt;this.m_gamma=m*(a+m*c),0!==this.m_gamma&&(this.m_gamma=1/this.m_gamma),this.m_beta=m*c*this.m_gamma,Oe.b2Rot.MultiplyVec2(n,Oe.b2Vec2.Subtract(this.m_localAnchorB,this.m_localCenterB,r),this.m_rB);const l=this.m_mass;l.ex.x=this.m_invMassB+this.m_invIB*this.m_rB.y*this.m_rB.y+this.m_gamma,l.ex.y=-this.m_invIB*this.m_rB.x*this.m_rB.y,l.ey.x=l.ex.y,l.ey.y=this.m_invMassB+this.m_invIB*this.m_rB.x*this.m_rB.x+this.m_gamma,l.Inverse(),Oe.b2Vec2.Add(e,this.m_rB,this.m_C).Subtract(this.m_targetA),this.m_C.Scale(this.m_beta),o*=.98,t.step.warmStarting?(this.m_impulse.Scale(t.step.dtRatio),i.AddScaled(this.m_invMassB,this.m_impulse),o+=this.m_invIB*Oe.b2Vec2.Cross(this.m_rB,this.m_impulse)):this.m_impulse.SetZero(),t.velocities[this.m_indexB].w=o}SolveVelocityConstraints(t){const e=t.velocities[this.m_indexB].v;let s=t.velocities[this.m_indexB].w;const{Cdot:i,impulse:o,oldImpulse:n}=je;Oe.b2Vec2.AddCrossScalarVec2(e,s,this.m_rB,i),Oe.b2Mat22.MultiplyVec2(this.m_mass,Oe.b2Vec2.Add(i,this.m_C,o).AddScaled(this.m_gamma,this.m_impulse).Negate(),o),n.Copy(this.m_impulse),this.m_impulse.Add(o);const r=t.step.dt*this.m_maxForce;this.m_impulse.LengthSquared()>r*r&&this.m_impulse.Scale(r/this.m_impulse.Length()),Oe.b2Vec2.Subtract(this.m_impulse,n,o),e.AddScaled(this.m_invMassB,o),s+=this.m_invIB*Oe.b2Vec2.Cross(this.m_rB,o),t.velocities[this.m_indexB].w=s}SolvePositionConstraints(t){return!0}GetAnchorA(t){return t.x=this.m_targetA.x,t.y=this.m_targetA.y,t}GetAnchorB(t){return this.m_bodyB.GetWorldPoint(this.m_localAnchorB,t)}GetReactionForce(t,e){return Oe.b2Vec2.Scale(t,this.m_impulse,e)}GetReactionTorque(t){return 0}ShiftOrigin(t){this.m_targetA.Subtract(t)}Draw(t){const e=this.GetAnchorA(je.pA),s=this.GetAnchorB(je.pB);t.DrawPoint(e,4,qe.debugColors.joint7),t.DrawPoint(s,4,qe.debugColors.joint7),t.DrawSegment(e,s,qe.debugColors.joint8)}};var Ne={};Object.defineProperty(Ne,"__esModule",{value:!0}),Ne.b2PrismaticJoint=Ne.b2PrismaticJointDef=void 0;const Ee=s,Ze=n,We=o,Xe=be,Ue={K3:new We.b2Mat33,K2:new We.b2Mat22,qA:new We.b2Rot,qB:new We.b2Rot,lalcA:new We.b2Vec2,lalcB:new We.b2Vec2,rA:new We.b2Vec2,rB:new We.b2Vec2,GetJointTranslation:{pA:new We.b2Vec2,pB:new We.b2Vec2,d:new We.b2Vec2,axis:new We.b2Vec2},InitVelocityConstraints:{d:new We.b2Vec2,P:new We.b2Vec2},SolveVelocityConstraints:{P:new We.b2Vec2,df:new We.b2Vec2},SolvePositionConstraints:{d:new We.b2Vec2,impulse:new We.b2Vec3,impulse1:new We.b2Vec2,P:new We.b2Vec2},Draw:{p1:new We.b2Vec2,p2:new We.b2Vec2,pA:new We.b2Vec2,pB:new We.b2Vec2,axis:new We.b2Vec2,lower:new We.b2Vec2,upper:new We.b2Vec2,perp:new We.b2Vec2}};Ne.b2PrismaticJointDef=class extends Xe.b2JointDef{constructor(){super(Xe.b2JointType.e_prismaticJoint),this.localAnchorA=new We.b2Vec2,this.localAnchorB=new We.b2Vec2,this.localAxisA=new We.b2Vec2(1,0),this.referenceAngle=0,this.enableLimit=!1,this.lowerTranslation=0,this.upperTranslation=0,this.enableMotor=!1,this.maxMotorForce=0,this.motorSpeed=0}Initialize(t,e,s,i){this.bodyA=t,this.bodyB=e,this.bodyA.GetLocalPoint(s,this.localAnchorA),this.bodyB.GetLocalPoint(s,this.localAnchorB),this.bodyA.GetLocalVector(i,this.localAxisA),this.referenceAngle=this.bodyB.GetAngle()-this.bodyA.GetAngle()}};Ne.b2PrismaticJoint=class extends Xe.b2Joint{constructor(t){var e,s,i,o,n,r,a,c,m,l;super(t),this.m_localAnchorA=new We.b2Vec2,this.m_localAnchorB=new We.b2Vec2,this.m_localXAxisA=new We.b2Vec2,this.m_localYAxisA=new We.b2Vec2,this.m_referenceAngle=0,this.m_impulse=new We.b2Vec2,this.m_motorImpulse=0,this.m_lowerImpulse=0,this.m_upperImpulse=0,this.m_lowerTranslation=0,this.m_upperTranslation=0,this.m_maxMotorForce=0,this.m_motorSpeed=0,this.m_enableLimit=!1,this.m_enableMotor=!1,this.m_indexA=0,this.m_indexB=0,this.m_localCenterA=new We.b2Vec2,this.m_localCenterB=new We.b2Vec2,this.m_invMassA=0,this.m_invMassB=0,this.m_invIA=0,this.m_invIB=0,this.m_axis=new We.b2Vec2,this.m_perp=new We.b2Vec2,this.m_s1=0,this.m_s2=0,this.m_a1=0,this.m_a2=0,this.m_K=new We.b2Mat22,this.m_translation=0,this.m_axialMass=0,this.m_localAnchorA.Copy(null!==(e=t.localAnchorA)&&void 0!==e?e:We.b2Vec2.ZERO),this.m_localAnchorB.Copy(null!==(s=t.localAnchorB)&&void 0!==s?s:We.b2Vec2.ZERO),We.b2Vec2.Normalize(null!==(i=t.localAxisA)&&void 0!==i?i:We.b2Vec2.UNITX,this.m_localXAxisA),We.b2Vec2.CrossOneVec2(this.m_localXAxisA,this.m_localYAxisA),this.m_referenceAngle=null!==(o=t.referenceAngle)&&void 0!==o?o:0,this.m_lowerTranslation=null!==(n=t.lowerTranslation)&&void 0!==n?n:0,this.m_upperTranslation=null!==(r=t.upperTranslation)&&void 0!==r?r:0,this.m_maxMotorForce=null!==(a=t.maxMotorForce)&&void 0!==a?a:0,this.m_motorSpeed=null!==(c=t.motorSpeed)&&void 0!==c?c:0,this.m_enableLimit=null!==(m=t.enableLimit)&&void 0!==m&&m,this.m_enableMotor=null!==(l=t.enableMotor)&&void 0!==l&&l}InitVelocityConstraints(t){this.m_indexA=this.m_bodyA.m_islandIndex,this.m_indexB=this.m_bodyB.m_islandIndex,this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter),this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter),this.m_invMassA=this.m_bodyA.m_invMass,this.m_invMassB=this.m_bodyB.m_invMass,this.m_invIA=this.m_bodyA.m_invI,this.m_invIB=this.m_bodyB.m_invI;const e=t.positions[this.m_indexA].c,s=t.positions[this.m_indexA].a,i=t.velocities[this.m_indexA].v;let o=t.velocities[this.m_indexA].w;const n=t.positions[this.m_indexB].c,r=t.positions[this.m_indexB].a,a=t.velocities[this.m_indexB].v;let c=t.velocities[this.m_indexB].w;const{qA:m,qB:l,lalcA:h,lalcB:_,rA:b,rB:u}=Ue;m.Set(s),l.Set(r),We.b2Rot.MultiplyVec2(m,We.b2Vec2.Subtract(this.m_localAnchorA,this.m_localCenterA,h),b),We.b2Rot.MultiplyVec2(l,We.b2Vec2.Subtract(this.m_localAnchorB,this.m_localCenterB,_),u);const d=We.b2Vec2.Subtract(n,e,Ue.InitVelocityConstraints.d).Add(u).Subtract(b),p=this.m_invMassA,y=this.m_invMassB,A=this.m_invIA,x=this.m_invIB;We.b2Rot.MultiplyVec2(m,this.m_localXAxisA,this.m_axis),this.m_a1=We.b2Vec2.Cross(We.b2Vec2.Add(d,b,We.b2Vec2.s_t0),this.m_axis),this.m_a2=We.b2Vec2.Cross(u,this.m_axis),this.m_axialMass=p+y+A*this.m_a1*this.m_a1+x*this.m_a2*this.m_a2,this.m_axialMass>0&&(this.m_axialMass=1/this.m_axialMass),We.b2Rot.MultiplyVec2(m,this.m_localYAxisA,this.m_perp),this.m_s1=We.b2Vec2.Cross(We.b2Vec2.Add(d,b,We.b2Vec2.s_t0),this.m_perp),this.m_s2=We.b2Vec2.Cross(u,this.m_perp);const V=p+y+A*this.m_s1*this.m_s1+x*this.m_s2*this.m_s2,S=A*this.m_s1+x*this.m_s2;let v=A+x;if(0===v&&(v=1),this.m_K.ex.Set(V,S),this.m_K.ey.Set(S,v),this.m_enableLimit?this.m_translation=We.b2Vec2.Dot(this.m_axis,d):(this.m_lowerImpulse=0,this.m_upperImpulse=0),this.m_enableMotor||(this.m_motorImpulse=0),t.step.warmStarting){this.m_impulse.Scale(t.step.dtRatio),this.m_motorImpulse*=t.step.dtRatio,this.m_lowerImpulse*=t.step.dtRatio,this.m_upperImpulse*=t.step.dtRatio;const e=this.m_motorImpulse+this.m_lowerImpulse-this.m_upperImpulse,{P:s}=Ue.InitVelocityConstraints;We.b2Vec2.Scale(this.m_impulse.x,this.m_perp,s).AddScaled(e,this.m_axis);const n=this.m_impulse.x*this.m_s1+this.m_impulse.y+e*this.m_a1,r=this.m_impulse.x*this.m_s2+this.m_impulse.y+e*this.m_a2;i.SubtractScaled(p,s),o-=A*n,a.AddScaled(y,s),c+=x*r}else this.m_impulse.SetZero(),this.m_motorImpulse=0,this.m_lowerImpulse=0,this.m_upperImpulse=0;t.velocities[this.m_indexA].w=o,t.velocities[this.m_indexB].w=c}SolveVelocityConstraints(t){const e=t.velocities[this.m_indexA].v;let s=t.velocities[this.m_indexA].w;const i=t.velocities[this.m_indexB].v;let o=t.velocities[this.m_indexB].w;const n=this.m_invMassA,r=this.m_invMassB,a=this.m_invIA,c=this.m_invIB,{P:m,df:l}=Ue.SolveVelocityConstraints;if(this.m_enableMotor){const l=We.b2Vec2.Dot(this.m_axis,We.b2Vec2.Subtract(i,e,We.b2Vec2.s_t0))+this.m_a2*o-this.m_a1*s;let h=this.m_axialMass*(this.m_motorSpeed-l);const _=this.m_motorImpulse,b=t.step.dt*this.m_maxMotorForce;this.m_motorImpulse=(0,We.b2Clamp)(this.m_motorImpulse+h,-b,b),h=this.m_motorImpulse-_,We.b2Vec2.Scale(h,this.m_axis,m);const u=h*this.m_a1,d=h*this.m_a2;e.SubtractScaled(n,m),s-=a*u,i.AddScaled(r,m),o+=c*d}if(this.m_enableLimit){{const l=this.m_translation-this.m_lowerTranslation,h=We.b2Vec2.Dot(this.m_axis,We.b2Vec2.Subtract(i,e,We.b2Vec2.s_t0))+this.m_a2*o-this.m_a1*s;let _=-this.m_axialMass*(h+Math.max(l,0)*t.step.inv_dt);const b=this.m_lowerImpulse;this.m_lowerImpulse=Math.max(this.m_lowerImpulse+_,0),_=this.m_lowerImpulse-b,We.b2Vec2.Scale(_,this.m_axis,m);const u=_*this.m_a1,d=_*this.m_a2;e.SubtractScaled(n,m),s-=a*u,i.AddScaled(r,m),o+=c*d}{const l=this.m_upperTranslation-this.m_translation,h=We.b2Vec2.Dot(this.m_axis,We.b2Vec2.Subtract(e,i,We.b2Vec2.s_t0))+this.m_a1*s-this.m_a2*o;let _=-this.m_axialMass*(h+Math.max(l,0)*t.step.inv_dt);const b=this.m_upperImpulse;this.m_upperImpulse=Math.max(this.m_upperImpulse+_,0),_=this.m_upperImpulse-b,We.b2Vec2.Scale(_,this.m_axis,m);const u=_*this.m_a1,d=_*this.m_a2;e.AddScaled(n,m),s+=a*u,i.SubtractScaled(r,m),o-=c*d}}{const t=We.b2Vec2.Dot(this.m_perp,We.b2Vec2.Subtract(i,e,We.b2Vec2.s_t0))+this.m_s2*o-this.m_s1*s,h=o-s;this.m_K.Solve(-t,-h,l),this.m_impulse.Add(l),We.b2Vec2.Scale(l.x,this.m_perp,m);const _=l.x*this.m_s1+l.y,b=l.x*this.m_s2+l.y;e.SubtractScaled(n,m),s-=a*_,i.AddScaled(r,m),o+=c*b}t.velocities[this.m_indexA].w=s,t.velocities[this.m_indexB].w=o}SolvePositionConstraints(t){const e=t.positions[this.m_indexA].c;let s=t.positions[this.m_indexA].a;const i=t.positions[this.m_indexB].c;let o=t.positions[this.m_indexB].a;const{qA:n,qB:r,lalcA:a,lalcB:c,rA:m,rB:l}=Ue;n.Set(s),r.Set(o);const h=this.m_invMassA,_=this.m_invMassB,b=this.m_invIA,u=this.m_invIB,{d:d,impulse:p,P:y}=Ue.SolvePositionConstraints;We.b2Rot.MultiplyVec2(n,We.b2Vec2.Subtract(this.m_localAnchorA,this.m_localCenterA,a),m),We.b2Rot.MultiplyVec2(r,We.b2Vec2.Subtract(this.m_localAnchorB,this.m_localCenterB,c),l),We.b2Vec2.Add(i,l,d).Subtract(e).Subtract(m);const A=We.b2Rot.MultiplyVec2(n,this.m_localXAxisA,this.m_axis),x=We.b2Vec2.Cross(We.b2Vec2.Add(d,m,We.b2Vec2.s_t0),A),V=We.b2Vec2.Cross(l,A),S=We.b2Rot.MultiplyVec2(n,this.m_localYAxisA,this.m_perp),v=We.b2Vec2.Cross(We.b2Vec2.Add(d,m,We.b2Vec2.s_t0),S),f=We.b2Vec2.Cross(l,S),C=We.b2Vec2.Dot(S,d),B=o-s-this.m_referenceAngle;let w=Math.abs(C);const g=Math.abs(B);let M=!1,I=0;if(this.m_enableLimit){const t=We.b2Vec2.Dot(A,d);Math.abs(this.m_upperTranslation-this.m_lowerTranslation)<2*Ee.b2_linearSlop?(I=t,w=Math.max(w,Math.abs(t)),M=!0):t<=this.m_lowerTranslation?(I=Math.min(t-this.m_lowerTranslation,0),w=Math.max(w,this.m_lowerTranslation-t),M=!0):t>=this.m_upperTranslation&&(I=Math.max(t-this.m_upperTranslation,0),w=Math.max(w,t-this.m_upperTranslation),M=!0)}if(M){const t=h+_+b*v*v+u*f*f,e=b*v+u*f,s=b*v*x+u*f*V;let i=b+u;0===i&&(i=1);const o=b*x+u*V,n=h+_+b*x*x+u*V*V,r=Ue.K3;r.ex.Set(t,e,s),r.ey.Set(e,i,o),r.ez.Set(s,o,n),r.Solve33(-C,-B,-I,p)}else{const t=h+_+b*v*v+u*f*f,e=b*v+u*f;let s=b+u;0===s&&(s=1);const i=Ue.K2;i.ex.Set(t,e),i.ey.Set(e,s);const o=i.Solve(-C,-B,Ue.SolvePositionConstraints.impulse1);p.x=o.x,p.y=o.y,p.z=0}We.b2Vec2.Scale(p.x,S,y).AddScaled(p.z,A);const T=p.x*v+p.y+p.z*x,D=p.x*f+p.y+p.z*V;return e.SubtractScaled(h,y),s-=b*T,i.AddScaled(_,y),o+=u*D,t.positions[this.m_indexA].a=s,t.positions[this.m_indexB].a=o,w<=Ee.b2_linearSlop&&g<=Ee.b2_angularSlop}GetAnchorA(t){return this.m_bodyA.GetWorldPoint(this.m_localAnchorA,t)}GetAnchorB(t){return this.m_bodyB.GetWorldPoint(this.m_localAnchorB,t)}GetReactionForce(t,e){const s=this.m_motorImpulse+this.m_lowerImpulse-this.m_upperImpulse;return e.x=t*(this.m_impulse.x*this.m_perp.x+s*this.m_axis.x),e.y=t*(this.m_impulse.x*this.m_perp.y+s*this.m_axis.y),e}GetReactionTorque(t){return t*this.m_impulse.y}GetLocalAnchorA(){return this.m_localAnchorA}GetLocalAnchorB(){return this.m_localAnchorB}GetLocalAxisA(){return this.m_localXAxisA}GetReferenceAngle(){return this.m_referenceAngle}GetJointTranslation(){const{pA:t,pB:e,axis:s,d:i}=Ue.GetJointTranslation;this.m_bodyA.GetWorldPoint(this.m_localAnchorA,t),this.m_bodyB.GetWorldPoint(this.m_localAnchorB,e),We.b2Vec2.Subtract(e,t,i),this.m_bodyA.GetWorldVector(this.m_localXAxisA,s);return We.b2Vec2.Dot(i,s)}GetJointSpeed(){const t=this.m_bodyA,e=this.m_bodyB,{lalcA:s,lalcB:i,rA:o,rB:n}=Ue;We.b2Rot.MultiplyVec2(t.m_xf.q,We.b2Vec2.Subtract(this.m_localAnchorA,t.m_sweep.localCenter,s),o),We.b2Rot.MultiplyVec2(e.m_xf.q,We.b2Vec2.Subtract(this.m_localAnchorB,e.m_sweep.localCenter,i),n);const r=We.b2Vec2.Add(t.m_sweep.c,o,We.b2Vec2.s_t0),a=We.b2Vec2.Add(e.m_sweep.c,n,We.b2Vec2.s_t1),c=We.b2Vec2.Subtract(a,r,We.b2Vec2.s_t2),m=We.b2Rot.MultiplyVec2(t.m_xf.q,this.m_localXAxisA,this.m_axis),l=t.m_linearVelocity,h=e.m_linearVelocity,_=t.m_angularVelocity,b=e.m_angularVelocity;return We.b2Vec2.Dot(c,We.b2Vec2.CrossScalarVec2(_,m,We.b2Vec2.s_t0))+We.b2Vec2.Dot(m,We.b2Vec2.Subtract(We.b2Vec2.AddCrossScalarVec2(h,b,n,We.b2Vec2.s_t0),We.b2Vec2.AddCrossScalarVec2(l,_,o,We.b2Vec2.s_t1),We.b2Vec2.s_t0))}IsLimitEnabled(){return this.m_enableLimit}EnableLimit(t){return t!==this.m_enableLimit&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_enableLimit=t,this.m_lowerImpulse=0,this.m_upperImpulse=0),t}GetLowerLimit(){return this.m_lowerTranslation}GetUpperLimit(){return this.m_upperTranslation}SetLimits(t,e){t===this.m_lowerTranslation&&e===this.m_upperTranslation||(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_lowerTranslation=t,this.m_upperTranslation=e,this.m_lowerImpulse=0,this.m_upperImpulse=0)}IsMotorEnabled(){return this.m_enableMotor}EnableMotor(t){return t!==this.m_enableMotor&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_enableMotor=t),t}SetMotorSpeed(t){return t!==this.m_motorSpeed&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_motorSpeed=t),t}GetMotorSpeed(){return this.m_motorSpeed}SetMaxMotorForce(t){t!==this.m_maxMotorForce&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_maxMotorForce=t)}GetMaxMotorForce(){return this.m_maxMotorForce}GetMotorForce(t){return t*this.m_motorImpulse}Draw(t){const{p1:e,p2:s,pA:i,pB:o,axis:n}=Ue.Draw,r=this.m_bodyA.GetTransform(),a=this.m_bodyB.GetTransform();if(We.b2Transform.MultiplyVec2(r,this.m_localAnchorA,i),We.b2Transform.MultiplyVec2(a,this.m_localAnchorB,o),We.b2Rot.MultiplyVec2(r.q,this.m_localXAxisA,n),t.DrawSegment(i,o,Ze.debugColors.joint5),this.m_enableLimit){const{lower:o,upper:a,perp:c}=Ue.Draw;We.b2Vec2.AddScaled(i,this.m_lowerTranslation,n,o),We.b2Vec2.AddScaled(i,this.m_upperTranslation,n,a),We.b2Rot.MultiplyVec2(r.q,this.m_localYAxisA,c),t.DrawSegment(o,a,Ze.debugColors.joint1),t.DrawSegment(We.b2Vec2.SubtractScaled(o,.5,c,e),We.b2Vec2.AddScaled(o,.5,c,s),Ze.debugColors.joint2),t.DrawSegment(We.b2Vec2.SubtractScaled(a,.5,c,e),We.b2Vec2.AddScaled(a,.5,c,s),Ze.debugColors.joint3)}else t.DrawSegment(We.b2Vec2.Subtract(i,n,e),We.b2Vec2.Add(i,n,s),Ze.debugColors.joint1);t.DrawPoint(i,5,Ze.debugColors.joint1),t.DrawPoint(o,5,Ze.debugColors.joint4)}};var Qe={};Object.defineProperty(Qe,"__esModule",{value:!0}),Qe.b2PulleyJoint=Qe.b2PulleyJointDef=Qe.b2_minPulleyLength=void 0;const Ke=s,He=n,Ye=o,$e=be;Qe.b2_minPulleyLength=2;const ts={qA:new Ye.b2Rot,qB:new Ye.b2Rot,lalcA:new Ye.b2Vec2,lalcB:new Ye.b2Vec2,p:new Ye.b2Vec2,PA:new Ye.b2Vec2,PB:new Ye.b2Vec2,vpA:new Ye.b2Vec2,vpB:new Ye.b2Vec2,pA:new Ye.b2Vec2,pB:new Ye.b2Vec2};Qe.b2PulleyJointDef=class extends $e.b2JointDef{constructor(){super($e.b2JointType.e_pulleyJoint),this.groundAnchorA=new Ye.b2Vec2(-1,1),this.groundAnchorB=new Ye.b2Vec2(1,1),this.localAnchorA=new Ye.b2Vec2(-1,0),this.localAnchorB=new Ye.b2Vec2(1,0),this.lengthA=0,this.lengthB=0,this.ratio=1,this.collideConnected=!0}Initialize(t,e,s,i,o,n,r){this.bodyA=t,this.bodyB=e,this.groundAnchorA.Copy(s),this.groundAnchorB.Copy(i),this.bodyA.GetLocalPoint(o,this.localAnchorA),this.bodyB.GetLocalPoint(n,this.localAnchorB),this.lengthA=Ye.b2Vec2.Distance(o,s),this.lengthB=Ye.b2Vec2.Distance(n,i),this.ratio=r}};const es=new Ye.b2Vec2(-1,1),ss=Ye.b2Vec2.UNITX,is=new Ye.b2Vec2(-1,0),os=Ye.b2Vec2.UNITX;Qe.b2PulleyJoint=class extends $e.b2Joint{constructor(t){var e,s,i,o,n,r,a;super(t),this.m_groundAnchorA=new Ye.b2Vec2,this.m_groundAnchorB=new Ye.b2Vec2,this.m_lengthA=0,this.m_lengthB=0,this.m_localAnchorA=new Ye.b2Vec2,this.m_localAnchorB=new Ye.b2Vec2,this.m_constant=0,this.m_ratio=0,this.m_impulse=0,this.m_indexA=0,this.m_indexB=0,this.m_uA=new Ye.b2Vec2,this.m_uB=new Ye.b2Vec2,this.m_rA=new Ye.b2Vec2,this.m_rB=new Ye.b2Vec2,this.m_localCenterA=new Ye.b2Vec2,this.m_localCenterB=new Ye.b2Vec2,this.m_invMassA=0,this.m_invMassB=0,this.m_invIA=0,this.m_invIB=0,this.m_mass=0,this.m_groundAnchorA.Copy(null!==(e=t.groundAnchorA)&&void 0!==e?e:es),this.m_groundAnchorB.Copy(null!==(s=t.groundAnchorB)&&void 0!==s?s:ss),this.m_localAnchorA.Copy(null!==(i=t.localAnchorA)&&void 0!==i?i:is),this.m_localAnchorB.Copy(null!==(o=t.localAnchorB)&&void 0!==o?o:os),this.m_lengthA=null!==(n=t.lengthA)&&void 0!==n?n:0,this.m_lengthB=null!==(r=t.lengthB)&&void 0!==r?r:0,this.m_ratio=null!==(a=t.ratio)&&void 0!==a?a:1,this.m_constant=this.m_lengthA+this.m_ratio*this.m_lengthB,this.m_impulse=0}InitVelocityConstraints(t){this.m_indexA=this.m_bodyA.m_islandIndex,this.m_indexB=this.m_bodyB.m_islandIndex,this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter),this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter),this.m_invMassA=this.m_bodyA.m_invMass,this.m_invMassB=this.m_bodyB.m_invMass,this.m_invIA=this.m_bodyA.m_invI,this.m_invIB=this.m_bodyB.m_invI;const e=t.positions[this.m_indexA].c,s=t.positions[this.m_indexA].a,i=t.velocities[this.m_indexA].v;let o=t.velocities[this.m_indexA].w;const n=t.positions[this.m_indexB].c,r=t.positions[this.m_indexB].a,a=t.velocities[this.m_indexB].v;let c=t.velocities[this.m_indexB].w;const{qA:m,qB:l,lalcA:h,lalcB:_}=ts;m.Set(s),l.Set(r),Ye.b2Rot.MultiplyVec2(m,Ye.b2Vec2.Subtract(this.m_localAnchorA,this.m_localCenterA,h),this.m_rA),Ye.b2Rot.MultiplyVec2(l,Ye.b2Vec2.Subtract(this.m_localAnchorB,this.m_localCenterB,_),this.m_rB),Ye.b2Vec2.Add(e,this.m_rA,this.m_uA).Subtract(this.m_groundAnchorA),Ye.b2Vec2.Add(n,this.m_rB,this.m_uB).Subtract(this.m_groundAnchorB);const b=this.m_uA.Length(),u=this.m_uB.Length();b>10*Ke.b2_linearSlop?this.m_uA.Scale(1/b):this.m_uA.SetZero(),u>10*Ke.b2_linearSlop?this.m_uB.Scale(1/u):this.m_uB.SetZero();const d=Ye.b2Vec2.Cross(this.m_rA,this.m_uA),p=Ye.b2Vec2.Cross(this.m_rB,this.m_uB),y=this.m_invMassA+this.m_invIA*d*d,A=this.m_invMassB+this.m_invIB*p*p;if(this.m_mass=y+this.m_ratio*this.m_ratio*A,this.m_mass>0&&(this.m_mass=1/this.m_mass),t.step.warmStarting){this.m_impulse*=t.step.dtRatio;const{PA:e,PB:s}=ts;Ye.b2Vec2.Scale(-this.m_impulse,this.m_uA,e),Ye.b2Vec2.Scale(-this.m_ratio*this.m_impulse,this.m_uB,s),i.AddScaled(this.m_invMassA,e),o+=this.m_invIA*Ye.b2Vec2.Cross(this.m_rA,e),a.AddScaled(this.m_invMassB,s),c+=this.m_invIB*Ye.b2Vec2.Cross(this.m_rB,s)}else this.m_impulse=0;t.velocities[this.m_indexA].w=o,t.velocities[this.m_indexB].w=c}SolveVelocityConstraints(t){const e=t.velocities[this.m_indexA].v;let s=t.velocities[this.m_indexA].w;const i=t.velocities[this.m_indexB].v;let o=t.velocities[this.m_indexB].w;const{PA:n,PB:r,vpA:a,vpB:c}=ts;Ye.b2Vec2.AddCrossScalarVec2(e,s,this.m_rA,a),Ye.b2Vec2.AddCrossScalarVec2(i,o,this.m_rB,c);const m=-Ye.b2Vec2.Dot(this.m_uA,a)-this.m_ratio*Ye.b2Vec2.Dot(this.m_uB,c),l=-this.m_mass*m;this.m_impulse+=l,Ye.b2Vec2.Scale(-l,this.m_uA,n),Ye.b2Vec2.Scale(-this.m_ratio*l,this.m_uB,r),e.AddScaled(this.m_invMassA,n),s+=this.m_invIA*Ye.b2Vec2.Cross(this.m_rA,n),i.AddScaled(this.m_invMassB,r),o+=this.m_invIB*Ye.b2Vec2.Cross(this.m_rB,r),t.velocities[this.m_indexA].w=s,t.velocities[this.m_indexB].w=o}SolvePositionConstraints(t){const e=t.positions[this.m_indexA].c;let s=t.positions[this.m_indexA].a;const i=t.positions[this.m_indexB].c;let o=t.positions[this.m_indexB].a;const{qA:n,qB:r,lalcA:a,lalcB:c,PA:m,PB:l}=ts;n.Set(s),r.Set(o);const h=Ye.b2Rot.MultiplyVec2(n,Ye.b2Vec2.Subtract(this.m_localAnchorA,this.m_localCenterA,a),this.m_rA),_=Ye.b2Rot.MultiplyVec2(r,Ye.b2Vec2.Subtract(this.m_localAnchorB,this.m_localCenterB,c),this.m_rB),b=Ye.b2Vec2.Add(e,h,this.m_uA).Subtract(this.m_groundAnchorA),u=Ye.b2Vec2.Add(i,_,this.m_uB).Subtract(this.m_groundAnchorB),d=b.Length(),p=u.Length();d>10*Ke.b2_linearSlop?b.Scale(1/d):b.SetZero(),p>10*Ke.b2_linearSlop?u.Scale(1/p):u.SetZero();const y=Ye.b2Vec2.Cross(h,b),A=Ye.b2Vec2.Cross(_,u),x=this.m_invMassA+this.m_invIA*y*y,V=this.m_invMassB+this.m_invIB*A*A;let S=x+this.m_ratio*this.m_ratio*V;S>0&&(S=1/S);const v=this.m_constant-d-this.m_ratio*p,f=Math.abs(v),C=-S*v;return Ye.b2Vec2.Scale(-C,b,m),Ye.b2Vec2.Scale(-this.m_ratio*C,u,l),e.AddScaled(this.m_invMassA,m),s+=this.m_invIA*Ye.b2Vec2.Cross(h,m),i.AddScaled(this.m_invMassB,l),o+=this.m_invIB*Ye.b2Vec2.Cross(_,l),t.positions[this.m_indexA].a=s,t.positions[this.m_indexB].a=o,f<Ke.b2_linearSlop}GetAnchorA(t){return this.m_bodyA.GetWorldPoint(this.m_localAnchorA,t)}GetAnchorB(t){return this.m_bodyB.GetWorldPoint(this.m_localAnchorB,t)}GetReactionForce(t,e){return e.x=t*this.m_impulse*this.m_uB.x,e.y=t*this.m_impulse*this.m_uB.y,e}GetReactionTorque(t){return 0}GetGroundAnchorA(){return this.m_groundAnchorA}GetGroundAnchorB(){return this.m_groundAnchorB}GetLengthA(){return this.m_lengthA}GetLengthB(){return this.m_lengthB}GetRatio(){return this.m_ratio}GetCurrentLengthA(){const t=this.m_bodyA.GetWorldPoint(this.m_localAnchorA,ts.p),e=this.m_groundAnchorA;return Ye.b2Vec2.Distance(t,e)}GetCurrentLengthB(){const t=this.m_bodyB.GetWorldPoint(this.m_localAnchorB,ts.p),e=this.m_groundAnchorB;return Ye.b2Vec2.Distance(t,e)}ShiftOrigin(t){this.m_groundAnchorA.Subtract(t),this.m_groundAnchorB.Subtract(t)}Draw(t){const e=this.GetAnchorA(ts.pA),s=this.GetAnchorB(ts.pB),i=this.GetGroundAnchorA(),o=this.GetGroundAnchorB();t.DrawSegment(i,e,He.debugColors.joint6),t.DrawSegment(o,s,He.debugColors.joint6),t.DrawSegment(i,o,He.debugColors.joint6)}};var ns={};Object.defineProperty(ns,"__esModule",{value:!0}),ns.b2RevoluteJoint=ns.b2RevoluteJointDef=void 0;const rs=s,as=n,cs=o,ms=be,ls={qA:new cs.b2Rot,qB:new cs.b2Rot,lalcA:new cs.b2Vec2,lalcB:new cs.b2Vec2,P:new cs.b2Vec2,Cdot:new cs.b2Vec2,C:new cs.b2Vec2,impulse:new cs.b2Vec2,p2:new cs.b2Vec2,r:new cs.b2Vec2,pA:new cs.b2Vec2,pB:new cs.b2Vec2,rlo:new cs.b2Vec2,rhi:new cs.b2Vec2};ns.b2RevoluteJointDef=class extends ms.b2JointDef{constructor(){super(ms.b2JointType.e_revoluteJoint),this.localAnchorA=new cs.b2Vec2,this.localAnchorB=new cs.b2Vec2,this.referenceAngle=0,this.enableLimit=!1,this.lowerAngle=0,this.upperAngle=0,this.enableMotor=!1,this.motorSpeed=0,this.maxMotorTorque=0}Initialize(t,e,s){this.bodyA=t,this.bodyB=e,this.bodyA.GetLocalPoint(s,this.localAnchorA),this.bodyB.GetLocalPoint(s,this.localAnchorB),this.referenceAngle=this.bodyB.GetAngle()-this.bodyA.GetAngle()}};ns.b2RevoluteJoint=class extends ms.b2Joint{constructor(t){var e,s,i,o,n,r,a,c,m;super(t),this.m_localAnchorA=new cs.b2Vec2,this.m_localAnchorB=new cs.b2Vec2,this.m_impulse=new cs.b2Vec2,this.m_motorImpulse=0,this.m_lowerImpulse=0,this.m_upperImpulse=0,this.m_enableMotor=!1,this.m_maxMotorTorque=0,this.m_motorSpeed=0,this.m_enableLimit=!1,this.m_referenceAngle=0,this.m_lowerAngle=0,this.m_upperAngle=0,this.m_indexA=0,this.m_indexB=0,this.m_rA=new cs.b2Vec2,this.m_rB=new cs.b2Vec2,this.m_localCenterA=new cs.b2Vec2,this.m_localCenterB=new cs.b2Vec2,this.m_invMassA=0,this.m_invMassB=0,this.m_invIA=0,this.m_invIB=0,this.m_K=new cs.b2Mat22,this.m_angle=0,this.m_axialMass=0,this.m_localAnchorA.Copy(null!==(e=t.localAnchorA)&&void 0!==e?e:cs.b2Vec2.ZERO),this.m_localAnchorB.Copy(null!==(s=t.localAnchorB)&&void 0!==s?s:cs.b2Vec2.ZERO),this.m_referenceAngle=null!==(i=t.referenceAngle)&&void 0!==i?i:0,this.m_impulse.SetZero(),this.m_lowerAngle=null!==(o=t.lowerAngle)&&void 0!==o?o:0,this.m_upperAngle=null!==(n=t.upperAngle)&&void 0!==n?n:0,this.m_maxMotorTorque=null!==(r=t.maxMotorTorque)&&void 0!==r?r:0,this.m_motorSpeed=null!==(a=t.motorSpeed)&&void 0!==a?a:0,this.m_enableLimit=null!==(c=t.enableLimit)&&void 0!==c&&c,this.m_enableMotor=null!==(m=t.enableMotor)&&void 0!==m&&m}InitVelocityConstraints(t){this.m_indexA=this.m_bodyA.m_islandIndex,this.m_indexB=this.m_bodyB.m_islandIndex,this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter),this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter),this.m_invMassA=this.m_bodyA.m_invMass,this.m_invMassB=this.m_bodyB.m_invMass,this.m_invIA=this.m_bodyA.m_invI,this.m_invIB=this.m_bodyB.m_invI;const e=t.positions[this.m_indexA].a,s=t.velocities[this.m_indexA].v;let i=t.velocities[this.m_indexA].w;const o=t.positions[this.m_indexB].a,n=t.velocities[this.m_indexB].v;let r=t.velocities[this.m_indexB].w;const{qA:a,qB:c,lalcA:m,lalcB:l}=ls;a.Set(e),c.Set(o),cs.b2Rot.MultiplyVec2(a,cs.b2Vec2.Subtract(this.m_localAnchorA,this.m_localCenterA,m),this.m_rA),cs.b2Rot.MultiplyVec2(c,cs.b2Vec2.Subtract(this.m_localAnchorB,this.m_localCenterB,l),this.m_rB);const h=this.m_invMassA,_=this.m_invMassB,b=this.m_invIA,u=this.m_invIB;let d;if(this.m_K.ex.x=h+_+this.m_rA.y*this.m_rA.y*b+this.m_rB.y*this.m_rB.y*u,this.m_K.ey.x=-this.m_rA.y*this.m_rA.x*b-this.m_rB.y*this.m_rB.x*u,this.m_K.ex.y=this.m_K.ey.x,this.m_K.ey.y=h+_+this.m_rA.x*this.m_rA.x*b+this.m_rB.x*this.m_rB.x*u,this.m_axialMass=b+u,this.m_axialMass>0?(this.m_axialMass=1/this.m_axialMass,d=!1):d=!0,this.m_angle=o-e-this.m_referenceAngle,(!1===this.m_enableLimit||d)&&(this.m_lowerImpulse=0,this.m_upperImpulse=0),(!1===this.m_enableMotor||d)&&(this.m_motorImpulse=0),t.step.warmStarting){this.m_impulse.Scale(t.step.dtRatio),this.m_motorImpulse*=t.step.dtRatio,this.m_lowerImpulse*=t.step.dtRatio,this.m_upperImpulse*=t.step.dtRatio;const e=this.m_motorImpulse+this.m_lowerImpulse-this.m_upperImpulse,o=ls.P.Set(this.m_impulse.x,this.m_impulse.y);s.SubtractScaled(h,o),i-=b*(cs.b2Vec2.Cross(this.m_rA,o)+e),n.AddScaled(_,o),r+=u*(cs.b2Vec2.Cross(this.m_rB,o)+e)}else this.m_impulse.SetZero(),this.m_motorImpulse=0,this.m_lowerImpulse=0,this.m_upperImpulse=0;t.velocities[this.m_indexA].w=i,t.velocities[this.m_indexB].w=r}SolveVelocityConstraints(t){const e=t.velocities[this.m_indexA].v;let s=t.velocities[this.m_indexA].w;const i=t.velocities[this.m_indexB].v;let o=t.velocities[this.m_indexB].w;const n=this.m_invMassA,r=this.m_invMassB,a=this.m_invIA,c=this.m_invIB,m=a+c===0;if(this.m_enableMotor&&!m){const e=o-s-this.m_motorSpeed;let i=-this.m_axialMass*e;const n=this.m_motorImpulse,r=t.step.dt*this.m_maxMotorTorque;this.m_motorImpulse=(0,cs.b2Clamp)(this.m_motorImpulse+i,-r,r),i=this.m_motorImpulse-n,s-=a*i,o+=c*i}if(this.m_enableLimit&&!m){{const e=this.m_angle-this.m_lowerAngle,i=o-s;let n=-this.m_axialMass*(i+Math.max(e,0)*t.step.inv_dt);const r=this.m_lowerImpulse;this.m_lowerImpulse=Math.max(this.m_lowerImpulse+n,0),n=this.m_lowerImpulse-r,s-=a*n,o+=c*n}{const e=this.m_upperAngle-this.m_angle,i=s-o;let n=-this.m_axialMass*(i+Math.max(e,0)*t.step.inv_dt);const r=this.m_upperImpulse;this.m_upperImpulse=Math.max(this.m_upperImpulse+n,0),n=this.m_upperImpulse-r,s+=a*n,o-=c*n}}{const{Cdot:t,impulse:m}=ls;cs.b2Vec2.Subtract(cs.b2Vec2.AddCrossScalarVec2(i,o,this.m_rB,cs.b2Vec2.s_t0),cs.b2Vec2.AddCrossScalarVec2(e,s,this.m_rA,cs.b2Vec2.s_t1),t),this.m_K.Solve(-t.x,-t.y,m),this.m_impulse.x+=m.x,this.m_impulse.y+=m.y,e.SubtractScaled(n,m),s-=a*cs.b2Vec2.Cross(this.m_rA,m),i.AddScaled(r,m),o+=c*cs.b2Vec2.Cross(this.m_rB,m)}t.velocities[this.m_indexA].w=s,t.velocities[this.m_indexB].w=o}SolvePositionConstraints(t){const e=t.positions[this.m_indexA].c;let s=t.positions[this.m_indexA].a;const i=t.positions[this.m_indexB].c;let o=t.positions[this.m_indexB].a;const{qA:n,qB:r,lalcA:a,lalcB:c,impulse:m}=ls;n.Set(s),r.Set(o);let l=0,h=0;const _=this.m_invIA+this.m_invIB===0;if(this.m_enableLimit&&!_){const t=o-s-this.m_referenceAngle;let e=0;Math.abs(this.m_upperAngle-this.m_lowerAngle)<2*rs.b2_angularSlop?e=(0,cs.b2Clamp)(t-this.m_lowerAngle,-rs.b2_maxAngularCorrection,rs.b2_maxAngularCorrection):t<=this.m_lowerAngle?e=(0,cs.b2Clamp)(t-this.m_lowerAngle+rs.b2_angularSlop,-rs.b2_maxAngularCorrection,0):t>=this.m_upperAngle&&(e=(0,cs.b2Clamp)(t-this.m_upperAngle-rs.b2_angularSlop,0,rs.b2_maxAngularCorrection));const i=-this.m_axialMass*e;s-=this.m_invIA*i,o+=this.m_invIB*i,l=Math.abs(e)}{n.Set(s),r.Set(o);const t=cs.b2Rot.MultiplyVec2(n,cs.b2Vec2.Subtract(this.m_localAnchorA,this.m_localCenterA,a),this.m_rA),l=cs.b2Rot.MultiplyVec2(r,cs.b2Vec2.Subtract(this.m_localAnchorB,this.m_localCenterB,c),this.m_rB),_=cs.b2Vec2.Add(i,l,ls.C).Subtract(e).Subtract(t);h=_.Length();const b=this.m_invMassA,u=this.m_invMassB,d=this.m_invIA,p=this.m_invIB,y=this.m_K;y.ex.x=b+u+d*t.y*t.y+p*l.y*l.y,y.ex.y=-d*t.x*t.y-p*l.x*l.y,y.ey.x=y.ex.y,y.ey.y=b+u+d*t.x*t.x+p*l.x*l.x,y.Solve(_.x,_.y,m).Negate(),e.SubtractScaled(b,m),s-=d*cs.b2Vec2.Cross(t,m),i.AddScaled(u,m),o+=p*cs.b2Vec2.Cross(l,m)}return t.positions[this.m_indexA].a=s,t.positions[this.m_indexB].a=o,h<=rs.b2_linearSlop&&l<=rs.b2_angularSlop}GetAnchorA(t){return this.m_bodyA.GetWorldPoint(this.m_localAnchorA,t)}GetAnchorB(t){return this.m_bodyB.GetWorldPoint(this.m_localAnchorB,t)}GetReactionForce(t,e){return e.x=t*this.m_impulse.x,e.y=t*this.m_impulse.y,e}GetReactionTorque(t){return t*(this.m_motorImpulse+this.m_lowerImpulse-this.m_upperImpulse)}GetLocalAnchorA(){return this.m_localAnchorA}GetLocalAnchorB(){return this.m_localAnchorB}GetReferenceAngle(){return this.m_referenceAngle}GetJointAngle(){return this.m_bodyB.m_sweep.a-this.m_bodyA.m_sweep.a-this.m_referenceAngle}GetJointSpeed(){return this.m_bodyB.m_angularVelocity-this.m_bodyA.m_angularVelocity}IsMotorEnabled(){return this.m_enableMotor}EnableMotor(t){return t!==this.m_enableMotor&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_enableMotor=t),t}GetMotorTorque(t){return t*this.m_motorImpulse}GetMotorSpeed(){return this.m_motorSpeed}SetMaxMotorTorque(t){t!==this.m_maxMotorTorque&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_maxMotorTorque=t)}GetMaxMotorTorque(){return this.m_maxMotorTorque}IsLimitEnabled(){return this.m_enableLimit}EnableLimit(t){return t!==this.m_enableLimit&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_enableLimit=t,this.m_lowerImpulse=0,this.m_upperImpulse=0),t}GetLowerLimit(){return this.m_lowerAngle}GetUpperLimit(){return this.m_upperAngle}SetLimits(t,e){t===this.m_lowerAngle&&e===this.m_upperAngle||(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_lowerImpulse=0,this.m_upperImpulse=0,this.m_lowerAngle=t,this.m_upperAngle=e)}SetMotorSpeed(t){return t!==this.m_motorSpeed&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_motorSpeed=t),t}Draw(t){const{p2:e,r:s,pA:i,pB:o}=ls,n=this.m_bodyA.GetTransform(),r=this.m_bodyB.GetTransform();cs.b2Transform.MultiplyVec2(n,this.m_localAnchorA,i),cs.b2Transform.MultiplyVec2(r,this.m_localAnchorB,o),t.DrawPoint(i,5,as.debugColors.joint4),t.DrawPoint(o,5,as.debugColors.joint5);const a=this.m_bodyA.GetAngle(),c=this.m_bodyB.GetAngle()-a-this.m_referenceAngle,m=.5;if(s.Set(Math.cos(c),Math.sin(c)).Scale(m),t.DrawSegment(o,cs.b2Vec2.Add(o,s,e),as.debugColors.joint1),t.DrawCircle(o,m,as.debugColors.joint1),this.m_enableLimit){const{rlo:s,rhi:i}=ls;s.Set(Math.cos(this.m_lowerAngle),Math.sin(this.m_lowerAngle)).Scale(m),i.Set(Math.cos(this.m_upperAngle),Math.sin(this.m_upperAngle)).Scale(m),t.DrawSegment(o,cs.b2Vec2.Add(o,s,e),as.debugColors.joint2),t.DrawSegment(o,cs.b2Vec2.Add(o,i,e),as.debugColors.joint3)}t.DrawSegment(n.p,i,as.debugColors.joint6),t.DrawSegment(i,o,as.debugColors.joint6),t.DrawSegment(r.p,o,as.debugColors.joint6)}};var hs={};Object.defineProperty(hs,"__esModule",{value:!0}),hs.b2WeldJoint=hs.b2WeldJointDef=void 0;const _s=s,bs=o,us=be,ds={qA:new bs.b2Rot,qB:new bs.b2Rot,rA:new bs.b2Vec2,rB:new bs.b2Vec2,lalcA:new bs.b2Vec2,lalcB:new bs.b2Vec2,K:new bs.b2Mat33,P:new bs.b2Vec2,Cdot1:new bs.b2Vec3,impulse1:new bs.b2Vec2,impulse:new bs.b2Vec3,C1:new bs.b2Vec2,C:new bs.b2Vec3};hs.b2WeldJointDef=class extends us.b2JointDef{constructor(){super(us.b2JointType.e_weldJoint),this.localAnchorA=new bs.b2Vec2,this.localAnchorB=new bs.b2Vec2,this.referenceAngle=0,this.stiffness=0,this.damping=0}Initialize(t,e,s){this.bodyA=t,this.bodyB=e,this.bodyA.GetLocalPoint(s,this.localAnchorA),this.bodyB.GetLocalPoint(s,this.localAnchorB),this.referenceAngle=this.bodyB.GetAngle()-this.bodyA.GetAngle()}};hs.b2WeldJoint=class extends us.b2Joint{constructor(t){var e,s,i,o,n;super(t),this.m_stiffness=0,this.m_damping=0,this.m_bias=0,this.m_localAnchorA=new bs.b2Vec2,this.m_localAnchorB=new bs.b2Vec2,this.m_referenceAngle=0,this.m_gamma=0,this.m_impulse=new bs.b2Vec3,this.m_indexA=0,this.m_indexB=0,this.m_rA=new bs.b2Vec2,this.m_rB=new bs.b2Vec2,this.m_localCenterA=new bs.b2Vec2,this.m_localCenterB=new bs.b2Vec2,this.m_invMassA=0,this.m_invMassB=0,this.m_invIA=0,this.m_invIB=0,this.m_mass=new bs.b2Mat33,this.m_localAnchorA.Copy(null!==(e=t.localAnchorA)&&void 0!==e?e:bs.b2Vec2.ZERO),this.m_localAnchorB.Copy(null!==(s=t.localAnchorB)&&void 0!==s?s:bs.b2Vec2.ZERO),this.m_referenceAngle=null!==(i=t.referenceAngle)&&void 0!==i?i:0,this.m_stiffness=null!==(o=t.stiffness)&&void 0!==o?o:0,this.m_damping=null!==(n=t.damping)&&void 0!==n?n:0}InitVelocityConstraints(t){this.m_indexA=this.m_bodyA.m_islandIndex,this.m_indexB=this.m_bodyB.m_islandIndex,this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter),this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter),this.m_invMassA=this.m_bodyA.m_invMass,this.m_invMassB=this.m_bodyB.m_invMass,this.m_invIA=this.m_bodyA.m_invI,this.m_invIB=this.m_bodyB.m_invI;const e=t.positions[this.m_indexA].a,s=t.velocities[this.m_indexA].v;let i=t.velocities[this.m_indexA].w;const o=t.positions[this.m_indexB].a,n=t.velocities[this.m_indexB].v;let r=t.velocities[this.m_indexB].w;const{qA:a,qB:c,lalcA:m,lalcB:l,K:h}=ds;a.Set(e),c.Set(o),bs.b2Rot.MultiplyVec2(a,bs.b2Vec2.Subtract(this.m_localAnchorA,this.m_localCenterA,m),this.m_rA),bs.b2Rot.MultiplyVec2(c,bs.b2Vec2.Subtract(this.m_localAnchorB,this.m_localCenterB,l),this.m_rB);const _=this.m_invMassA,b=this.m_invMassB,u=this.m_invIA,d=this.m_invIB;if(h.ex.x=_+b+this.m_rA.y*this.m_rA.y*u+this.m_rB.y*this.m_rB.y*d,h.ey.x=-this.m_rA.y*this.m_rA.x*u-this.m_rB.y*this.m_rB.x*d,h.ez.x=-this.m_rA.y*u-this.m_rB.y*d,h.ex.y=h.ey.x,h.ey.y=_+b+this.m_rA.x*this.m_rA.x*u+this.m_rB.x*this.m_rB.x*d,h.ez.y=this.m_rA.x*u+this.m_rB.x*d,h.ex.z=h.ez.x,h.ey.z=h.ez.y,h.ez.z=u+d,this.m_stiffness>0){h.GetInverse22(this.m_mass);let s=u+d;const i=o-e-this.m_referenceAngle,n=this.m_damping,r=this.m_stiffness,a=t.step.dt;this.m_gamma=a*(n+a*r),this.m_gamma=0!==this.m_gamma?1/this.m_gamma:0,this.m_bias=i*a*r*this.m_gamma,s+=this.m_gamma,this.m_mass.ez.z=0!==s?1/s:0}else 0===h.ez.z?(h.GetInverse22(this.m_mass),this.m_gamma=0,this.m_bias=0):(h.GetSymInverse33(this.m_mass),this.m_gamma=0,this.m_bias=0);if(t.step.warmStarting){this.m_impulse.Scale(t.step.dtRatio);const{P:e}=ds;e.Copy(this.m_impulse),s.SubtractScaled(_,e),i-=u*(bs.b2Vec2.Cross(this.m_rA,e)+this.m_impulse.z),n.AddScaled(b,e),r+=d*(bs.b2Vec2.Cross(this.m_rB,e)+this.m_impulse.z)}else this.m_impulse.SetZero();t.velocities[this.m_indexA].w=i,t.velocities[this.m_indexB].w=r}SolveVelocityConstraints(t){const e=t.velocities[this.m_indexA].v;let s=t.velocities[this.m_indexA].w;const i=t.velocities[this.m_indexB].v;let o=t.velocities[this.m_indexB].w;const n=this.m_invMassA,r=this.m_invMassB,a=this.m_invIA,c=this.m_invIB;if(this.m_stiffness>0){const t=o-s,m=-this.m_mass.ez.z*(t+this.m_bias+this.m_gamma*this.m_impulse.z);this.m_impulse.z+=m,s-=a*m,o+=c*m;const{Cdot1:l,impulse1:h}=ds;bs.b2Vec2.Subtract(bs.b2Vec2.AddCrossScalarVec2(i,o,this.m_rB,bs.b2Vec2.s_t0),bs.b2Vec2.AddCrossScalarVec2(e,s,this.m_rA,bs.b2Vec2.s_t1),l),bs.b2Mat33.MultiplyVec2(this.m_mass,l,h).Negate(),this.m_impulse.x+=h.x,this.m_impulse.y+=h.y;const _=h;e.SubtractScaled(n,_),s-=a*bs.b2Vec2.Cross(this.m_rA,_),i.AddScaled(r,_),o+=c*bs.b2Vec2.Cross(this.m_rB,_)}else{const{Cdot1:t,impulse:m,P:l}=ds;bs.b2Vec2.Subtract(bs.b2Vec2.AddCrossScalarVec2(i,o,this.m_rB,bs.b2Vec2.s_t0),bs.b2Vec2.AddCrossScalarVec2(e,s,this.m_rA,bs.b2Vec2.s_t1),t),t.z=o-s,bs.b2Mat33.MultiplyVec3(this.m_mass,t,m).Negate(),this.m_impulse.Add(m),l.Set(m.x,m.y),e.SubtractScaled(n,l),s-=a*(bs.b2Vec2.Cross(this.m_rA,l)+m.z),i.AddScaled(r,l),o+=c*(bs.b2Vec2.Cross(this.m_rB,l)+m.z)}t.velocities[this.m_indexA].w=s,t.velocities[this.m_indexB].w=o}SolvePositionConstraints(t){const e=t.positions[this.m_indexA].c;let s=t.positions[this.m_indexA].a;const i=t.positions[this.m_indexB].c;let o=t.positions[this.m_indexB].a;const{qA:n,qB:r,lalcA:a,lalcB:c,K:m,C1:l,P:h,rA:_,rB:b}=ds;n.Set(s),r.Set(o);const u=this.m_invMassA,d=this.m_invMassB,p=this.m_invIA,y=this.m_invIB;let A,x;if(bs.b2Rot.MultiplyVec2(n,bs.b2Vec2.Subtract(this.m_localAnchorA,this.m_localCenterA,a),_),bs.b2Rot.MultiplyVec2(r,bs.b2Vec2.Subtract(this.m_localAnchorB,this.m_localCenterB,c),b),m.ex.x=u+d+_.y*_.y*p+b.y*b.y*y,m.ey.x=-_.y*_.x*p-b.y*b.x*y,m.ez.x=-_.y*p-b.y*y,m.ex.y=m.ey.x,m.ey.y=u+d+_.x*_.x*p+b.x*b.x*y,m.ez.y=_.x*p+b.x*y,m.ex.z=m.ez.x,m.ey.z=m.ez.y,m.ez.z=p+y,this.m_stiffness>0)bs.b2Vec2.Add(i,b,l).Subtract(e).Subtract(_),A=l.Length(),x=0,m.Solve22(l.x,l.y,h).Negate(),e.SubtractScaled(u,h),s-=p*bs.b2Vec2.Cross(_,h),i.AddScaled(d,h),o+=y*bs.b2Vec2.Cross(b,h);else{bs.b2Vec2.Add(i,b,l).Subtract(e).Subtract(_),bs.b2Vec2.Subtract(bs.b2Vec2.Add(i,b,bs.b2Vec2.s_t0),bs.b2Vec2.Add(e,_,bs.b2Vec2.s_t1),l);const t=o-s-this.m_referenceAngle;A=l.Length(),x=Math.abs(t);const{impulse:n,C:r}=ds;r.Set(l.x,l.y,t),m.ez.z>0?m.Solve33(r.x,r.y,r.z,n).Negate():(m.Solve22(l.x,l.y,n).Negate(),n.z=0),h.Copy(n),e.SubtractScaled(u,h),s-=p*(bs.b2Vec2.Cross(_,h)+n.z),i.AddScaled(d,h),o+=y*(bs.b2Vec2.Cross(b,h)+n.z)}return t.positions[this.m_indexA].a=s,t.positions[this.m_indexB].a=o,A<=_s.b2_linearSlop&&x<=_s.b2_angularSlop}GetAnchorA(t){return this.m_bodyA.GetWorldPoint(this.m_localAnchorA,t)}GetAnchorB(t){return this.m_bodyB.GetWorldPoint(this.m_localAnchorB,t)}GetReactionForce(t,e){return e.x=t*this.m_impulse.x,e.y=t*this.m_impulse.y,e}GetReactionTorque(t){return t*this.m_impulse.z}GetLocalAnchorA(){return this.m_localAnchorA}GetLocalAnchorB(){return this.m_localAnchorB}GetReferenceAngle(){return this.m_referenceAngle}SetStiffness(t){this.m_stiffness=t}GetStiffness(){return this.m_stiffness}SetDamping(t){this.m_damping=t}GetDamping(){return this.m_damping}};var ps={};Object.defineProperty(ps,"__esModule",{value:!0}),ps.b2WheelJoint=ps.b2WheelJointDef=void 0;const ys=s,As=o,xs=be,Vs=n,Ss={qA:new As.b2Rot,qB:new As.b2Rot,lalcA:new As.b2Vec2,lalcB:new As.b2Vec2,rA:new As.b2Vec2,rB:new As.b2Vec2,d:new As.b2Vec2,P:new As.b2Vec2,ay:new As.b2Vec2,pA:new As.b2Vec2,pB:new As.b2Vec2,axis:new As.b2Vec2,Draw:{p1:new As.b2Vec2,p2:new As.b2Vec2,pA:new As.b2Vec2,pB:new As.b2Vec2,axis:new As.b2Vec2,lower:new As.b2Vec2,upper:new As.b2Vec2,perp:new As.b2Vec2}};ps.b2WheelJointDef=class extends xs.b2JointDef{constructor(){super(xs.b2JointType.e_wheelJoint),this.localAnchorA=new As.b2Vec2,this.localAnchorB=new As.b2Vec2,this.localAxisA=new As.b2Vec2(1,0),this.enableLimit=!1,this.lowerTranslation=0,this.upperTranslation=0,this.enableMotor=!1,this.maxMotorTorque=0,this.motorSpeed=0,this.stiffness=0,this.damping=0}Initialize(t,e,s,i){this.bodyA=t,this.bodyB=e,this.bodyA.GetLocalPoint(s,this.localAnchorA),this.bodyB.GetLocalPoint(s,this.localAnchorB),this.bodyA.GetLocalVector(i,this.localAxisA)}};ps.b2WheelJoint=class extends xs.b2Joint{constructor(t){var e,s,i,o,n,r,a,c,m,l,h;super(t),this.m_localAnchorA=new As.b2Vec2,this.m_localAnchorB=new As.b2Vec2,this.m_localXAxisA=new As.b2Vec2,this.m_localYAxisA=new As.b2Vec2,this.m_impulse=0,this.m_motorImpulse=0,this.m_springImpulse=0,this.m_lowerImpulse=0,this.m_upperImpulse=0,this.m_translation=0,this.m_lowerTranslation=0,this.m_upperTranslation=0,this.m_maxMotorTorque=0,this.m_motorSpeed=0,this.m_enableLimit=!1,this.m_enableMotor=!1,this.m_stiffness=0,this.m_damping=0,this.m_indexA=0,this.m_indexB=0,this.m_localCenterA=new As.b2Vec2,this.m_localCenterB=new As.b2Vec2,this.m_invMassA=0,this.m_invMassB=0,this.m_invIA=0,this.m_invIB=0,this.m_ax=new As.b2Vec2,this.m_ay=new As.b2Vec2,this.m_sAx=0,this.m_sBx=0,this.m_sAy=0,this.m_sBy=0,this.m_mass=0,this.m_motorMass=0,this.m_axialMass=0,this.m_springMass=0,this.m_bias=0,this.m_gamma=0,this.m_localAnchorA.Copy(null!==(e=t.localAnchorA)&&void 0!==e?e:As.b2Vec2.ZERO),this.m_localAnchorB.Copy(null!==(s=t.localAnchorB)&&void 0!==s?s:As.b2Vec2.ZERO),this.m_localXAxisA.Copy(null!==(i=t.localAxisA)&&void 0!==i?i:As.b2Vec2.UNITX),As.b2Vec2.CrossOneVec2(this.m_localXAxisA,this.m_localYAxisA),this.m_lowerTranslation=null!==(o=t.lowerTranslation)&&void 0!==o?o:0,this.m_upperTranslation=null!==(n=t.upperTranslation)&&void 0!==n?n:0,this.m_enableLimit=null!==(r=t.enableLimit)&&void 0!==r&&r,this.m_maxMotorTorque=null!==(a=t.maxMotorTorque)&&void 0!==a?a:0,this.m_motorSpeed=null!==(c=t.motorSpeed)&&void 0!==c?c:0,this.m_enableMotor=null!==(m=t.enableMotor)&&void 0!==m&&m,this.m_ax.SetZero(),this.m_ay.SetZero(),this.m_stiffness=null!==(l=t.stiffness)&&void 0!==l?l:0,this.m_damping=null!==(h=t.damping)&&void 0!==h?h:0}GetMotorSpeed(){return this.m_motorSpeed}GetMaxMotorTorque(){return this.m_maxMotorTorque}SetStiffness(t){this.m_stiffness=t}GetStiffness(){return this.m_stiffness}SetDamping(t){this.m_damping=t}GetDamping(){return this.m_damping}InitVelocityConstraints(t){this.m_indexA=this.m_bodyA.m_islandIndex,this.m_indexB=this.m_bodyB.m_islandIndex,this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter),this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter),this.m_invMassA=this.m_bodyA.m_invMass,this.m_invMassB=this.m_bodyB.m_invMass,this.m_invIA=this.m_bodyA.m_invI,this.m_invIB=this.m_bodyB.m_invI;const e=this.m_invMassA,s=this.m_invMassB,i=this.m_invIA,o=this.m_invIB,n=t.positions[this.m_indexA].c,r=t.positions[this.m_indexA].a,a=t.velocities[this.m_indexA].v;let c=t.velocities[this.m_indexA].w;const m=t.positions[this.m_indexB].c,l=t.positions[this.m_indexB].a,h=t.velocities[this.m_indexB].v;let _=t.velocities[this.m_indexB].w;const{qA:b,qB:u,lalcA:d,lalcB:p,rA:y,rB:A,d:x}=Ss;b.Set(r),u.Set(l),As.b2Rot.MultiplyVec2(b,As.b2Vec2.Subtract(this.m_localAnchorA,this.m_localCenterA,d),y),As.b2Rot.MultiplyVec2(u,As.b2Vec2.Subtract(this.m_localAnchorB,this.m_localCenterB,p),A),As.b2Vec2.Add(m,A,x).Subtract(n).Subtract(y),As.b2Rot.MultiplyVec2(b,this.m_localYAxisA,this.m_ay),this.m_sAy=As.b2Vec2.Cross(As.b2Vec2.Add(x,y,As.b2Vec2.s_t0),this.m_ay),this.m_sBy=As.b2Vec2.Cross(A,this.m_ay),this.m_mass=e+s+i*this.m_sAy*this.m_sAy+o*this.m_sBy*this.m_sBy,this.m_mass>0&&(this.m_mass=1/this.m_mass),As.b2Rot.MultiplyVec2(b,this.m_localXAxisA,this.m_ax),this.m_sAx=As.b2Vec2.Cross(As.b2Vec2.Add(x,y,As.b2Vec2.s_t0),this.m_ax),this.m_sBx=As.b2Vec2.Cross(A,this.m_ax);const V=e+s+i*this.m_sAx*this.m_sAx+o*this.m_sBx*this.m_sBx;if(this.m_axialMass=V>0?1/V:0,this.m_springMass=0,this.m_bias=0,this.m_gamma=0,this.m_stiffness>0&&V>0){this.m_springMass=1/V;const e=As.b2Vec2.Dot(x,this.m_ax),s=t.step.dt;this.m_gamma=s*(this.m_damping+s*this.m_stiffness),this.m_gamma>0&&(this.m_gamma=1/this.m_gamma),this.m_bias=e*s*this.m_stiffness*this.m_gamma,this.m_springMass=V+this.m_gamma,this.m_springMass>0&&(this.m_springMass=1/this.m_springMass)}else this.m_springImpulse=0;if(this.m_enableLimit?this.m_translation=As.b2Vec2.Dot(this.m_ax,x):(this.m_lowerImpulse=0,this.m_upperImpulse=0),this.m_enableMotor?(this.m_motorMass=i+o,this.m_motorMass>0&&(this.m_motorMass=1/this.m_motorMass)):(this.m_motorMass=0,this.m_motorImpulse=0),t.step.warmStarting){this.m_impulse*=t.step.dtRatio,this.m_springImpulse*=t.step.dtRatio,this.m_motorImpulse*=t.step.dtRatio;const e=this.m_springImpulse+this.m_lowerImpulse-this.m_upperImpulse,{P:s}=Ss;As.b2Vec2.Scale(this.m_impulse,this.m_ay,s).AddScaled(e,this.m_ax);const i=this.m_impulse*this.m_sAy+e*this.m_sAx+this.m_motorImpulse,o=this.m_impulse*this.m_sBy+e*this.m_sBx+this.m_motorImpulse;a.SubtractScaled(this.m_invMassA,s),c-=this.m_invIA*i,h.AddScaled(this.m_invMassB,s),_+=this.m_invIB*o}else this.m_impulse=0,this.m_springImpulse=0,this.m_motorImpulse=0,this.m_lowerImpulse=0,this.m_upperImpulse=0;t.velocities[this.m_indexA].w=c,t.velocities[this.m_indexB].w=_}SolveVelocityConstraints(t){const e=this.m_invMassA,s=this.m_invMassB,i=this.m_invIA,o=this.m_invIB,n=t.velocities[this.m_indexA].v;let r=t.velocities[this.m_indexA].w;const a=t.velocities[this.m_indexB].v;let c=t.velocities[this.m_indexB].w;const{P:m}=Ss;{const t=As.b2Vec2.Dot(this.m_ax,As.b2Vec2.Subtract(a,n,As.b2Vec2.s_t0))+this.m_sBx*c-this.m_sAx*r,l=-this.m_springMass*(t+this.m_bias+this.m_gamma*this.m_springImpulse);this.m_springImpulse+=l,As.b2Vec2.Scale(l,this.m_ax,m);const h=l*this.m_sAx,_=l*this.m_sBx;n.SubtractScaled(e,m),r-=i*h,a.AddScaled(s,m),c+=o*_}{const e=c-r-this.m_motorSpeed;let s=-this.m_motorMass*e;const n=this.m_motorImpulse,a=t.step.dt*this.m_maxMotorTorque;this.m_motorImpulse=(0,As.b2Clamp)(this.m_motorImpulse+s,-a,a),s=this.m_motorImpulse-n,r-=i*s,c+=o*s}if(this.m_enableLimit){{const l=this.m_translation-this.m_lowerTranslation,h=As.b2Vec2.Dot(this.m_ax,As.b2Vec2.Subtract(a,n,As.b2Vec2.s_t0))+this.m_sBx*c-this.m_sAx*r;let _=-this.m_axialMass*(h+Math.max(l,0)*t.step.inv_dt);const b=this.m_lowerImpulse;this.m_lowerImpulse=Math.max(this.m_lowerImpulse+_,0),_=this.m_lowerImpulse-b,As.b2Vec2.Scale(_,this.m_ax,m);const u=_*this.m_sAx,d=_*this.m_sBx;n.SubtractScaled(e,m),r-=i*u,a.AddScaled(s,m),c+=o*d}{const l=this.m_upperTranslation-this.m_translation,h=As.b2Vec2.Dot(this.m_ax,As.b2Vec2.Subtract(n,a,As.b2Vec2.s_t0))+this.m_sAx*r-this.m_sBx*c;let _=-this.m_axialMass*(h+Math.max(l,0)*t.step.inv_dt);const b=this.m_upperImpulse;this.m_upperImpulse=Math.max(this.m_upperImpulse+_,0),_=this.m_upperImpulse-b,As.b2Vec2.Scale(_,this.m_ax,m);const u=_*this.m_sAx,d=_*this.m_sBx;n.AddScaled(e,m),r+=i*u,a.SubtractScaled(s,m),c-=o*d}}{const t=As.b2Vec2.Dot(this.m_ay,As.b2Vec2.Subtract(a,n,As.b2Vec2.s_t0))+this.m_sBy*c-this.m_sAy*r,l=-this.m_mass*t;this.m_impulse+=l,As.b2Vec2.Scale(l,this.m_ay,m);const h=l*this.m_sAy,_=l*this.m_sBy;n.SubtractScaled(e,m),r-=i*h,a.AddScaled(s,m),c+=o*_}t.velocities[this.m_indexA].w=r,t.velocities[this.m_indexB].w=c}SolvePositionConstraints(t){const e=t.positions[this.m_indexA].c;let s=t.positions[this.m_indexA].a;const i=t.positions[this.m_indexB].c;let o=t.positions[this.m_indexB].a,n=0;const{qA:r,qB:a,lalcA:c,lalcB:m,rA:l,rB:h,d:_,P:b,ay:u}=Ss;if(this.m_enableLimit){r.Set(s),a.Set(o),As.b2Rot.MultiplyVec2(r,As.b2Vec2.Subtract(this.m_localAnchorA,this.m_localCenterA,c),l),As.b2Rot.MultiplyVec2(a,As.b2Vec2.Subtract(this.m_localAnchorB,this.m_localCenterB,m),h),As.b2Vec2.Subtract(i,e,_).Add(h).Subtract(l);const t=As.b2Rot.MultiplyVec2(r,this.m_localXAxisA,this.m_ax),u=As.b2Vec2.Cross(As.b2Vec2.Add(_,l,As.b2Vec2.s_t0),this.m_ax),d=As.b2Vec2.Cross(h,this.m_ax);let p=0;const y=As.b2Vec2.Dot(t,_);if(Math.abs(this.m_upperTranslation-this.m_lowerTranslation)<2*ys.b2_linearSlop?p=y:y<=this.m_lowerTranslation?p=Math.min(y-this.m_lowerTranslation,0):y>=this.m_upperTranslation&&(p=Math.max(y-this.m_upperTranslation,0)),0!==p){const r=this.m_invMassA+this.m_invMassB+this.m_invIA*u*u+this.m_invIB*d*d;let a=0;0!==r&&(a=-p/r),As.b2Vec2.Scale(a,t,b);const c=a*u,m=a*d;e.SubtractScaled(this.m_invMassA,b),s-=this.m_invIA*c,i.AddScaled(this.m_invMassB,b),o+=this.m_invIB*m,n=Math.abs(p)}}{r.Set(s),a.Set(o),As.b2Rot.MultiplyVec2(r,As.b2Vec2.Subtract(this.m_localAnchorA,this.m_localCenterA,c),l),As.b2Rot.MultiplyVec2(a,As.b2Vec2.Subtract(this.m_localAnchorB,this.m_localCenterB,m),h),As.b2Vec2.Subtract(i,e,_).Add(h).Subtract(l),As.b2Rot.MultiplyVec2(r,this.m_localYAxisA,u);const t=As.b2Vec2.Cross(As.b2Vec2.Add(_,l,As.b2Vec2.s_t0),u),d=As.b2Vec2.Cross(h,u),p=As.b2Vec2.Dot(_,u),y=this.m_invMassA+this.m_invMassB+this.m_invIA*this.m_sAy*this.m_sAy+this.m_invIB*this.m_sBy*this.m_sBy;let A=0;0!==y&&(A=-p/y),As.b2Vec2.Scale(A,u,b);const x=A*t,V=A*d;e.SubtractScaled(this.m_invMassA,b),s-=this.m_invIA*x,i.AddScaled(this.m_invMassB,b),o+=this.m_invIB*V,n=Math.max(n,Math.abs(p))}return t.positions[this.m_indexA].a=s,t.positions[this.m_indexB].a=o,n<=ys.b2_linearSlop}GetAnchorA(t){return this.m_bodyA.GetWorldPoint(this.m_localAnchorA,t)}GetAnchorB(t){return this.m_bodyB.GetWorldPoint(this.m_localAnchorB,t)}GetReactionForce(t,e){const s=this.m_springImpulse+this.m_lowerImpulse-this.m_upperImpulse;return e.x=t*(this.m_impulse*this.m_ay.x+s*this.m_ax.x),e.y=t*(this.m_impulse*this.m_ay.y+s*this.m_ax.y),e}GetReactionTorque(t){return t*this.m_motorImpulse}GetLocalAnchorA(){return this.m_localAnchorA}GetLocalAnchorB(){return this.m_localAnchorB}GetLocalAxisA(){return this.m_localXAxisA}GetJointTranslation(){const t=this.m_bodyA,e=this.m_bodyB,{pA:s,pB:i,d:o,axis:n}=Ss;t.GetWorldPoint(this.m_localAnchorA,s),e.GetWorldPoint(this.m_localAnchorB,i),As.b2Vec2.Subtract(i,s,o),t.GetWorldVector(this.m_localXAxisA,n);return As.b2Vec2.Dot(o,n)}GetJointLinearSpeed(){const t=this.m_bodyA,e=this.m_bodyB,{rA:s,rB:i,lalcA:o,lalcB:n,axis:r}=Ss;As.b2Rot.MultiplyVec2(t.m_xf.q,As.b2Vec2.Subtract(this.m_localAnchorA,t.m_sweep.localCenter,o),s),As.b2Rot.MultiplyVec2(e.m_xf.q,As.b2Vec2.Subtract(this.m_localAnchorB,e.m_sweep.localCenter,n),i);const a=As.b2Vec2.Add(t.m_sweep.c,s,As.b2Vec2.s_t0),c=As.b2Vec2.Add(e.m_sweep.c,i,As.b2Vec2.s_t1),m=As.b2Vec2.Subtract(c,a,As.b2Vec2.s_t2);As.b2Rot.MultiplyVec2(t.m_xf.q,this.m_localXAxisA,r);const l=t.m_linearVelocity,h=e.m_linearVelocity,_=t.m_angularVelocity,b=e.m_angularVelocity;return As.b2Vec2.Dot(m,As.b2Vec2.CrossScalarVec2(_,r,As.b2Vec2.s_t0))+As.b2Vec2.Dot(r,As.b2Vec2.AddCrossScalarVec2(h,b,i,As.b2Vec2.s_t0).Subtract(l).Subtract(As.b2Vec2.CrossScalarVec2(_,s,As.b2Vec2.s_t1)))}GetJointAngle(){return this.m_bodyB.m_sweep.a-this.m_bodyA.m_sweep.a}GetJointAngularSpeed(){const t=this.m_bodyA.m_angularVelocity;return this.m_bodyB.m_angularVelocity-t}IsMotorEnabled(){return this.m_enableMotor}EnableMotor(t){return t!==this.m_enableMotor&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_enableMotor=t),t}SetMotorSpeed(t){return t!==this.m_motorSpeed&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_motorSpeed=t),t}SetMaxMotorTorque(t){t!==this.m_maxMotorTorque&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_maxMotorTorque=t)}GetMotorTorque(t){return t*this.m_motorImpulse}IsLimitEnabled(){return this.m_enableLimit}EnableLimit(t){return t!==this.m_enableLimit&&(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_enableLimit=t,this.m_lowerImpulse=0,this.m_upperImpulse=0),t}GetLowerLimit(){return this.m_lowerTranslation}GetUpperLimit(){return this.m_upperTranslation}SetLimits(t,e){t===this.m_lowerTranslation&&e===this.m_upperTranslation||(this.m_bodyA.SetAwake(!0),this.m_bodyB.SetAwake(!0),this.m_lowerTranslation=t,this.m_upperTranslation=e,this.m_lowerImpulse=0,this.m_upperImpulse=0)}Draw(t){const{p1:e,p2:s,pA:i,pB:o,axis:n}=Ss.Draw,r=this.m_bodyA.GetTransform(),a=this.m_bodyB.GetTransform();if(As.b2Transform.MultiplyVec2(r,this.m_localAnchorA,i),As.b2Transform.MultiplyVec2(a,this.m_localAnchorB,o),As.b2Rot.MultiplyVec2(r.q,this.m_localXAxisA,n),t.DrawSegment(i,o,Vs.debugColors.joint5),this.m_enableLimit){const{lower:o,upper:a,perp:c}=Ss.Draw;As.b2Vec2.AddScaled(i,this.m_lowerTranslation,n,o),As.b2Vec2.AddScaled(i,this.m_upperTranslation,n,a),As.b2Rot.MultiplyVec2(r.q,this.m_localYAxisA,c),t.DrawSegment(o,a,Vs.debugColors.joint1),t.DrawSegment(As.b2Vec2.SubtractScaled(o,.5,c,e),As.b2Vec2.AddScaled(o,.5,c,s),Vs.debugColors.joint2),t.DrawSegment(As.b2Vec2.SubtractScaled(a,.5,c,e),As.b2Vec2.AddScaled(a,.5,c,s),Vs.debugColors.joint3)}else t.DrawSegment(As.b2Vec2.Subtract(i,n,e),As.b2Vec2.Add(i,n,s),Vs.debugColors.joint1);t.DrawPoint(i,5,Vs.debugColors.joint1),t.DrawPoint(o,5,Vs.debugColors.joint4)}};var vs={},fs={},Cs={},Bs={};Object.defineProperty(Bs,"__esModule",{value:!0}),Bs.b2Contact=Bs.b2ContactEdge=Bs.b2MixRestitutionThreshold=Bs.b2MixRestitution=Bs.b2MixFriction=void 0;const ws=s,gs=h;function Ms(t,e){return Math.sqrt(t*e)}function Is(t,e){return t>e?t:e}function Ts(t,e){return t<e?t:e}Bs.b2MixFriction=Ms,Bs.b2MixRestitution=Is,Bs.b2MixRestitutionThreshold=Ts;class Ds{constructor(t){this.m_other=null,this.prev=null,this.next=null,this.contact=t}get other(){return(0,ws.b2Assert)(null!==this.m_other),this.m_other}set other(t){(0,ws.b2Assert)(null===this.m_other),this.m_other=t}Reset(){this.m_other=null,this.prev=null,this.next=null}}Bs.b2ContactEdge=Ds;Bs.b2Contact=class{constructor(){this.m_islandFlag=!1,this.m_touchingFlag=!1,this.m_enabledFlag=!1,this.m_filterFlag=!1,this.m_bulletHitFlag=!1,this.m_toiFlag=!1,this.m_prev=null,this.m_next=null,this.m_nodeA=new Ds(this),this.m_nodeB=new Ds(this),this.m_indexA=0,this.m_indexB=0,this.m_manifold=new gs.b2Manifold,this.m_toiCount=0,this.m_toi=0,this.m_friction=0,this.m_restitution=0,this.m_restitutionThreshold=0,this.m_tangentSpeed=0,this.m_oldManifold=new gs.b2Manifold}GetManifold(){return this.m_manifold}GetWorldManifold(t){const e=this.m_fixtureA.GetBody(),s=this.m_fixtureB.GetBody(),i=this.GetShapeA(),o=this.GetShapeB();t.Initialize(this.m_manifold,e.GetTransform(),i.m_radius,s.GetTransform(),o.m_radius)}IsTouching(){return this.m_touchingFlag}SetEnabled(t){this.m_enabledFlag=t}IsEnabled(){return this.m_enabledFlag}GetNext(){return this.m_next}GetFixtureA(){return this.m_fixtureA}GetChildIndexA(){return this.m_indexA}GetShapeA(){return this.m_fixtureA.GetShape()}GetFixtureB(){return this.m_fixtureB}GetChildIndexB(){return this.m_indexB}GetShapeB(){return this.m_fixtureB.GetShape()}FlagForFiltering(){this.m_filterFlag=!0}SetFriction(t){this.m_friction=t}GetFriction(){return this.m_friction}ResetFriction(){this.m_friction=Ms(this.m_fixtureA.m_friction,this.m_fixtureB.m_friction)}SetRestitution(t){this.m_restitution=t}GetRestitution(){return this.m_restitution}ResetRestitution(){this.m_restitution=Is(this.m_fixtureA.m_restitution,this.m_fixtureB.m_restitution)}SetRestitutionThreshold(t){this.m_restitutionThreshold=t}GetRestitutionThreshold(){return this.m_restitutionThreshold}ResetRestitutionThreshold(){this.m_restitutionThreshold=Ts(this.m_fixtureA.m_restitutionThreshold,this.m_fixtureB.m_restitutionThreshold)}SetTangentSpeed(t){this.m_tangentSpeed=t}GetTangentSpeed(){return this.m_tangentSpeed}Reset(t,e,s,i){this.m_islandFlag=!1,this.m_touchingFlag=!1,this.m_enabledFlag=!0,this.m_filterFlag=!1,this.m_bulletHitFlag=!1,this.m_toiFlag=!1,this.m_fixtureA=t,this.m_fixtureB=s,this.m_indexA=e,this.m_indexB=i,this.m_manifold.pointCount=0,this.m_prev=null,this.m_next=null,this.m_nodeA.Reset(),this.m_nodeB.Reset(),this.m_toiCount=0,this.m_friction=Ms(this.m_fixtureA.m_friction,this.m_fixtureB.m_friction),this.m_restitution=Is(this.m_fixtureA.m_restitution,this.m_fixtureB.m_restitution),this.m_restitutionThreshold=Ts(this.m_fixtureA.m_restitutionThreshold,this.m_fixtureB.m_restitutionThreshold)}Update(t){const e=this.m_oldManifold;this.m_oldManifold=this.m_manifold,this.m_manifold=e,this.m_enabledFlag=!0;let s=!1;const i=this.m_touchingFlag,o=this.m_fixtureA.IsSensor(),n=this.m_fixtureB.IsSensor(),r=o||n,a=this.m_fixtureA.GetBody(),c=this.m_fixtureB.GetBody(),m=a.GetTransform(),l=c.GetTransform();if(r){const t=this.GetShapeA(),e=this.GetShapeB();s=(0,gs.b2TestOverlap)(t,this.m_indexA,e,this.m_indexB,m,l),this.m_manifold.pointCount=0}else{this.Evaluate(this.m_manifold,m,l),s=this.m_manifold.pointCount>0;for(let t=0;t<this.m_manifold.pointCount;++t){const e=this.m_manifold.points[t];e.normalImpulse=0,e.tangentImpulse=0;const s=e.id;for(let t=0;t<this.m_oldManifold.pointCount;++t){const i=this.m_oldManifold.points[t];if(i.id.key===s.key){e.normalImpulse=i.normalImpulse,e.tangentImpulse=i.tangentImpulse;break}}}s!==i&&(a.SetAwake(!0),c.SetAwake(!0))}this.m_touchingFlag=s,!i&&s&&t&&t.BeginContact(this),i&&!s&&t&&t.EndContact(this),!r&&s&&t&&t.PreSolve(this,this.m_oldManifold)}},Object.defineProperty(Cs,"__esModule",{value:!0}),Cs.b2CircleContact=void 0;const Gs=P,Ps=Bs;class Rs extends Ps.b2Contact{Evaluate(t,e,s){(0,Gs.b2CollideCircles)(t,this.GetShapeA(),e,this.GetShapeB(),s)}}Cs.b2CircleContact=Rs;var Ls={};Object.defineProperty(Ls,"__esModule",{value:!0}),Ls.b2PolygonContact=void 0;const Fs=j,Js=Bs;class ks extends Js.b2Contact{Evaluate(t,e,s){(0,Fs.b2CollidePolygons)(t,this.GetShapeA(),e,this.GetShapeB(),s)}}Ls.b2PolygonContact=ks;var qs={};Object.defineProperty(qs,"__esModule",{value:!0}),qs.b2PolygonAndCircleContact=void 0;const Os=P,zs=Bs;class js extends zs.b2Contact{Evaluate(t,e,s){(0,Os.b2CollidePolygonAndCircle)(t,this.GetShapeA(),e,this.GetShapeB(),s)}}qs.b2PolygonAndCircleContact=js;var Ns={};Object.defineProperty(Ns,"__esModule",{value:!0}),Ns.b2EdgeAndCircleContact=void 0;const Es=lt,Zs=Bs;class Ws extends Zs.b2Contact{Evaluate(t,e,s){(0,Es.b2CollideEdgeAndCircle)(t,this.GetShapeA(),e,this.GetShapeB(),s)}}Ns.b2EdgeAndCircleContact=Ws;var Xs={};Object.defineProperty(Xs,"__esModule",{value:!0}),Xs.b2EdgeAndPolygonContact=void 0;const Us=lt,Qs=Bs;class Ks extends Qs.b2Contact{Evaluate(t,e,s){(0,Us.b2CollideEdgeAndPolygon)(t,this.GetShapeA(),e,this.GetShapeB(),s)}}Xs.b2EdgeAndPolygonContact=Ks;var Hs={};Object.defineProperty(Hs,"__esModule",{value:!0}),Hs.b2ChainAndCircleContact=void 0;const Ys=lt,$s=ee,ti=Bs;class ei extends ti.b2Contact{Evaluate(t,e,s){const i=ei.Evaluate_s_edge;this.GetShapeA().GetChildEdge(i,this.m_indexA),(0,Ys.b2CollideEdgeAndCircle)(t,i,e,this.GetShapeB(),s)}}Hs.b2ChainAndCircleContact=ei,ei.Evaluate_s_edge=new $s.b2EdgeShape;var si={};Object.defineProperty(si,"__esModule",{value:!0}),si.b2ChainAndPolygonContact=void 0;const ii=lt,oi=ee,ni=Bs;class ri extends ni.b2Contact{Evaluate(t,e,s){const i=ri.Evaluate_s_edge;this.GetShapeA().GetChildEdge(i,this.m_indexA),(0,ii.b2CollideEdgeAndPolygon)(t,i,e,this.GetShapeB(),s)}}si.b2ChainAndPolygonContact=ri,ri.Evaluate_s_edge=new oi.b2EdgeShape,Object.defineProperty(fs,"__esModule",{value:!0}),fs.b2ContactFactory=void 0;const ai=m,ci=Cs,mi=Ls,li=qs,hi=Ns,_i=Xs,bi=Hs,ui=si;fs.b2ContactFactory=class{constructor(){const t=new Array(ai.b2ShapeType.e_typeCount);for(let e=0;e<ai.b2ShapeType.e_typeCount;e++)t[e]=new Array(ai.b2ShapeType.e_typeCount);this.m_registers=t,this.AddType(ci.b2CircleContact,ai.b2ShapeType.e_circle,ai.b2ShapeType.e_circle),this.AddType(li.b2PolygonAndCircleContact,ai.b2ShapeType.e_polygon,ai.b2ShapeType.e_circle),this.AddType(mi.b2PolygonContact,ai.b2ShapeType.e_polygon,ai.b2ShapeType.e_polygon),this.AddType(hi.b2EdgeAndCircleContact,ai.b2ShapeType.e_edge,ai.b2ShapeType.e_circle),this.AddType(_i.b2EdgeAndPolygonContact,ai.b2ShapeType.e_edge,ai.b2ShapeType.e_polygon),this.AddType(bi.b2ChainAndCircleContact,ai.b2ShapeType.e_chain,ai.b2ShapeType.e_circle),this.AddType(ui.b2ChainAndPolygonContact,ai.b2ShapeType.e_chain,ai.b2ShapeType.e_polygon)}AddType(t,e,s){const i=[],o=t=>{i.push(t)};this.m_registers[e][s]={createFcn(e,s,o,n){var r;const a=null!==(r=i.pop())&&void 0!==r?r:new t;return a.Reset(e,s,o,n),a},destroyFcn:o},e!==s&&(this.m_registers[s][e]={createFcn(e,s,o,n){var r;const a=null!==(r=i.pop())&&void 0!==r?r:new t;return a.Reset(o,n,e,s),a},destroyFcn:o})}Create(t,e,s,i){const o=t.GetType(),n=s.GetType(),r=this.m_registers[o][n];return r?r.createFcn(t,e,s,i):null}Destroy(t){const e=t.m_fixtureA.GetType(),s=t.m_fixtureB.GetType(),i=this.m_registers[e][s];null==i||i.destroyFcn(t)}};var di={};Object.defineProperty(di,"__esModule",{value:!0}),di.b2ContactListener=di.b2ContactImpulse=di.b2ContactFilter=di.b2DestructionListener=void 0;const pi=s;di.b2DestructionListener=class{SayGoodbyeJoint(t){}SayGoodbyeFixture(t){}};class yi{ShouldCollide(t,e){const s=t.GetFilterData(),i=e.GetFilterData();return s.groupIndex===i.groupIndex&&0!==s.groupIndex?s.groupIndex>0:0!=(s.maskBits&i.categoryBits)&&0!=(s.categoryBits&i.maskBits)}}di.b2ContactFilter=yi,yi.b2_defaultFilter=new yi;di.b2ContactImpulse=class{constructor(){this.normalImpulses=(0,pi.b2MakeNumberArray)(pi.b2_maxManifoldPoints),this.tangentImpulses=(0,pi.b2MakeNumberArray)(pi.b2_maxManifoldPoints),this.count=0}};class Ai{BeginContact(t){}EndContact(t){}PreSolve(t,e){}PostSolve(t,e){}}di.b2ContactListener=Ai,Ai.b2_defaultListener=new Ai,Object.defineProperty(vs,"__esModule",{value:!0}),vs.b2ContactManager=void 0;const xi=v,Vi=fs,Si=c,vi=di;vs.b2ContactManager=class{constructor(){this.m_broadPhase=new xi.b2BroadPhase,this.m_contactList=null,this.m_contactCount=0,this.m_contactFilter=vi.b2ContactFilter.b2_defaultFilter,this.m_contactListener=vi.b2ContactListener.b2_defaultListener,this.m_contactFactory=new Vi.b2ContactFactory,this.AddPair=(t,e)=>{let s=t.fixture,i=e.fixture,o=t.childIndex,n=e.childIndex,r=s.GetBody(),a=i.GetBody();if(r===a)return;let c=a.GetContactList();for(;c;){if(c.other===r){const t=c.contact.GetFixtureA(),e=c.contact.GetFixtureB(),r=c.contact.GetChildIndexA(),a=c.contact.GetChildIndexB();if(t===s&&e===i&&r===o&&a===n)return;if(t===i&&e===s&&r===n&&a===o)return}c=c.next}if(!1===a.ShouldCollide(r))return;if(this.m_contactFilter&&!this.m_contactFilter.ShouldCollide(s,i))return;const m=this.m_contactFactory.Create(s,o,i,n);null!==m&&(s=m.GetFixtureA(),i=m.GetFixtureB(),o=m.GetChildIndexA(),n=m.GetChildIndexB(),r=s.m_body,a=i.m_body,m.m_prev=null,m.m_next=this.m_contactList,null!==this.m_contactList&&(this.m_contactList.m_prev=m),this.m_contactList=m,m.m_nodeA.other=a,m.m_nodeA.prev=null,m.m_nodeA.next=r.m_contactList,null!==r.m_contactList&&(r.m_contactList.prev=m.m_nodeA),r.m_contactList=m.m_nodeA,m.m_nodeB.other=r,m.m_nodeB.prev=null,m.m_nodeB.next=a.m_contactList,null!==a.m_contactList&&(a.m_contactList.prev=m.m_nodeB),a.m_contactList=m.m_nodeB,++this.m_contactCount)}}FindNewContacts(){this.m_broadPhase.UpdatePairs(this.AddPair)}Destroy(t){const e=t.GetFixtureA(),s=t.GetFixtureB(),i=e.GetBody(),o=s.GetBody();this.m_contactListener&&t.IsTouching()&&this.m_contactListener.EndContact(t),t.m_prev&&(t.m_prev.m_next=t.m_next),t.m_next&&(t.m_next.m_prev=t.m_prev),t===this.m_contactList&&(this.m_contactList=t.m_next),t.m_nodeA.prev&&(t.m_nodeA.prev.next=t.m_nodeA.next),t.m_nodeA.next&&(t.m_nodeA.next.prev=t.m_nodeA.prev),t.m_nodeA===i.m_contactList&&(i.m_contactList=t.m_nodeA.next),t.m_nodeB.prev&&(t.m_nodeB.prev.next=t.m_nodeB.next),t.m_nodeB.next&&(t.m_nodeB.next.prev=t.m_nodeB.prev),t.m_nodeB===o.m_contactList&&(o.m_contactList=t.m_nodeB.next),t.m_manifold.pointCount>0&&!e.IsSensor()&&!s.IsSensor()&&(e.GetBody().SetAwake(!0),s.GetBody().SetAwake(!0)),this.m_contactFactory.Destroy(t),--this.m_contactCount}Collide(){let t=this.m_contactList;for(;t;){const e=t.GetFixtureA(),s=t.GetFixtureB(),i=t.GetChildIndexA(),o=t.GetChildIndexB(),n=e.GetBody(),r=s.GetBody();if(t.m_filterFlag){if(!r.ShouldCollide(n)||this.m_contactFilter&&!this.m_contactFilter.ShouldCollide(e,s)){const e=t;t=e.m_next,this.Destroy(e);continue}t.m_filterFlag=!1}const a=n.IsAwake()&&n.m_type!==Si.b2BodyType.b2_staticBody,c=r.IsAwake()&&r.m_type!==Si.b2BodyType.b2_staticBody;if(!a&&!c){t=t.m_next;continue}const m=e.m_proxies[i].treeNode,l=s.m_proxies[o].treeNode;if(m.aabb.TestOverlap(l.aabb))t.Update(this.m_contactListener),t=t.m_next;else{const e=t;t=e.m_next,this.Destroy(e)}}}};var fi={},Ci={},Bi={};Object.defineProperty(Bi,"__esModule",{value:!0}),Bi.b2SolverData=Bi.b2Velocity=Bi.b2Position=Bi.b2TimeStep=Bi.b2Profile=void 0;const wi=o;Bi.b2Profile=class{constructor(){this.step=0,this.collide=0,this.solve=0,this.solveInit=0,this.solveVelocity=0,this.solvePosition=0,this.broadphase=0,this.solveTOI=0}Reset(){return this.step=0,this.collide=0,this.solve=0,this.solveInit=0,this.solveVelocity=0,this.solvePosition=0,this.broadphase=0,this.solveTOI=0,this}};class gi{constructor(){this.dt=0,this.inv_dt=0,this.dtRatio=0,this.config={velocityIterations:0,positionIterations:0},this.warmStarting=!1}static Create(){return new gi}Copy(t){return this.dt=t.dt,this.inv_dt=t.inv_dt,this.dtRatio=t.dtRatio,this.config={...t.config},this.warmStarting=t.warmStarting,this}}Bi.b2TimeStep=gi;Bi.b2Position=class{constructor(){this.c=new wi.b2Vec2,this.a=0}};Bi.b2Velocity=class{constructor(){this.v=new wi.b2Vec2,this.w=0}};Bi.b2SolverData=class{constructor(){this.step=gi.Create()}},Object.defineProperty(Ci,"__esModule",{value:!0}),Ci.b2ContactSolver=Ci.b2ContactSolverDef=Ci.b2ContactVelocityConstraint=Ci.b2GetBlockSolve=Ci.b2SetBlockSolve=void 0;const Mi=s,Ii=o,Ti=h,Di=Bi;let Gi=!0;Ci.b2SetBlockSolve=function(t){Gi=t},Ci.b2GetBlockSolve=function(){return Gi};class Pi{constructor(){this.rA=new Ii.b2Vec2,this.rB=new Ii.b2Vec2,this.normalImpulse=0,this.tangentImpulse=0,this.normalMass=0,this.tangentMass=0,this.velocityBias=0}}class Ri{constructor(){this.points=(0,Mi.b2MakeArray)(Mi.b2_maxManifoldPoints,Pi),this.normal=new Ii.b2Vec2,this.tangent=new Ii.b2Vec2,this.normalMass=new Ii.b2Mat22,this.K=new Ii.b2Mat22,this.indexA=0,this.indexB=0,this.invMassA=0,this.invMassB=0,this.invIA=0,this.invIB=0,this.friction=0,this.restitution=0,this.threshold=0,this.tangentSpeed=0,this.pointCount=0,this.contactIndex=0}}Ci.b2ContactVelocityConstraint=Ri;class Li{constructor(){this.localPoints=(0,Mi.b2MakeArray)(Mi.b2_maxManifoldPoints,Ii.b2Vec2),this.localNormal=new Ii.b2Vec2,this.localPoint=new Ii.b2Vec2,this.indexA=0,this.indexB=0,this.invMassA=0,this.invMassB=0,this.localCenterA=new Ii.b2Vec2,this.localCenterB=new Ii.b2Vec2,this.invIA=0,this.invIB=0,this.type=Ti.b2ManifoldType.e_circles,this.radiusA=0,this.radiusB=0,this.pointCount=0}}Ci.b2ContactSolverDef=class{constructor(){this.step=Di.b2TimeStep.Create(),this.count=0}};class Fi{constructor(){this.normal=new Ii.b2Vec2,this.point=new Ii.b2Vec2,this.separation=0}Initialize(t,e,s,i){const o=Fi.Initialize_s_pointA,n=Fi.Initialize_s_pointB,r=Fi.Initialize_s_planePoint,a=Fi.Initialize_s_clipPoint;switch(t.type){case Ti.b2ManifoldType.e_circles:Ii.b2Transform.MultiplyVec2(e,t.localPoint,o),Ii.b2Transform.MultiplyVec2(s,t.localPoints[0],n),Ii.b2Vec2.Subtract(n,o,this.normal).Normalize(),Ii.b2Vec2.Mid(o,n,this.point),this.separation=Ii.b2Vec2.Dot(Ii.b2Vec2.Subtract(n,o,Ii.b2Vec2.s_t0),this.normal)-t.radiusA-t.radiusB;break;case Ti.b2ManifoldType.e_faceA:Ii.b2Rot.MultiplyVec2(e.q,t.localNormal,this.normal),Ii.b2Transform.MultiplyVec2(e,t.localPoint,r),Ii.b2Transform.MultiplyVec2(s,t.localPoints[i],a),this.separation=Ii.b2Vec2.Dot(Ii.b2Vec2.Subtract(a,r,Ii.b2Vec2.s_t0),this.normal)-t.radiusA-t.radiusB,this.point.Copy(a);break;case Ti.b2ManifoldType.e_faceB:Ii.b2Rot.MultiplyVec2(s.q,t.localNormal,this.normal),Ii.b2Transform.MultiplyVec2(s,t.localPoint,r),Ii.b2Transform.MultiplyVec2(e,t.localPoints[i],a),this.separation=Ii.b2Vec2.Dot(Ii.b2Vec2.Subtract(a,r,Ii.b2Vec2.s_t0),this.normal)-t.radiusA-t.radiusB,this.point.Copy(a),this.normal.Negate()}}}Fi.Initialize_s_pointA=new Ii.b2Vec2,Fi.Initialize_s_pointB=new Ii.b2Vec2,Fi.Initialize_s_planePoint=new Ii.b2Vec2,Fi.Initialize_s_clipPoint=new Ii.b2Vec2;class Ji{constructor(){this.m_step=Di.b2TimeStep.Create(),this.m_positionConstraints=(0,Mi.b2MakeArray)(1024,Li),this.m_velocityConstraints=(0,Mi.b2MakeArray)(1024,Ri),this.m_count=0}Initialize(t){if(this.m_step.Copy(t.step),this.m_count=t.count,this.m_positionConstraints.length<this.m_count){const t=Math.max(2*this.m_positionConstraints.length,this.m_count);for(;this.m_positionConstraints.length<t;)this.m_positionConstraints[this.m_positionConstraints.length]=new Li}if(this.m_velocityConstraints.length<this.m_count){const t=Math.max(2*this.m_velocityConstraints.length,this.m_count);for(;this.m_velocityConstraints.length<t;)this.m_velocityConstraints[this.m_velocityConstraints.length]=new Ri}this.m_positions=t.positions,this.m_velocities=t.velocities,this.m_contacts=t.contacts;for(let t=0;t<this.m_count;++t){const e=this.m_contacts[t],s=e.m_fixtureA,i=e.m_fixtureB,o=s.GetShape(),n=i.GetShape(),r=o.m_radius,a=n.m_radius,c=s.GetBody(),m=i.GetBody(),l=e.GetManifold(),{pointCount:h}=l,_=this.m_velocityConstraints[t];_.friction=e.m_friction,_.restitution=e.m_restitution,_.threshold=e.m_restitutionThreshold,_.tangentSpeed=e.m_tangentSpeed,_.indexA=c.m_islandIndex,_.indexB=m.m_islandIndex,_.invMassA=c.m_invMass,_.invMassB=m.m_invMass,_.invIA=c.m_invI,_.invIB=m.m_invI,_.contactIndex=t,_.pointCount=h,_.K.SetZero(),_.normalMass.SetZero();const b=this.m_positionConstraints[t];b.indexA=c.m_islandIndex,b.indexB=m.m_islandIndex,b.invMassA=c.m_invMass,b.invMassB=m.m_invMass,b.localCenterA.Copy(c.m_sweep.localCenter),b.localCenterB.Copy(m.m_sweep.localCenter),b.invIA=c.m_invI,b.invIB=m.m_invI,b.localNormal.Copy(l.localNormal),b.localPoint.Copy(l.localPoint),b.pointCount=h,b.radiusA=r,b.radiusB=a,b.type=l.type;for(let t=0;t<h;++t){const e=l.points[t],s=_.points[t];this.m_step.warmStarting?(s.normalImpulse=this.m_step.dtRatio*e.normalImpulse,s.tangentImpulse=this.m_step.dtRatio*e.tangentImpulse):(s.normalImpulse=0,s.tangentImpulse=0),s.rA.SetZero(),s.rB.SetZero(),s.normalMass=0,s.tangentMass=0,s.velocityBias=0,b.localPoints[t].Copy(e.localPoint)}}return this}InitializeVelocityConstraints(){const t=Ji.InitializeVelocityConstraints_s_xfA,e=Ji.InitializeVelocityConstraints_s_xfB,s=Ji.InitializeVelocityConstraints_s_worldManifold;for(let i=0;i<this.m_count;++i){const o=this.m_velocityConstraints[i],n=this.m_positionConstraints[i],{radiusA:r,radiusB:a,localCenterA:c,localCenterB:m}=n,l=this.m_contacts[o.contactIndex].GetManifold(),{indexA:h,indexB:_,tangent:b,pointCount:u}=o,d=o.invMassA,p=o.invMassB,y=o.invIA,A=o.invIB,x=this.m_positions[h].c,V=this.m_positions[h].a,S=this.m_velocities[h].v,v=this.m_velocities[h].w,f=this.m_positions[_].c,C=this.m_positions[_].a,B=this.m_velocities[_].v,w=this.m_velocities[_].w;t.q.Set(V),e.q.Set(C),Ii.b2Vec2.Subtract(x,Ii.b2Rot.MultiplyVec2(t.q,c,Ii.b2Vec2.s_t0),t.p),Ii.b2Vec2.Subtract(f,Ii.b2Rot.MultiplyVec2(e.q,m,Ii.b2Vec2.s_t0),e.p),s.Initialize(l,t,r,e,a),o.normal.Copy(s.normal),Ii.b2Vec2.CrossVec2One(o.normal,b);for(let t=0;t<u;++t){const e=o.points[t];Ii.b2Vec2.Subtract(s.points[t],x,e.rA),Ii.b2Vec2.Subtract(s.points[t],f,e.rB);const i=Ii.b2Vec2.Cross(e.rA,o.normal),n=Ii.b2Vec2.Cross(e.rB,o.normal),r=d+p+y*i*i+A*n*n;e.normalMass=r>0?1/r:0;const a=Ii.b2Vec2.Cross(e.rA,b),c=Ii.b2Vec2.Cross(e.rB,b),m=d+p+y*a*a+A*c*c;e.tangentMass=m>0?1/m:0,e.velocityBias=0;const l=Ii.b2Vec2.Dot(o.normal,Ii.b2Vec2.Subtract(Ii.b2Vec2.AddCrossScalarVec2(B,w,e.rB,Ii.b2Vec2.s_t0),Ii.b2Vec2.AddCrossScalarVec2(S,v,e.rA,Ii.b2Vec2.s_t1),Ii.b2Vec2.s_t0));l<-o.threshold&&(e.velocityBias=-o.restitution*l)}if(2===o.pointCount&&Gi){const t=o.points[0],e=o.points[1],s=Ii.b2Vec2.Cross(t.rA,o.normal),i=Ii.b2Vec2.Cross(t.rB,o.normal),n=Ii.b2Vec2.Cross(e.rA,o.normal),r=Ii.b2Vec2.Cross(e.rB,o.normal),a=d+p+y*s*s+A*i*i,c=d+p+y*n*n+A*r*r,m=d+p+y*s*n+A*i*r;a*a<1e3*(a*c-m*m)?(o.K.ex.Set(a,m),o.K.ey.Set(m,c),o.K.GetInverse(o.normalMass)):o.pointCount=1}}}WarmStart(){const t=Ji.WarmStart_s_P;for(let e=0;e<this.m_count;++e){const s=this.m_velocityConstraints[e],{indexA:i,indexB:o,pointCount:n,normal:r,tangent:a}=s,c=s.invMassA,m=s.invIA,l=s.invMassB,h=s.invIB,_=this.m_velocities[i].v;let b=this.m_velocities[i].w;const u=this.m_velocities[o].v;let d=this.m_velocities[o].w;for(let e=0;e<n;++e){const i=s.points[e];Ii.b2Vec2.Add(Ii.b2Vec2.Scale(i.normalImpulse,r,Ii.b2Vec2.s_t0),Ii.b2Vec2.Scale(i.tangentImpulse,a,Ii.b2Vec2.s_t1),t),b-=m*Ii.b2Vec2.Cross(i.rA,t),_.SubtractScaled(c,t),d+=h*Ii.b2Vec2.Cross(i.rB,t),u.AddScaled(l,t)}this.m_velocities[i].w=b,this.m_velocities[o].w=d}}SolveVelocityConstraints(){const t=Ji.SolveVelocityConstraints_s_dv,e=Ji.SolveVelocityConstraints_s_dv1,s=Ji.SolveVelocityConstraints_s_dv2,i=Ji.SolveVelocityConstraints_s_P,o=Ji.SolveVelocityConstraints_s_a,n=Ji.SolveVelocityConstraints_s_b,r=Ji.SolveVelocityConstraints_s_x,a=Ji.SolveVelocityConstraints_s_d,c=Ji.SolveVelocityConstraints_s_P1,m=Ji.SolveVelocityConstraints_s_P2,l=Ji.SolveVelocityConstraints_s_P1P2;for(let h=0;h<this.m_count;++h){const _=this.m_velocityConstraints[h],{indexA:b,indexB:u,pointCount:d,normal:p,tangent:y,friction:A}=_,x=_.invMassA,V=_.invIA,S=_.invMassB,v=_.invIB,f=this.m_velocities[b].v;let C=this.m_velocities[b].w;const B=this.m_velocities[u].v;let w=this.m_velocities[u].w;for(let e=0;e<d;++e){const s=_.points[e];Ii.b2Vec2.Subtract(Ii.b2Vec2.AddCrossScalarVec2(B,w,s.rB,Ii.b2Vec2.s_t0),Ii.b2Vec2.AddCrossScalarVec2(f,C,s.rA,Ii.b2Vec2.s_t1),t);const o=Ii.b2Vec2.Dot(t,y)-_.tangentSpeed;let n=s.tangentMass*-o;const r=A*s.normalImpulse,a=(0,Ii.b2Clamp)(s.tangentImpulse+n,-r,r);n=a-s.tangentImpulse,s.tangentImpulse=a,Ii.b2Vec2.Scale(n,y,i),f.SubtractScaled(x,i),C-=V*Ii.b2Vec2.Cross(s.rA,i),B.AddScaled(S,i),w+=v*Ii.b2Vec2.Cross(s.rB,i)}if(1===_.pointCount||!1===Gi)for(let e=0;e<d;++e){const s=_.points[e];Ii.b2Vec2.Subtract(Ii.b2Vec2.AddCrossScalarVec2(B,w,s.rB,Ii.b2Vec2.s_t0),Ii.b2Vec2.AddCrossScalarVec2(f,C,s.rA,Ii.b2Vec2.s_t1),t);const o=Ii.b2Vec2.Dot(t,p);let n=-s.normalMass*(o-s.velocityBias);const r=Math.max(s.normalImpulse+n,0);n=r-s.normalImpulse,s.normalImpulse=r,Ii.b2Vec2.Scale(n,p,i),f.SubtractScaled(x,i),C-=V*Ii.b2Vec2.Cross(s.rA,i),B.AddScaled(S,i),w+=v*Ii.b2Vec2.Cross(s.rB,i)}else{const t=_.points[0],i=_.points[1];o.Set(t.normalImpulse,i.normalImpulse),Ii.b2Vec2.Subtract(Ii.b2Vec2.AddCrossScalarVec2(B,w,t.rB,Ii.b2Vec2.s_t0),Ii.b2Vec2.AddCrossScalarVec2(f,C,t.rA,Ii.b2Vec2.s_t1),e),Ii.b2Vec2.Subtract(Ii.b2Vec2.AddCrossScalarVec2(B,w,i.rB,Ii.b2Vec2.s_t0),Ii.b2Vec2.AddCrossScalarVec2(f,C,i.rA,Ii.b2Vec2.s_t1),s);let h=Ii.b2Vec2.Dot(e,p),b=Ii.b2Vec2.Dot(s,p);for(n.x=h-t.velocityBias,n.y=b-i.velocityBias,n.Subtract(Ii.b2Mat22.MultiplyVec2(_.K,o,Ii.b2Vec2.s_t0));;){if(Ii.b2Mat22.MultiplyVec2(_.normalMass,n,r).Negate(),r.x>=0&&r.y>=0){Ii.b2Vec2.Subtract(r,o,a),Ii.b2Vec2.Scale(a.x,p,c),Ii.b2Vec2.Scale(a.y,p,m),Ii.b2Vec2.Add(c,m,l),f.SubtractScaled(x,l),C-=V*(Ii.b2Vec2.Cross(t.rA,c)+Ii.b2Vec2.Cross(i.rA,m)),B.AddScaled(S,l),w+=v*(Ii.b2Vec2.Cross(t.rB,c)+Ii.b2Vec2.Cross(i.rB,m)),t.normalImpulse=r.x,i.normalImpulse=r.y;break}if(r.x=-t.normalMass*n.x,r.y=0,h=0,b=_.K.ex.y*r.x+n.y,r.x>=0&&b>=0){Ii.b2Vec2.Subtract(r,o,a),Ii.b2Vec2.Scale(a.x,p,c),Ii.b2Vec2.Scale(a.y,p,m),Ii.b2Vec2.Add(c,m,l),f.SubtractScaled(x,l),C-=V*(Ii.b2Vec2.Cross(t.rA,c)+Ii.b2Vec2.Cross(i.rA,m)),B.AddScaled(S,l),w+=v*(Ii.b2Vec2.Cross(t.rB,c)+Ii.b2Vec2.Cross(i.rB,m)),t.normalImpulse=r.x,i.normalImpulse=r.y;break}if(r.x=0,r.y=-i.normalMass*n.y,h=_.K.ey.x*r.y+n.x,b=0,r.y>=0&&h>=0){Ii.b2Vec2.Subtract(r,o,a),Ii.b2Vec2.Scale(a.x,p,c),Ii.b2Vec2.Scale(a.y,p,m),Ii.b2Vec2.Add(c,m,l),f.SubtractScaled(x,l),C-=V*(Ii.b2Vec2.Cross(t.rA,c)+Ii.b2Vec2.Cross(i.rA,m)),B.AddScaled(S,l),w+=v*(Ii.b2Vec2.Cross(t.rB,c)+Ii.b2Vec2.Cross(i.rB,m)),t.normalImpulse=r.x,i.normalImpulse=r.y;break}if(r.x=0,r.y=0,h=n.x,b=n.y,h>=0&&b>=0){Ii.b2Vec2.Subtract(r,o,a),Ii.b2Vec2.Scale(a.x,p,c),Ii.b2Vec2.Scale(a.y,p,m),Ii.b2Vec2.Add(c,m,l),f.SubtractScaled(x,l),C-=V*(Ii.b2Vec2.Cross(t.rA,c)+Ii.b2Vec2.Cross(i.rA,m)),B.AddScaled(S,l),w+=v*(Ii.b2Vec2.Cross(t.rB,c)+Ii.b2Vec2.Cross(i.rB,m)),t.normalImpulse=r.x,i.normalImpulse=r.y;break}break}}this.m_velocities[b].w=C,this.m_velocities[u].w=w}}StoreImpulses(){for(let t=0;t<this.m_count;++t){const e=this.m_velocityConstraints[t],s=this.m_contacts[e.contactIndex].GetManifold();for(let t=0;t<e.pointCount;++t)s.points[t].normalImpulse=e.points[t].normalImpulse,s.points[t].tangentImpulse=e.points[t].tangentImpulse}}SolvePositionConstraints(){const t=Ji.SolvePositionConstraints_s_xfA,e=Ji.SolvePositionConstraints_s_xfB,s=Ji.SolvePositionConstraints_s_psm,i=Ji.SolvePositionConstraints_s_rA,o=Ji.SolvePositionConstraints_s_rB,n=Ji.SolvePositionConstraints_s_P;let r=0;for(let a=0;a<this.m_count;++a){const c=this.m_positionConstraints[a],{indexA:m,indexB:l,localCenterA:h,localCenterB:_,pointCount:b}=c,u=c.invMassA,d=c.invIA,p=c.invMassB,y=c.invIB,A=this.m_positions[m].c;let x=this.m_positions[m].a;const V=this.m_positions[l].c;let S=this.m_positions[l].a;for(let a=0;a<b;++a){t.q.Set(x),e.q.Set(S),Ii.b2Vec2.Subtract(A,Ii.b2Rot.MultiplyVec2(t.q,h,Ii.b2Vec2.s_t0),t.p),Ii.b2Vec2.Subtract(V,Ii.b2Rot.MultiplyVec2(e.q,_,Ii.b2Vec2.s_t0),e.p),s.Initialize(c,t,e,a);const{normal:m,point:l,separation:b}=s;Ii.b2Vec2.Subtract(l,A,i),Ii.b2Vec2.Subtract(l,V,o),r=Math.min(r,b);const v=(0,Ii.b2Clamp)(Mi.b2_baumgarte*(b+Mi.b2_linearSlop),-Mi.b2_maxLinearCorrection,0),f=Ii.b2Vec2.Cross(i,m),C=Ii.b2Vec2.Cross(o,m),B=u+p+d*f*f+y*C*C,w=B>0?-v/B:0;Ii.b2Vec2.Scale(w,m,n),A.SubtractScaled(u,n),x-=d*Ii.b2Vec2.Cross(i,n),V.AddScaled(p,n),S+=y*Ii.b2Vec2.Cross(o,n)}this.m_positions[m].c.Copy(A),this.m_positions[m].a=x,this.m_positions[l].c.Copy(V),this.m_positions[l].a=S}return r>=-3*Mi.b2_linearSlop}SolveTOIPositionConstraints(t,e){const s=Ji.SolveTOIPositionConstraints_s_xfA,i=Ji.SolveTOIPositionConstraints_s_xfB,o=Ji.SolveTOIPositionConstraints_s_psm,n=Ji.SolveTOIPositionConstraints_s_rA,r=Ji.SolveTOIPositionConstraints_s_rB,a=Ji.SolveTOIPositionConstraints_s_P;let c=0;for(let m=0;m<this.m_count;++m){const l=this.m_positionConstraints[m],{indexA:h,indexB:_,localCenterA:b,localCenterB:u,pointCount:d}=l;let p=0,y=0;h!==t&&h!==e||(p=l.invMassA,y=l.invIA);let A=0,x=0;_!==t&&_!==e||(A=l.invMassB,x=l.invIB);const V=this.m_positions[h].c;let S=this.m_positions[h].a;const v=this.m_positions[_].c;let f=this.m_positions[_].a;for(let t=0;t<d;++t){s.q.Set(S),i.q.Set(f),Ii.b2Vec2.Subtract(V,Ii.b2Rot.MultiplyVec2(s.q,b,Ii.b2Vec2.s_t0),s.p),Ii.b2Vec2.Subtract(v,Ii.b2Rot.MultiplyVec2(i.q,u,Ii.b2Vec2.s_t0),i.p),o.Initialize(l,s,i,t);const{normal:e,point:m,separation:h}=o;Ii.b2Vec2.Subtract(m,V,n),Ii.b2Vec2.Subtract(m,v,r),c=Math.min(c,h);const _=(0,Ii.b2Clamp)(Mi.b2_toiBaumgarte*(h+Mi.b2_linearSlop),-Mi.b2_maxLinearCorrection,0),d=Ii.b2Vec2.Cross(n,e),C=Ii.b2Vec2.Cross(r,e),B=p+A+y*d*d+x*C*C,w=B>0?-_/B:0;Ii.b2Vec2.Scale(w,e,a),V.SubtractScaled(p,a),S-=y*Ii.b2Vec2.Cross(n,a),v.AddScaled(A,a),f+=x*Ii.b2Vec2.Cross(r,a)}this.m_positions[h].a=S,this.m_positions[_].a=f}return c>=-1.5*Mi.b2_linearSlop}}Ci.b2ContactSolver=Ji,Ji.InitializeVelocityConstraints_s_xfA=new Ii.b2Transform,Ji.InitializeVelocityConstraints_s_xfB=new Ii.b2Transform,Ji.InitializeVelocityConstraints_s_worldManifold=new Ti.b2WorldManifold,Ji.WarmStart_s_P=new Ii.b2Vec2,Ji.SolveVelocityConstraints_s_dv=new Ii.b2Vec2,Ji.SolveVelocityConstraints_s_dv1=new Ii.b2Vec2,Ji.SolveVelocityConstraints_s_dv2=new Ii.b2Vec2,Ji.SolveVelocityConstraints_s_P=new Ii.b2Vec2,Ji.SolveVelocityConstraints_s_a=new Ii.b2Vec2,Ji.SolveVelocityConstraints_s_b=new Ii.b2Vec2,Ji.SolveVelocityConstraints_s_x=new Ii.b2Vec2,Ji.SolveVelocityConstraints_s_d=new Ii.b2Vec2,Ji.SolveVelocityConstraints_s_P1=new Ii.b2Vec2,Ji.SolveVelocityConstraints_s_P2=new Ii.b2Vec2,Ji.SolveVelocityConstraints_s_P1P2=new Ii.b2Vec2,Ji.SolvePositionConstraints_s_xfA=new Ii.b2Transform,Ji.SolvePositionConstraints_s_xfB=new Ii.b2Transform,Ji.SolvePositionConstraints_s_psm=new Fi,Ji.SolvePositionConstraints_s_rA=new Ii.b2Vec2,Ji.SolvePositionConstraints_s_rB=new Ii.b2Vec2,Ji.SolvePositionConstraints_s_P=new Ii.b2Vec2,Ji.SolveTOIPositionConstraints_s_xfA=new Ii.b2Transform,Ji.SolveTOIPositionConstraints_s_xfB=new Ii.b2Transform,Ji.SolveTOIPositionConstraints_s_psm=new Fi,Ji.SolveTOIPositionConstraints_s_rA=new Ii.b2Vec2,Ji.SolveTOIPositionConstraints_s_rB=new Ii.b2Vec2,Ji.SolveTOIPositionConstraints_s_P=new Ii.b2Vec2,Object.defineProperty(fi,"__esModule",{value:!0}),fi.b2Island=void 0;const ki=s,qi=o,Oi=V,zi=Ci,ji=c,Ni=Bi,Ei=di;class Zi{constructor(t,e,s,i){this.m_bodyCount=0,this.m_jointCount=0,this.m_contactCount=0,this.m_bodyCapacity=t,this.m_listener=i,this.m_bodies=new Array(t),this.m_contacts=new Array(e),this.m_joints=new Array(s),this.m_velocities=(0,ki.b2MakeArray)(t,Ni.b2Velocity),this.m_positions=(0,ki.b2MakeArray)(t,Ni.b2Position),this.Resize(t)}Resize(t){for(;this.m_bodyCapacity<t;)this.m_velocities[this.m_bodyCapacity]=new Ni.b2Velocity,this.m_positions[this.m_bodyCapacity]=new Ni.b2Position,this.m_bodyCapacity++}Clear(){this.m_bodyCount=0,this.m_contactCount=0,this.m_jointCount=0}AddBody(t){t.m_islandIndex=this.m_bodyCount,this.m_bodies[this.m_bodyCount]=t,++this.m_bodyCount}AddContact(t){this.m_contacts[this.m_contactCount++]=t}AddJoint(t){this.m_joints[this.m_jointCount++]=t}Solve(t,e,s,i){const o=Zi.s_timer.Reset(),n=e.dt;for(let t=0;t<this.m_bodyCount;++t){const e=this.m_bodies[t];this.m_positions[t].c.Copy(e.m_sweep.c);const{a:i}=e.m_sweep,o=this.m_velocities[t].v.Copy(e.m_linearVelocity);let r=e.m_angularVelocity;e.m_sweep.c0.Copy(e.m_sweep.c),e.m_sweep.a0=e.m_sweep.a,e.m_type===ji.b2BodyType.b2_dynamicBody&&(o.x+=n*e.m_invMass*(e.m_gravityScale*e.m_mass*s.x+e.m_force.x),o.y+=n*e.m_invMass*(e.m_gravityScale*e.m_mass*s.y+e.m_force.y),r+=n*e.m_invI*e.m_torque,o.Scale(1/(1+n*e.m_linearDamping)),r*=1/(1+n*e.m_angularDamping)),this.m_positions[t].a=i,this.m_velocities[t].w=r}o.Reset();const r=Zi.s_solverData;r.step.Copy(e),r.positions=this.m_positions,r.velocities=this.m_velocities;const a=Zi.s_contactSolverDef;a.step.Copy(e),a.contacts=this.m_contacts,a.count=this.m_contactCount,a.positions=this.m_positions,a.velocities=this.m_velocities;const c=Zi.s_contactSolver.Initialize(a);c.InitializeVelocityConstraints(),e.warmStarting&&c.WarmStart();for(let t=0;t<this.m_jointCount;++t)this.m_joints[t].InitVelocityConstraints(r);t.solveInit=o.GetMilliseconds(),o.Reset();for(let t=0;t<e.config.velocityIterations;++t){for(let t=0;t<this.m_jointCount;++t)this.m_joints[t].SolveVelocityConstraints(r);c.SolveVelocityConstraints()}c.StoreImpulses(),t.solveVelocity=o.GetMilliseconds();for(let t=0;t<this.m_bodyCount;++t){const{c:e}=this.m_positions[t];let{a:s}=this.m_positions[t];const{v:i}=this.m_velocities[t];let{w:o}=this.m_velocities[t];const r=qi.b2Vec2.Scale(n,i,Zi.s_translation);if(qi.b2Vec2.Dot(r,r)>ki.b2_maxTranslationSquared){const t=ki.b2_maxTranslation/r.Length();i.Scale(t)}const a=n*o;if(a*a>ki.b2_maxRotationSquared){o*=ki.b2_maxRotation/Math.abs(a)}e.AddScaled(n,i),s+=n*o,this.m_positions[t].a=s,this.m_velocities[t].w=o}o.Reset();let m=!1;for(let t=0;t<e.config.positionIterations;++t){const t=c.SolvePositionConstraints();let e=!0;for(let t=0;t<this.m_jointCount;++t){const s=this.m_joints[t].SolvePositionConstraints(r);e=e&&s}if(t&&e){m=!0;break}}for(let t=0;t<this.m_bodyCount;++t){const e=this.m_bodies[t];e.m_sweep.c.Copy(this.m_positions[t].c),e.m_sweep.a=this.m_positions[t].a,e.m_linearVelocity.Copy(this.m_velocities[t].v),e.m_angularVelocity=this.m_velocities[t].w,e.SynchronizeTransform()}if(t.solvePosition=o.GetMilliseconds(),this.Report(c.m_velocityConstraints),i){let t=ki.b2_maxFloat;const e=ki.b2_linearSleepTolerance*ki.b2_linearSleepTolerance,s=ki.b2_angularSleepTolerance*ki.b2_angularSleepTolerance;for(let i=0;i<this.m_bodyCount;++i){const o=this.m_bodies[i];o.GetType()!==ji.b2BodyType.b2_staticBody&&(!o.m_autoSleepFlag||o.m_angularVelocity*o.m_angularVelocity>s||qi.b2Vec2.Dot(o.m_linearVelocity,o.m_linearVelocity)>e?(o.m_sleepTime=0,t=0):(o.m_sleepTime+=n,t=Math.min(t,o.m_sleepTime)))}if(t>=ki.b2_timeToSleep&&m)for(let t=0;t<this.m_bodyCount;++t){this.m_bodies[t].SetAwake(!1)}}}SolveTOI(t,e,s){for(let t=0;t<this.m_bodyCount;++t){const e=this.m_bodies[t];this.m_positions[t].c.Copy(e.m_sweep.c),this.m_positions[t].a=e.m_sweep.a,this.m_velocities[t].v.Copy(e.m_linearVelocity),this.m_velocities[t].w=e.m_angularVelocity}const i=Zi.s_contactSolverDef;i.contacts=this.m_contacts,i.count=this.m_contactCount,i.step.Copy(t),i.positions=this.m_positions,i.velocities=this.m_velocities;const o=Zi.s_contactSolver.Initialize(i);for(let i=0;i<t.config.positionIterations;++i){if(o.SolveTOIPositionConstraints(e,s))break}this.m_bodies[e].m_sweep.c0.Copy(this.m_positions[e].c),this.m_bodies[e].m_sweep.a0=this.m_positions[e].a,this.m_bodies[s].m_sweep.c0.Copy(this.m_positions[s].c),this.m_bodies[s].m_sweep.a0=this.m_positions[s].a,o.InitializeVelocityConstraints();for(let e=0;e<t.config.velocityIterations;++e)o.SolveVelocityConstraints();const n=t.dt;for(let t=0;t<this.m_bodyCount;++t){const{c:e}=this.m_positions[t];let{a:s}=this.m_positions[t];const{v:i}=this.m_velocities[t];let{w:o}=this.m_velocities[t];const r=qi.b2Vec2.Scale(n,i,Zi.s_translation);if(qi.b2Vec2.Dot(r,r)>ki.b2_maxTranslationSquared){const t=ki.b2_maxTranslation/r.Length();i.Scale(t)}const a=n*o;if(a*a>ki.b2_maxRotationSquared){o*=ki.b2_maxRotation/Math.abs(a)}e.AddScaled(n,i),s+=n*o,this.m_positions[t].a=s,this.m_velocities[t].w=o;const c=this.m_bodies[t];c.m_sweep.c.Copy(e),c.m_sweep.a=s,c.m_linearVelocity.Copy(i),c.m_angularVelocity=o,c.SynchronizeTransform()}this.Report(o.m_velocityConstraints)}Report(t){for(let e=0;e<this.m_contactCount;++e){const s=this.m_contacts[e],i=t[e],o=Zi.s_impulse;o.count=i.pointCount;for(let t=0;t<i.pointCount;++t)o.normalImpulses[t]=i.points[t].normalImpulse,o.tangentImpulses[t]=i.points[t].tangentImpulse;this.m_listener.PostSolve(s,o)}}}fi.b2Island=Zi,Zi.s_timer=new Oi.b2Timer,Zi.s_solverData=new Ni.b2SolverData,Zi.s_contactSolverDef=new zi.b2ContactSolverDef,Zi.s_contactSolver=new zi.b2ContactSolver,Zi.s_translation=new qi.b2Vec2,Zi.s_impulse=new Ei.b2ContactImpulse,Object.defineProperty(_e,"__esModule",{value:!0}),_e.b2World=void 0;const Wi=s,Xi=o,Ui=V,Qi=h,Ki=G,Hi=be,Yi=ue,$i=de,to=Be,eo=Ie,so=Re,io=ke,oo=Ne,no=Qe,ro=ns,ao=hs,co=ps,mo=c,lo=vs,ho=fi,_o=Bi;class bo{constructor(t){this.m_contactManager=new lo.b2ContactManager,this.m_bodyList=null,this.m_jointList=null,this.m_bodyCount=0,this.m_jointCount=0,this.m_gravity=new Xi.b2Vec2,this.m_allowSleep=!0,this.m_destructionListener=null,this.m_inv_dt0=0,this.m_newContacts=!1,this.m_locked=!1,this.m_clearForces=!0,this.m_warmStarting=!0,this.m_continuousPhysics=!0,this.m_subStepping=!1,this.m_stepComplete=!0,this.m_profile=new _o.b2Profile,this.m_island=new ho.b2Island(2*Wi.b2_maxTOIContacts,Wi.b2_maxTOIContacts,0,this.m_contactManager.m_contactListener),this.s_stack=[],this.m_gravity.Copy(t)}static Create(t){return new bo(t)}SetDestructionListener(t){this.m_destructionListener=t}GetDestructionListener(){return this.m_destructionListener}SetContactFilter(t){this.m_contactManager.m_contactFilter=t}SetContactListener(t){this.m_contactManager.m_contactListener=t,this.m_island.m_listener=t}CreateBody(t={}){(0,Wi.b2Assert)(!this.IsLocked());const e=new mo.b2Body(t,this);return e.m_prev=null,e.m_next=this.m_bodyList,this.m_bodyList&&(this.m_bodyList.m_prev=e),this.m_bodyList=e,++this.m_bodyCount,e}DestroyBody(t){var e,s;(0,Wi.b2Assert)(!this.IsLocked());let i=t.m_jointList;for(;i;){const s=i;i=i.next,null===(e=this.m_destructionListener)||void 0===e||e.SayGoodbyeJoint(s.joint),this.DestroyJoint(s.joint),t.m_jointList=i}t.m_jointList=null;let o=t.m_contactList;for(;o;){const t=o;o=o.next,this.m_contactManager.Destroy(t.contact)}t.m_contactList=null;const n=this.m_contactManager.m_broadPhase;let r=t.m_fixtureList;for(;r;){const e=r;r=r.m_next,null===(s=this.m_destructionListener)||void 0===s||s.SayGoodbyeFixture(e),e.DestroyProxies(n),t.m_fixtureList=r,t.m_fixtureCount-=1}t.m_fixtureList=null,t.m_fixtureCount=0,t.m_prev&&(t.m_prev.m_next=t.m_next),t.m_next&&(t.m_next.m_prev=t.m_prev),t===this.m_bodyList&&(this.m_bodyList=t.m_next),--this.m_bodyCount}static Joint_Create(t){switch(t.type){case Hi.b2JointType.e_distanceJoint:return new $i.b2DistanceJoint(t);case Hi.b2JointType.e_mouseJoint:return new io.b2MouseJoint(t);case Hi.b2JointType.e_prismaticJoint:return new oo.b2PrismaticJoint(t);case Hi.b2JointType.e_revoluteJoint:return new ro.b2RevoluteJoint(t);case Hi.b2JointType.e_pulleyJoint:return new no.b2PulleyJoint(t);case Hi.b2JointType.e_gearJoint:return new eo.b2GearJoint(t);case Hi.b2JointType.e_wheelJoint:return new co.b2WheelJoint(t);case Hi.b2JointType.e_weldJoint:return new ao.b2WeldJoint(t);case Hi.b2JointType.e_frictionJoint:return new to.b2FrictionJoint(t);case Hi.b2JointType.e_motorJoint:return new so.b2MotorJoint(t);case Hi.b2JointType.e_areaJoint:return new Yi.b2AreaJoint(t)}throw new Error}CreateJoint(t){(0,Wi.b2Assert)(!this.IsLocked());const e=bo.Joint_Create(t);e.m_prev=null,e.m_next=this.m_jointList,this.m_jointList&&(this.m_jointList.m_prev=e),this.m_jointList=e,++this.m_jointCount,e.m_edgeA.prev=null,e.m_edgeA.next=e.m_bodyA.m_jointList,e.m_bodyA.m_jointList&&(e.m_bodyA.m_jointList.prev=e.m_edgeA),e.m_bodyA.m_jointList=e.m_edgeA,e.m_edgeB.prev=null,e.m_edgeB.next=e.m_bodyB.m_jointList,e.m_bodyB.m_jointList&&(e.m_bodyB.m_jointList.prev=e.m_edgeB),e.m_bodyB.m_jointList=e.m_edgeB;const s=e.m_bodyA,i=e.m_bodyB;if(!t.collideConnected){let t=i.GetContactList();for(;t;)t.other===s&&t.contact.FlagForFiltering(),t=t.next}return e}DestroyJoint(t){(0,Wi.b2Assert)(!this.IsLocked()),t.m_prev&&(t.m_prev.m_next=t.m_next),t.m_next&&(t.m_next.m_prev=t.m_prev),t===this.m_jointList&&(this.m_jointList=t.m_next);const e=t.m_bodyA,s=t.m_bodyB,i=t.m_collideConnected;if(e.SetAwake(!0),s.SetAwake(!0),t.m_edgeA.prev&&(t.m_edgeA.prev.next=t.m_edgeA.next),t.m_edgeA.next&&(t.m_edgeA.next.prev=t.m_edgeA.prev),t.m_edgeA===e.m_jointList&&(e.m_jointList=t.m_edgeA.next),t.m_edgeA.prev=null,t.m_edgeA.next=null,t.m_edgeB.prev&&(t.m_edgeB.prev.next=t.m_edgeB.next),t.m_edgeB.next&&(t.m_edgeB.next.prev=t.m_edgeB.prev),t.m_edgeB===s.m_jointList&&(s.m_jointList=t.m_edgeB.next),t.m_edgeB.prev=null,t.m_edgeB.next=null,--this.m_jointCount,!i){let t=s.GetContactList();for(;t;)t.other===e&&t.contact.FlagForFiltering(),t=t.next}}Step(t,e){const s=bo.Step_s_stepTimer.Reset();this.m_newContacts&&(this.m_contactManager.FindNewContacts(),this.m_newContacts=!1),this.m_locked=!0;const i=bo.Step_s_step;i.dt=t,i.config={...e},i.inv_dt=t>0?1/t:0,i.dtRatio=this.m_inv_dt0*t,i.warmStarting=this.m_warmStarting;{const t=bo.Step_s_timer.Reset();this.m_contactManager.Collide(),this.m_profile.collide=t.GetMilliseconds()}if(this.m_stepComplete&&i.dt>0){const t=bo.Step_s_timer.Reset();this.Solve(i),this.m_profile.solve=t.GetMilliseconds()}if(this.m_continuousPhysics&&i.dt>0){const t=bo.Step_s_timer.Reset();this.SolveTOI(i),this.m_profile.solveTOI=t.GetMilliseconds()}i.dt>0&&(this.m_inv_dt0=i.inv_dt),this.m_clearForces&&this.ClearForces(),this.m_locked=!1,this.m_profile.step=s.GetMilliseconds()}ClearForces(){for(let t=this.m_bodyList;t;t=t.GetNext())t.m_force.SetZero(),t.m_torque=0}QueryAABB(t,e){this.m_contactManager.m_broadPhase.Query(t,(t=>{const s=(0,Wi.b2Verify)(t.userData);return e(s.fixture)}))}QueryAllAABB(t,e=[]){return this.QueryAABB(t,(t=>(e.push(t),!0))),e}QueryPointAABB(t,e){this.m_contactManager.m_broadPhase.QueryPoint(t,(t=>{const s=(0,Wi.b2Verify)(t.userData);return e(s.fixture)}))}QueryAllPointAABB(t,e=[]){return this.QueryPointAABB(t,(t=>(e.push(t),!0))),e}QueryFixtureShape(t,e,s,i){const o=bo.QueryFixtureShape_s_aabb;t.ComputeAABB(o,s,e),this.m_contactManager.m_broadPhase.Query(o,(o=>{const n=(0,Wi.b2Verify)(o.userData),{fixture:r}=n;return!(0,Qi.b2TestOverlap)(t,e,r.GetShape(),n.childIndex,s,r.GetBody().GetTransform())||i(r)}))}QueryAllFixtureShape(t,e,s,i=[]){return this.QueryFixtureShape(t,e,s,(t=>(i.push(t),!0))),i}QueryFixturePoint(t,e){this.m_contactManager.m_broadPhase.QueryPoint(t,(s=>{const i=(0,Wi.b2Verify)(s.userData),{fixture:o}=i;return!o.TestPoint(t)||e(o)}))}QueryAllFixturePoint(t,e=[]){return this.QueryFixturePoint(t,(t=>(e.push(t),!0))),e}RayCast(t,e,s){const i=bo.RayCast_s_input;i.maxFraction=1,i.p1.Copy(t),i.p2.Copy(e),this.m_contactManager.m_broadPhase.RayCast(i,((i,o)=>{const n=(0,Wi.b2Verify)(o.userData),{fixture:r}=n,a=n.childIndex,c=bo.RayCast_s_output;if(r.RayCast(c,i,a)){const{fraction:i}=c,o=bo.RayCast_s_point;return o.Set((1-i)*t.x+i*e.x,(1-i)*t.y+i*e.y),s(r,o,c.normal,i)}return i.maxFraction}))}RayCastOne(t,e){let s=null,i=1;return this.RayCast(t,e,((t,e,o,n)=>(n<i&&(i=n,s=t),i))),s}RayCastAll(t,e,s=[]){return this.RayCast(t,e,(t=>(s.push(t),1))),s}GetBodyList(){return this.m_bodyList}GetJointList(){return this.m_jointList}GetContactList(){return this.m_contactManager.m_contactList}SetAllowSleeping(t){if(t!==this.m_allowSleep&&(this.m_allowSleep=t,!this.m_allowSleep))for(let t=this.m_bodyList;t;t=t.m_next)t.SetAwake(!0)}GetAllowSleeping(){return this.m_allowSleep}SetWarmStarting(t){this.m_warmStarting=t}GetWarmStarting(){return this.m_warmStarting}SetContinuousPhysics(t){this.m_continuousPhysics=t}GetContinuousPhysics(){return this.m_continuousPhysics}SetSubStepping(t){this.m_subStepping=t}GetSubStepping(){return this.m_subStepping}GetProxyCount(){return this.m_contactManager.m_broadPhase.GetProxyCount()}GetBodyCount(){return this.m_bodyCount}GetJointCount(){return this.m_jointCount}GetContactCount(){return this.m_contactManager.m_contactCount}GetTreeHeight(){return this.m_contactManager.m_broadPhase.GetTreeHeight()}GetTreeBalance(){return this.m_contactManager.m_broadPhase.GetTreeBalance()}GetTreeQuality(){return this.m_contactManager.m_broadPhase.GetTreeQuality()}SetGravity(t){this.m_gravity.Copy(t)}GetGravity(){return this.m_gravity}IsLocked(){return this.m_locked}SetAutoClearForces(t){this.m_clearForces=t}GetAutoClearForces(){return this.m_clearForces}ShiftOrigin(t){(0,Wi.b2Assert)(!this.IsLocked());for(let e=this.m_bodyList;e;e=e.m_next)e.m_xf.p.Subtract(t),e.m_sweep.c0.Subtract(t),e.m_sweep.c.Subtract(t);for(let e=this.m_jointList;e;e=e.m_next)e.ShiftOrigin(t);this.m_contactManager.m_broadPhase.ShiftOrigin(t)}GetContactManager(){return this.m_contactManager}GetProfile(){return this.m_profile}Solve(t){this.m_profile.solveInit=0,this.m_profile.solveVelocity=0,this.m_profile.solvePosition=0;const e=this.m_island;e.Resize(this.m_bodyCount),e.Clear();for(let t=this.m_bodyList;t;t=t.m_next)t.m_islandFlag=!1;for(let t=this.m_contactManager.m_contactList;t;t=t.m_next)t.m_islandFlag=!1;for(let t=this.m_jointList;t;t=t.m_next)t.m_islandFlag=!1;const s=this.s_stack;for(let i=this.m_bodyList;i;i=i.m_next){if(i.m_islandFlag)continue;if(!i.IsAwake()||!i.IsEnabled())continue;if(i.GetType()===mo.b2BodyType.b2_staticBody)continue;e.Clear();let o=0;for(s[o++]=i,i.m_islandFlag=!0;o>0;){const t=s[--o];if((0,Wi.b2Assert)(null!==t),e.AddBody(t),t.GetType()!==mo.b2BodyType.b2_staticBody){t.m_awakeFlag=!0;for(let i=t.m_contactList;i;i=i.next){const{contact:t}=i;if(t.m_islandFlag)continue;if(!t.IsEnabled()||!t.IsTouching())continue;const n=t.m_fixtureA.m_isSensor,r=t.m_fixtureB.m_isSensor;if(n||r)continue;e.AddContact(t),t.m_islandFlag=!0;const{other:a}=i;a.m_islandFlag||(s[o++]=a,a.m_islandFlag=!0)}for(let i=t.m_jointList;i;i=i.next){if(i.joint.m_islandFlag)continue;const{other:t}=i;t.IsEnabled()&&(e.AddJoint(i.joint),i.joint.m_islandFlag=!0,t.m_islandFlag||(s[o++]=t,t.m_islandFlag=!0))}}}const n=new _o.b2Profile;e.Solve(n,t,this.m_gravity,this.m_allowSleep),this.m_profile.solveInit+=n.solveInit,this.m_profile.solveVelocity+=n.solveVelocity,this.m_profile.solvePosition+=n.solvePosition;for(let t=0;t<e.m_bodyCount;++t){const s=e.m_bodies[t];s.GetType()===mo.b2BodyType.b2_staticBody&&(s.m_islandFlag=!1)}}for(let t=0;t<s.length&&s[t];++t)s[t]=null;const i=new Ui.b2Timer;for(let t=this.m_bodyList;t;t=t.m_next)t.m_islandFlag&&t.GetType()!==mo.b2BodyType.b2_staticBody&&t.SynchronizeFixtures();this.m_contactManager.FindNewContacts(),this.m_profile.broadphase=i.GetMilliseconds()}SolveTOI(t){const e=this.m_island;if(e.Clear(),this.m_stepComplete){for(let t=this.m_bodyList;t;t=t.m_next)t.m_islandFlag=!1,t.m_sweep.alpha0=0;for(let t=this.m_contactManager.m_contactList;t;t=t.m_next)t.m_toiFlag=!1,t.m_islandFlag=!1,t.m_toiCount=0,t.m_toi=1}for(;;){let s=null,i=1;for(let t=this.m_contactManager.m_contactList;t;t=t.m_next){if(!t.IsEnabled())continue;if(t.m_toiCount>Wi.b2_maxSubSteps)continue;let e=1;if(t.m_toiFlag)e=t.m_toi;else{const s=t.GetFixtureA(),i=t.GetFixtureB();if(s.IsSensor()||i.IsSensor())continue;const o=s.GetBody(),n=i.GetBody(),r=o.m_type,a=n.m_type,c=o.IsAwake()&&r!==mo.b2BodyType.b2_staticBody,m=n.IsAwake()&&a!==mo.b2BodyType.b2_staticBody;if(!c&&!m)continue;const l=o.IsBullet()||r!==mo.b2BodyType.b2_dynamicBody,h=n.IsBullet()||a!==mo.b2BodyType.b2_dynamicBody;if(!l&&!h)continue;let{alpha0:_}=o.m_sweep;o.m_sweep.alpha0<n.m_sweep.alpha0?(_=n.m_sweep.alpha0,o.m_sweep.Advance(_)):n.m_sweep.alpha0<o.m_sweep.alpha0&&(_=o.m_sweep.alpha0,n.m_sweep.Advance(_));const b=t.GetChildIndexA(),u=t.GetChildIndexB(),d=bo.SolveTOI_s_toi_input;d.proxyA.SetShape(s.GetShape(),b),d.proxyB.SetShape(i.GetShape(),u),d.sweepA.Copy(o.m_sweep),d.sweepB.Copy(n.m_sweep),d.tMax=1;const p=bo.SolveTOI_s_toi_output;(0,Ki.b2TimeOfImpact)(p,d);const y=p.t;e=p.state===Ki.b2TOIOutputState.e_touching?Math.min(_+(1-_)*y,1):1,t.m_toi=e,t.m_toiFlag=!0}e<i&&(s=t,i=e)}if(null===s||1-10*Wi.b2_epsilon<i){this.m_stepComplete=!0;break}const o=s.GetFixtureA(),n=s.GetFixtureB(),r=o.GetBody(),a=n.GetBody(),c=bo.SolveTOI_s_backup1.Copy(r.m_sweep),m=bo.SolveTOI_s_backup2.Copy(a.m_sweep);if(r.Advance(i),a.Advance(i),s.Update(this.m_contactManager.m_contactListener),s.m_toiFlag=!1,++s.m_toiCount,!s.IsEnabled()||!s.IsTouching()){s.SetEnabled(!1),r.m_sweep.Copy(c),a.m_sweep.Copy(m),r.SynchronizeTransform(),a.SynchronizeTransform();continue}r.SetAwake(!0),a.SetAwake(!0),e.Clear(),e.AddBody(r),e.AddBody(a),e.AddContact(s),r.m_islandFlag=!0,a.m_islandFlag=!0,s.m_islandFlag=!0;for(let t=0;t<2;++t){const s=0===t?r:a;if(s.m_type===mo.b2BodyType.b2_dynamicBody)for(let t=s.m_contactList;t&&e.m_bodyCount!==e.m_bodyCapacity&&e.m_contactCount!==Wi.b2_maxTOIContacts;t=t.next){const{contact:o}=t;if(o.m_islandFlag)continue;const{other:n}=t;if(n.m_type===mo.b2BodyType.b2_dynamicBody&&!s.IsBullet()&&!n.IsBullet())continue;const r=o.m_fixtureA.m_isSensor,a=o.m_fixtureB.m_isSensor;if(r||a)continue;const c=bo.SolveTOI_s_backup.Copy(n.m_sweep);n.m_islandFlag||n.Advance(i),o.Update(this.m_contactManager.m_contactListener),o.IsEnabled()&&o.IsTouching()?(o.m_islandFlag=!0,e.AddContact(o),n.m_islandFlag||(n.m_islandFlag=!0,n.m_type!==mo.b2BodyType.b2_staticBody&&n.SetAwake(!0),e.AddBody(n))):(n.m_sweep.Copy(c),n.SynchronizeTransform())}}const l=bo.SolveTOI_s_subStep;l.dt=(1-i)*t.dt,l.inv_dt=1/l.dt,l.dtRatio=1,l.config={...t.config,positionIterations:20},l.warmStarting=!1,e.SolveTOI(l,r.m_islandIndex,a.m_islandIndex);for(let t=0;t<e.m_bodyCount;++t){const s=e.m_bodies[t];if(s.m_islandFlag=!1,s.m_type===mo.b2BodyType.b2_dynamicBody){s.SynchronizeFixtures();for(let t=s.m_contactList;t;t=t.next)t.contact.m_toiFlag=!1,t.contact.m_islandFlag=!1}}if(this.m_contactManager.FindNewContacts(),this.m_subStepping){this.m_stepComplete=!1;break}}}}_e.b2World=bo,bo.Step_s_step=_o.b2TimeStep.Create(),bo.Step_s_stepTimer=new Ui.b2Timer,bo.Step_s_timer=new Ui.b2Timer,bo.QueryFixtureShape_s_aabb=new Qi.b2AABB,bo.RayCast_s_input=new Qi.b2RayCastInput,bo.RayCast_s_output=new Qi.b2RayCastOutput,bo.RayCast_s_point=new Xi.b2Vec2,bo.SolveTOI_s_subStep=_o.b2TimeStep.Create(),bo.SolveTOI_s_backup=new Xi.b2Sweep,bo.SolveTOI_s_backup1=new Xi.b2Sweep,bo.SolveTOI_s_backup2=new Xi.b2Sweep,bo.SolveTOI_s_toi_input=new Ki.b2TOIInput,bo.SolveTOI_s_toi_output=new Ki.b2TOIOutput;var uo={};!function(t){Object.defineProperty(t,"__esModule",{value:!0}),t.b2Rope=t.b2RopeTuning=t.b2BendingModel=t.b2StretchingModel=void 0;const e=s,i=n,r=o,a={J1:new r.b2Vec2,J2:new r.b2Vec2,J3:new r.b2Vec2,r:new r.b2Vec2,e1:new r.b2Vec2,e2:new r.b2Vec2,Jd1:new r.b2Vec2,Jd2:new r.b2Vec2,d:new r.b2Vec2,u:new r.b2Vec2,dp1:new r.b2Vec2,dp2:new r.b2Vec2,dp3:new r.b2Vec2,d1:new r.b2Vec2,d2:new r.b2Vec2,dHat:new r.b2Vec2};var c,m;!function(t){t[t.b2_pbdStretchingModel=0]="b2_pbdStretchingModel",t[t.b2_xpbdStretchingModel=1]="b2_xpbdStretchingModel"}(c=t.b2StretchingModel||(t.b2StretchingModel={})),function(t){t[t.b2_springAngleBendingModel=0]="b2_springAngleBendingModel",t[t.b2_pbdAngleBendingModel=1]="b2_pbdAngleBendingModel",t[t.b2_xpbdAngleBendingModel=2]="b2_xpbdAngleBendingModel",t[t.b2_pbdDistanceBendingModel=3]="b2_pbdDistanceBendingModel",t[t.b2_pbdHeightBendingModel=4]="b2_pbdHeightBendingModel",t[t.b2_pbdTriangleBendingModel=5]="b2_pbdTriangleBendingModel"}(m=t.b2BendingModel||(t.b2BendingModel={}));class l{constructor(){this.stretchingModel=c.b2_pbdStretchingModel,this.bendingModel=m.b2_pbdAngleBendingModel,this.damping=0,this.stretchStiffness=1,this.stretchHertz=0,this.stretchDamping=0,this.bendStiffness=.5,this.bendHertz=1,this.bendDamping=0,this.isometric=!1,this.fixedEffectiveMass=!1,this.warmStart=!1}Copy(t){return this.stretchingModel=t.stretchingModel,this.bendingModel=t.bendingModel,this.damping=t.damping,this.stretchStiffness=t.stretchStiffness,this.stretchHertz=t.stretchHertz,this.stretchDamping=t.stretchDamping,this.bendStiffness=t.bendStiffness,this.bendHertz=t.bendHertz,this.bendDamping=t.bendDamping,this.isometric=t.isometric,this.fixedEffectiveMass=t.fixedEffectiveMass,this.warmStart=t.warmStart,this}}t.b2RopeTuning=l;class h{constructor(){this.i1=0,this.i2=0,this.invMass1=0,this.invMass2=0,this.L=0,this.lambda=0,this.spring=0,this.damper=0}}class _{constructor(){this.i1=0,this.i2=0,this.i3=0,this.invMass1=0,this.invMass2=0,this.invMass3=0,this.invEffectiveMass=0,this.lambda=0,this.L1=0,this.L2=0,this.alpha1=0,this.alpha2=0,this.spring=0,this.damper=0}}t.b2Rope=class{constructor(t){this.m_position=new r.b2Vec2,this.m_count=0,this.m_stretchCount=0,this.m_bendCount=0,this.m_gravity=new r.b2Vec2,this.m_tuning=new l,(0,e.b2Assert)(t.vertices.length>=3),this.m_position.Copy(t.position),this.m_count=t.vertices.length,this.m_bindPositions=(0,e.b2MakeArray)(this.m_count,r.b2Vec2),this.m_ps=(0,e.b2MakeArray)(this.m_count,r.b2Vec2),this.m_p0s=(0,e.b2MakeArray)(this.m_count,r.b2Vec2),this.m_vs=(0,e.b2MakeArray)(this.m_count,r.b2Vec2),this.m_invMasses=(0,e.b2MakeNumberArray)(this.m_count);for(let e=0;e<this.m_count;++e){this.m_bindPositions[e].Copy(t.vertices[e]),r.b2Vec2.Add(t.vertices[e],this.m_position,this.m_ps[e]),r.b2Vec2.Add(t.vertices[e],this.m_position,this.m_p0s[e]),this.m_vs[e].SetZero();const s=t.masses[e];this.m_invMasses[e]=s>0?1/s:0}this.m_stretchCount=this.m_count-1,this.m_bendCount=this.m_count-2,this.m_stretchConstraints=new Array(this.m_stretchCount);for(let t=0;t<this.m_stretchCount;t++)this.m_stretchConstraints[t]=new h;this.m_bendConstraints=new Array(this.m_bendCount);for(let t=0;t<this.m_bendCount;t++)this.m_bendConstraints[t]=new _;for(let t=0;t<this.m_stretchCount;++t){const e=this.m_stretchConstraints[t],s=this.m_ps[t],i=this.m_ps[t+1];e.i1=t,e.i2=t+1,e.L=r.b2Vec2.Distance(s,i),e.invMass1=this.m_invMasses[t],e.invMass2=this.m_invMasses[t+1],e.lambda=0,e.damper=0,e.spring=0}const{J1:s,J2:i,r:o,e1:n,e2:c,Jd1:m,Jd2:b}=a;for(let t=0;t<this.m_bendCount;++t){const e=this.m_bendConstraints[t],a=this.m_ps[t],l=this.m_ps[t+1],h=this.m_ps[t+2];e.i1=t,e.i2=t+1,e.i3=t+2,e.invMass1=this.m_invMasses[t],e.invMass2=this.m_invMasses[t+1],e.invMass3=this.m_invMasses[t+2],e.invEffectiveMass=0,e.L1=r.b2Vec2.Distance(a,l),e.L2=r.b2Vec2.Distance(l,h),e.lambda=0,r.b2Vec2.Subtract(l,a,n),r.b2Vec2.Subtract(h,l,c);const _=n.LengthSquared(),u=c.LengthSquared();if(_*u==0)continue;r.b2Vec2.Skew(n,m).Scale(-1/_),r.b2Vec2.Skew(c,b).Scale(1/u),r.b2Vec2.Negate(m,s),r.b2Vec2.Subtract(m,b,i);const d=b;e.invEffectiveMass=e.invMass1*r.b2Vec2.Dot(s,s)+e.invMass2*r.b2Vec2.Dot(i,i)+e.invMass3*r.b2Vec2.Dot(d,d),r.b2Vec2.Subtract(h,a,o);const p=o.LengthSquared();0!==p&&(e.alpha1=r.b2Vec2.Dot(c,o)/p,e.alpha2=r.b2Vec2.Dot(n,o)/p)}this.m_gravity.Copy(t.gravity),this.SetTuning(t.tuning)}SetTuning(t){this.m_tuning.Copy(t);const e=2*Math.PI*this.m_tuning.bendHertz;for(let t=0;t<this.m_bendCount;++t){const s=this.m_bendConstraints[t],i=s.L1*s.L1,o=s.L2*s.L2;if(i*o==0){s.spring=0,s.damper=0;continue}const n=1/s.L1+1/s.L2,r=s.invMass1/i+s.invMass2*n*n+s.invMass3/o;if(0===r){s.spring=0,s.damper=0;continue}const a=1/r;s.spring=a*e*e,s.damper=2*a*this.m_tuning.bendDamping*e}const s=2*Math.PI*this.m_tuning.stretchHertz;for(let t=0;t<this.m_stretchCount;++t){const e=this.m_stretchConstraints[t],i=e.invMass1+e.invMass2;if(0===i)continue;const o=1/i;e.spring=o*s*s,e.damper=2*o*this.m_tuning.stretchDamping*s}}Step(t,e,s){if(0===t)return;const i=1/t,o=Math.exp(-t*this.m_tuning.damping);for(let e=0;e<this.m_count;++e)this.m_invMasses[e]>0?(this.m_vs[e].Scale(o),this.m_vs[e].AddScaled(t,this.m_gravity)):(this.m_vs[e].x=i*(this.m_bindPositions[e].x+s.x-this.m_p0s[e].x),this.m_vs[e].y=i*(this.m_bindPositions[e].y+s.y-this.m_p0s[e].y));this.m_tuning.bendingModel===m.b2_springAngleBendingModel&&this.ApplyBendForces(t);for(let t=0;t<this.m_bendCount;++t)this.m_bendConstraints[t].lambda=0;for(let t=0;t<this.m_stretchCount;++t)this.m_stretchConstraints[t].lambda=0;for(let e=0;e<this.m_count;++e)this.m_ps[e].AddScaled(t,this.m_vs[e]);for(let s=0;s<e;++s)this.m_tuning.bendingModel===m.b2_pbdAngleBendingModel?this.SolveBend_PBD_Angle():this.m_tuning.bendingModel===m.b2_xpbdAngleBendingModel?this.SolveBend_XPBD_Angle(t):this.m_tuning.bendingModel===m.b2_pbdDistanceBendingModel?this.SolveBend_PBD_Distance():this.m_tuning.bendingModel===m.b2_pbdHeightBendingModel?this.SolveBend_PBD_Height():this.m_tuning.bendingModel===m.b2_pbdTriangleBendingModel&&this.SolveBend_PBD_Triangle(),this.m_tuning.stretchingModel===c.b2_pbdStretchingModel?this.SolveStretch_PBD():this.m_tuning.stretchingModel===c.b2_xpbdStretchingModel&&this.SolveStretch_XPBD(t);for(let t=0;t<this.m_count;++t)this.m_vs[t].x=i*(this.m_ps[t].x-this.m_p0s[t].x),this.m_vs[t].y=i*(this.m_ps[t].y-this.m_p0s[t].y),this.m_p0s[t].Copy(this.m_ps[t])}Reset(t){this.m_position.Copy(t);for(let t=0;t<this.m_count;++t)r.b2Vec2.Add(this.m_bindPositions[t],this.m_position,this.m_ps[t]),this.m_p0s[t].Copy(this.m_ps[t]),this.m_vs[t].SetZero();for(let t=0;t<this.m_bendCount;++t)this.m_bendConstraints[t].lambda=0;for(let t=0;t<this.m_stretchCount;++t)this.m_stretchConstraints[t].lambda=0}SolveStretch_PBD(){const t=this.m_tuning.stretchStiffness,{d:e}=a;for(let s=0;s<this.m_stretchCount;++s){const i=this.m_stretchConstraints[s],o=this.m_ps[i.i1],n=this.m_ps[i.i2];r.b2Vec2.Subtract(n,o,e);const a=e.Normalize(),c=i.invMass1+i.invMass2;if(0===c)continue;const m=i.invMass1/c,l=i.invMass2/c;o.SubtractScaled(t*m*(i.L-a),e),n.AddScaled(t*l*(i.L-a),e)}}SolveStretch_XPBD(t){const{dp1:e,dp2:s,u:i,J1:o}=a;for(let n=0;n<this.m_stretchCount;++n){const a=this.m_stretchConstraints[n],c=this.m_ps[a.i1],m=this.m_ps[a.i2];r.b2Vec2.Subtract(c,this.m_p0s[a.i1],e),r.b2Vec2.Subtract(m,this.m_p0s[a.i2],s),r.b2Vec2.Subtract(m,c,i);const l=i.Normalize();r.b2Vec2.Negate(i,o);const h=i,_=a.invMass1+a.invMass2;if(0===_)continue;const b=1/(a.spring*t*t),u=b*(t*t*a.damper)/t,d=l-a.L,p=r.b2Vec2.Dot(o,e)+r.b2Vec2.Dot(h,s),y=-(d+b*a.lambda+u*p)/((1+u)*_+b);c.AddScaled(a.invMass1*y,o),m.AddScaled(a.invMass2*y,h),a.lambda+=y}}SolveBend_PBD_Angle(){const t=this.m_tuning.bendStiffness,{Jd1:e,Jd2:s,J1:i,J2:o,d1:n,d2:c}=a;for(let a=0;a<this.m_bendCount;++a){const m=this.m_bendConstraints[a],l=this.m_ps[m.i1],h=this.m_ps[m.i2],_=this.m_ps[m.i3];r.b2Vec2.Subtract(h,l,n),r.b2Vec2.Subtract(_,h,c);const b=r.b2Vec2.Cross(n,c),u=r.b2Vec2.Dot(n,c),d=Math.atan2(b,u);let p,y;if(this.m_tuning.isometric?(p=m.L1*m.L1,y=m.L2*m.L2):(p=n.LengthSquared(),y=c.LengthSquared()),p*y==0)continue;r.b2Vec2.Skew(n,e).Scale(-1/p),r.b2Vec2.Skew(c,s).Scale(1/y),r.b2Vec2.Negate(e,i),r.b2Vec2.Subtract(e,s,o);const A=s;let x;x=this.m_tuning.fixedEffectiveMass?m.invEffectiveMass:m.invMass1*r.b2Vec2.Dot(i,i)+m.invMass2*r.b2Vec2.Dot(o,o)+m.invMass3*r.b2Vec2.Dot(A,A),0===x&&(x=m.invEffectiveMass);const V=-t*d/x;l.AddScaled(m.invMass1*V,i),h.AddScaled(m.invMass2*V,o),_.AddScaled(m.invMass3*V,A)}}SolveBend_XPBD_Angle(t){const{dp1:e,dp2:s,dp3:i,d1:o,d2:n,Jd1:c,Jd2:m,J1:l,J2:h}=a;for(let a=0;a<this.m_bendCount;++a){const _=this.m_bendConstraints[a],b=this.m_ps[_.i1],u=this.m_ps[_.i2],d=this.m_ps[_.i3];let p,y;if(r.b2Vec2.Subtract(b,this.m_p0s[_.i1],e),r.b2Vec2.Subtract(u,this.m_p0s[_.i2],s),r.b2Vec2.Subtract(d,this.m_p0s[_.i3],i),r.b2Vec2.Subtract(u,b,o),r.b2Vec2.Subtract(d,u,n),this.m_tuning.isometric?(p=_.L1*_.L1,y=_.L2*_.L2):(p=o.LengthSquared(),y=n.LengthSquared()),p*y==0)continue;const A=r.b2Vec2.Cross(o,n),x=r.b2Vec2.Dot(o,n),V=Math.atan2(A,x);r.b2Vec2.Skew(o,c).Scale(-1/p),r.b2Vec2.Skew(n,m).Scale(1/y),r.b2Vec2.Negate(c,l),r.b2Vec2.Subtract(c,m,h);const S=m;let v;if(v=this.m_tuning.fixedEffectiveMass?_.invEffectiveMass:_.invMass1*r.b2Vec2.Dot(l,l)+_.invMass2*r.b2Vec2.Dot(h,h)+_.invMass3*r.b2Vec2.Dot(S,S),0===v)continue;const f=1/(_.spring*t*t),C=f*(t*t*_.damper)/t,B=V,w=r.b2Vec2.Dot(l,e)+r.b2Vec2.Dot(h,s)+r.b2Vec2.Dot(S,i),g=-(B+f*_.lambda+C*w)/((1+C)*v+f);b.AddScaled(_.invMass1*g,l),u.AddScaled(_.invMass2*g,h),d.AddScaled(_.invMass3*g,S),_.lambda+=g}}SolveBend_PBD_Distance(){const t=this.m_tuning.bendStiffness,{d:e}=a;for(let s=0;s<this.m_bendCount;++s){const i=this.m_bendConstraints[s],{i1:o}=i,n=i.i3,a=this.m_ps[o],c=this.m_ps[n];r.b2Vec2.Subtract(c,a,e);const m=e.Normalize(),l=i.invMass1+i.invMass3;if(0===l)continue;const h=i.invMass1/l,_=i.invMass3/l;a.SubtractScaled(t*h*(i.L1+i.L2-m),e),c.AddScaled(t*_*(i.L1+i.L2-m),e)}}SolveBend_PBD_Height(){const t=this.m_tuning.bendStiffness,{dHat:e,J1:s,J2:i,J3:o,d:n}=a;for(let a=0;a<this.m_bendCount;++a){const c=this.m_bendConstraints[a],m=this.m_ps[c.i1],l=this.m_ps[c.i2],h=this.m_ps[c.i3];n.x=c.alpha1*m.x+c.alpha2*h.x-l.x,n.y=c.alpha1*m.y+c.alpha2*h.y-l.y;const _=n.Length();if(0===_)continue;r.b2Vec2.Scale(1/_,n,e),r.b2Vec2.Scale(c.alpha1,e,s),r.b2Vec2.Negate(e,i),r.b2Vec2.Scale(c.alpha2,e,o);const b=c.invMass1*c.alpha1*c.alpha1+c.invMass2+c.invMass3*c.alpha2*c.alpha2;if(0===b)continue;const u=-t*(1/b)*_;m.AddScaled(c.invMass1*u,s),l.AddScaled(c.invMass2*u,i),h.AddScaled(c.invMass3*u,o)}}SolveBend_PBD_Triangle(){const t=this.m_tuning.bendStiffness,{d:e}=a;for(let s=0;s<this.m_bendCount;++s){const i=this.m_bendConstraints[s],o=this.m_ps[i.i1],n=this.m_ps[i.i2],r=this.m_ps[i.i3],a=i.invMass1,c=i.invMass2,m=i.invMass3,l=t/(a+m+2*c);e.x=n.x-1/3*(o.x+n.x+r.x),e.y=n.y-1/3*(o.y+n.y+r.y),o.AddScaled(2*a*l,e),n.AddScaled(-4*c*l,e),r.AddScaled(2*m*l,e)}}ApplyBendForces(t){const e=2*Math.PI*this.m_tuning.bendHertz,{d1:s,d2:i,Jd1:o,Jd2:n,J1:c,J2:m}=a;for(let a=0;a<this.m_bendCount;++a){const l=this.m_bendConstraints[a],h=this.m_ps[l.i1],_=this.m_ps[l.i2],b=this.m_ps[l.i3],u=this.m_vs[l.i1],d=this.m_vs[l.i2],p=this.m_vs[l.i3];let y,A;if(r.b2Vec2.Subtract(_,h,s),r.b2Vec2.Subtract(b,_,i),this.m_tuning.isometric?(y=l.L1*l.L1,A=l.L2*l.L2):(y=s.LengthSquared(),A=i.LengthSquared()),y*A==0)continue;const x=r.b2Vec2.Cross(s,i),V=r.b2Vec2.Dot(s,i),S=Math.atan2(x,V);r.b2Vec2.Skew(s,o).Scale(-1/y),r.b2Vec2.Skew(i,n).Scale(1/A),r.b2Vec2.Negate(o,c),r.b2Vec2.Subtract(o,n,m);const v=n;let f;if(f=this.m_tuning.fixedEffectiveMass?l.invEffectiveMass:l.invMass1*r.b2Vec2.Dot(c,c)+l.invMass2*r.b2Vec2.Dot(m,m)+l.invMass3*r.b2Vec2.Dot(v,v),0===f)continue;const C=1/f,B=-t*(C*e*e*S+2*C*this.m_tuning.bendDamping*e*(r.b2Vec2.Dot(c,u)+r.b2Vec2.Dot(m,d)+r.b2Vec2.Dot(v,p)));this.m_vs[l.i1].AddScaled(l.invMass1*B,c),this.m_vs[l.i2].AddScaled(l.invMass2*B,m),this.m_vs[l.i3].AddScaled(l.invMass3*B,v)}}Draw(t){for(let e=0;e<this.m_count-1;++e){t.DrawSegment(this.m_ps[e],this.m_ps[e+1],i.debugColors.rope);const s=this.m_invMasses[e]>0?i.debugColors.ropePointD:i.debugColors.ropePointG;t.DrawPoint(this.m_ps[e],5,s)}const e=this.m_invMasses[this.m_count-1]>0?i.debugColors.ropePointD:i.debugColors.ropePointG;t.DrawPoint(this.m_ps[this.m_count-1],5,e)}}}(uo),function(e){var r=t&&t.__createBinding||(Object.create?function(t,e,s,i){void 0===i&&(i=s);var o=Object.getOwnPropertyDescriptor(e,s);o&&!("get"in o?!e.__esModule:o.writable||o.configurable)||(o={enumerable:!0,get:function(){return e[s]}}),Object.defineProperty(t,i,o)}:function(t,e,s,i){void 0===i&&(i=s),t[i]=e[s]}),b=t&&t.__exportStar||function(t,e){for(var s in t)"default"===s||Object.prototype.hasOwnProperty.call(e,s)||r(e,t,s)};Object.defineProperty(e,"__esModule",{value:!0}),e.b2GetBlockSolve=e.b2SetBlockSolve=e.b2World=e.b2BodyType=e.b2Body=void 0,b(s,e),b(i,e),b(o,e),b(n,e),b(a,e),b(V,e),b(S,e),b(h,e),b(_,e),b(v,e),b(f,e),b(G,e),b(P,e),b(j,e),b(lt,e),b(m,e),b(jt,e),b(Xt,e),b(ee,e),b(re,e),b(l,e);var u=c;Object.defineProperty(e,"b2Body",{enumerable:!0,get:function(){return u.b2Body}}),Object.defineProperty(e,"b2BodyType",{enumerable:!0,get:function(){return u.b2BodyType}});var d=_e;Object.defineProperty(e,"b2World",{enumerable:!0,get:function(){return d.b2World}}),b(di,e),b(Bi,e),b(vs,e),b(Bs,e),b(fs,e);var p=Ci;Object.defineProperty(e,"b2SetBlockSolve",{enumerable:!0,get:function(){return p.b2SetBlockSolve}}),Object.defineProperty(e,"b2GetBlockSolve",{enumerable:!0,get:function(){return p.b2GetBlockSolve}}),b(be,e),b(ue,e),b(de,e),b(Be,e),b(Ie,e),b(Re,e),b(ke,e),b(Ne,e),b(Qe,e),b(ns,e),b(hs,e),b(ps,e),b(uo,e)}(e);var po=e.DrawAABBs,yo=e.DrawCenterOfMasses,Ao=e.DrawJoints,xo=e.DrawPairs,Vo=e.DrawShapes,So=e.GetShapeColor,vo=e.__esModule,fo=e.b2AABB,Co=e.b2AngularStiffness,Bo=e.b2AreaJoint,wo=e.b2AreaJointDef,go=e.b2Assert,Mo=e.b2BendingModel,Io=e.b2Body,To=e.b2BodyType,Do=e.b2BroadPhase,Go=e.b2ChainShape,Po=e.b2CircleShape,Ro=e.b2Clamp,Lo=e.b2ClipSegmentToLine,Fo=e.b2ClipVertex,Jo=e.b2CollideCircles,ko=e.b2CollideEdgeAndCircle,qo=e.b2CollideEdgeAndPolygon,Oo=e.b2CollidePolygonAndCircle,zo=e.b2CollidePolygons,jo=e.b2Color,No=e.b2Contact,Eo=e.b2ContactEdge,Zo=e.b2ContactFactory,Wo=e.b2ContactFeature,Xo=e.b2ContactFeatureType,Uo=e.b2ContactFilter,Qo=e.b2ContactID,Ko=e.b2ContactImpulse,Ho=e.b2ContactListener,Yo=e.b2ContactManager,$o=e.b2DefaultFilter,tn=e.b2DegToRad,en=e.b2DestructionListener,sn=e.b2Distance,on=e.b2DistanceInput,nn=e.b2DistanceJoint,rn=e.b2DistanceJointDef,an=e.b2DistanceOutput,cn=e.b2DistanceProxy,mn=e.b2DynamicTree,ln=e.b2EdgeShape,hn=e.b2Fixture,_n=e.b2FixtureProxy,bn=e.b2FrictionJoint,un=e.b2FrictionJointDef,dn=e.b2GearJoint,pn=e.b2GearJointDef,yn=e.b2GetBlockSolve,An=e.b2GetPointStates,xn=e.b2Gjk,Vn=e.b2IsPowerOfTwo,Sn=e.b2Joint,vn=e.b2JointDef,fn=e.b2JointEdge,Cn=e.b2JointType,Bn=e.b2LinearStiffness,wn=e.b2MakeArray,gn=e.b2MakeBooleanArray,Mn=e.b2MakeNumberArray,In=e.b2Manifold,Tn=e.b2ManifoldPoint,Dn=e.b2ManifoldType,Gn=e.b2MassData,Pn=e.b2Mat22,Rn=e.b2Mat33,Ln=e.b2MixFriction,Fn=e.b2MixRestitution,Jn=e.b2MixRestitutionThreshold,kn=e.b2MotorJoint,qn=e.b2MotorJointDef,On=e.b2MouseJoint,zn=e.b2MouseJointDef,jn=e.b2NextPowerOfTwo,Nn=e.b2PointState,En=e.b2PolygonShape,Zn=e.b2Position,Wn=e.b2PrismaticJoint,Xn=e.b2PrismaticJointDef,Un=e.b2Profile,Qn=e.b2PulleyJoint,Kn=e.b2PulleyJointDef,Hn=e.b2RadToDeg,Yn=e.b2Random,$n=e.b2RandomFloat,tr=e.b2RandomInt,er=e.b2RayCastInput,sr=e.b2RayCastOutput,ir=e.b2RevoluteJoint,or=e.b2RevoluteJointDef,nr=e.b2Rope,rr=e.b2RopeTuning,ar=e.b2Rot,cr=e.b2SetBlockSolve,mr=e.b2Shape,lr=e.b2ShapeCast,hr=e.b2ShapeCastInput,_r=e.b2ShapeCastOutput,br=e.b2ShapeType,ur=e.b2SimplexCache,dr=e.b2SolverData,pr=e.b2StretchingModel,yr=e.b2Sweep,Ar=e.b2TOIInput,xr=e.b2TOIOutput,Vr=e.b2TOIOutputState,Sr=e.b2TestOverlap,vr=e.b2TimeOfImpact,fr=e.b2TimeStep,Cr=e.b2Timer,Br=e.b2Toi,wr=e.b2Transform,gr=e.b2TreeNode,Mr=e.b2Vec2,Ir=e.b2Vec3,Tr=e.b2Velocity,Dr=e.b2Verify,Gr=e.b2WeldJoint,Pr=e.b2WeldJointDef,Rr=e.b2WheelJoint,Lr=e.b2WheelJointDef,Fr=e.b2World,Jr=e.b2WorldManifold,kr=e.b2_180_over_pi,qr=e.b2_aabbExtension,Or=e.b2_aabbMultiplier,zr=e.b2_angularSleepTolerance,jr=e.b2_angularSlop,Nr=e.b2_augment,Er=e.b2_baumgarte,Zr=e.b2_epsilon,Wr=e.b2_epsilon_sq,Xr=e.b2_lengthUnitsPerMeter,Ur=e.b2_linearSleepTolerance,Qr=e.b2_linearSlop,Kr=e.b2_maxAngularCorrection,Hr=e.b2_maxFloat,Yr=e.b2_maxLinearCorrection,$r=e.b2_maxManifoldPoints,ta=e.b2_maxPolygonVertices,ea=e.b2_maxRotation,sa=e.b2_maxRotationSquared,ia=e.b2_maxSubSteps,oa=e.b2_maxTOIContacts,na=e.b2_maxTranslation,ra=e.b2_maxTranslationSquared,aa=e.b2_minPulleyLength,ca=e.b2_pi_over_180,ma=e.b2_polygonRadius,la=e.b2_timeToSleep,ha=e.b2_toiBaumgarte,_a=e.b2_two_pi,ba=e.b2_version,ua=e.debugColors;export{po as DrawAABBs,yo as DrawCenterOfMasses,Ao as DrawJoints,xo as DrawPairs,Vo as DrawShapes,So as GetShapeColor,vo as __esModule,fo as b2AABB,Co as b2AngularStiffness,Bo as b2AreaJoint,wo as b2AreaJointDef,go as b2Assert,Mo as b2BendingModel,Io as b2Body,To as b2BodyType,Do as b2BroadPhase,Go as b2ChainShape,Po as b2CircleShape,Ro as b2Clamp,Lo as b2ClipSegmentToLine,Fo as b2ClipVertex,Jo as b2CollideCircles,ko as b2CollideEdgeAndCircle,qo as b2CollideEdgeAndPolygon,Oo as b2CollidePolygonAndCircle,zo as b2CollidePolygons,jo as b2Color,No as b2Contact,Eo as b2ContactEdge,Zo as b2ContactFactory,Wo as b2ContactFeature,Xo as b2ContactFeatureType,Uo as b2ContactFilter,Qo as b2ContactID,Ko as b2ContactImpulse,Ho as b2ContactListener,Yo as b2ContactManager,$o as b2DefaultFilter,tn as b2DegToRad,en as b2DestructionListener,sn as b2Distance,on as b2DistanceInput,nn as b2DistanceJoint,rn as b2DistanceJointDef,an as b2DistanceOutput,cn as b2DistanceProxy,mn as b2DynamicTree,ln as b2EdgeShape,hn as b2Fixture,_n as b2FixtureProxy,bn as b2FrictionJoint,un as b2FrictionJointDef,dn as b2GearJoint,pn as b2GearJointDef,yn as b2GetBlockSolve,An as b2GetPointStates,xn as b2Gjk,Vn as b2IsPowerOfTwo,Sn as b2Joint,vn as b2JointDef,fn as b2JointEdge,Cn as b2JointType,Bn as b2LinearStiffness,wn as b2MakeArray,gn as b2MakeBooleanArray,Mn as b2MakeNumberArray,In as b2Manifold,Tn as b2ManifoldPoint,Dn as b2ManifoldType,Gn as b2MassData,Pn as b2Mat22,Rn as b2Mat33,Ln as b2MixFriction,Fn as b2MixRestitution,Jn as b2MixRestitutionThreshold,kn as b2MotorJoint,qn as b2MotorJointDef,On as b2MouseJoint,zn as b2MouseJointDef,jn as b2NextPowerOfTwo,Nn as b2PointState,En as b2PolygonShape,Zn as b2Position,Wn as b2PrismaticJoint,Xn as b2PrismaticJointDef,Un as b2Profile,Qn as b2PulleyJoint,Kn as b2PulleyJointDef,Hn as b2RadToDeg,Yn as b2Random,$n as b2RandomFloat,tr as b2RandomInt,er as b2RayCastInput,sr as b2RayCastOutput,ir as b2RevoluteJoint,or as b2RevoluteJointDef,nr as b2Rope,rr as b2RopeTuning,ar as b2Rot,cr as b2SetBlockSolve,mr as b2Shape,lr as b2ShapeCast,hr as b2ShapeCastInput,_r as b2ShapeCastOutput,br as b2ShapeType,ur as b2SimplexCache,dr as b2SolverData,pr as b2StretchingModel,yr as b2Sweep,Ar as b2TOIInput,xr as b2TOIOutput,Vr as b2TOIOutputState,Sr as b2TestOverlap,vr as b2TimeOfImpact,fr as b2TimeStep,Cr as b2Timer,Br as b2Toi,wr as b2Transform,gr as b2TreeNode,Mr as b2Vec2,Ir as b2Vec3,Tr as b2Velocity,Dr as b2Verify,Gr as b2WeldJoint,Pr as b2WeldJointDef,Rr as b2WheelJoint,Lr as b2WheelJointDef,Fr as b2World,Jr as b2WorldManifold,kr as b2_180_over_pi,qr as b2_aabbExtension,Or as b2_aabbMultiplier,zr as b2_angularSleepTolerance,jr as b2_angularSlop,Nr as b2_augment,Er as b2_baumgarte,Zr as b2_epsilon,Wr as b2_epsilon_sq,Xr as b2_lengthUnitsPerMeter,Ur as b2_linearSleepTolerance,Qr as b2_linearSlop,Kr as b2_maxAngularCorrection,Hr as b2_maxFloat,Yr as b2_maxLinearCorrection,$r as b2_maxManifoldPoints,ta as b2_maxPolygonVertices,ea as b2_maxRotation,sa as b2_maxRotationSquared,ia as b2_maxSubSteps,oa as b2_maxTOIContacts,na as b2_maxTranslation,ra as b2_maxTranslationSquared,aa as b2_minPulleyLength,ca as b2_pi_over_180,ma as b2_polygonRadius,la as b2_timeToSleep,ha as b2_toiBaumgarte,_a as b2_two_pi,ba as b2_version,ua as debugColors,e as default};
//# sourceMappingURL=/sm/b3a431d4be17bbf71966eab2dec4ae47ce39e4b7bd2849594f93bb9d0e67dcdc.map